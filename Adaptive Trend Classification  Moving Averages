Adaptive Trend Classification: Moving Averages [InvestorUnknown]

// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © InvestorUnknown | TRW @Andrej S.
//
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //
//                                                                                   //
//      _       _              _    _             _____                    _         //
//     /_\   __| | __ _  _ __ | |_ (_)__ __ ___  |_   _|_ _  ___  _ _   __| |        //
//    / _ \ / _` |/ _` || '_ \|  _|| |\ V // -_)   | | | '_|/ -_)| ' \ / _` |        //
//   /_/ \_\\__,_|\__,_|| .__/ \__||_| \_/ \___|   |_| |_|  \___||_||_|\__,_|        //
//                     |_|                                                           //
//         ___  _            _   __  _            _    _             _               //
//        / __|| | __ _  ___(_) / _|(_) __  __ _ | |_ (_) ___  _ _  (_)              //
//       | (__ | |/ _` |(_-<| ||  _|| |/ _|/ _` ||  _|| |/ _ \| ' \  _               //
//        \___||_|\__,_|/__/|_||_|  |_|\__|\__,_| \__||_|\___/|_||_|(_)              //
//                                                                                   //
//  __  __            _                 _                                            //
// |  \/  | ___ __ __(_) _ _   __ _    /_\ __ __ ___  _ _  __ _  __ _  ___  ___      //
// | |\/| |/ _ \\ V /| || ' \ / _` |  / _ \\ V // -_)| '_|/ _` |/ _` |/ -_)(_-<      //
// |_|  |_|\___/ \_/ |_||_||_|\__, | /_/ \_\\_/ \___||_|  \__,_|\__, |\___|/__/      //
//                            |___/                             |___/                //
//                                                                                   //
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //
//
// General Logic:
//
// This indicator exhibits two layers of adaptability:
//
// Adaptability of the Moving Average Types and Lengths: This enhances the robustness of the indicator by allowing for different lengths of moving averages.
// Adaptability of the Moving Average Types Themselves: The final signal is derived from an average based on weights assigned across both layers.
//
// The primary objective of investing is capital multiplication. Therefore, the weights of the indicators are based on the equity they generate. 
// To mitigate the influence of extreme past performances, a cutout period is introduced. 
// This period allows for the exclusion of a customizable number of bars from the beginning of the asset's price history.
//
// To maintain adaptability, the weights incorporate a natural decay rate that can be modified through input parameters. 
// This decay ensures that historical performance does not disproportionately influence current calculations. 
// Furthermore, the exponential growth of current and future performance can be adjusted via inputs, 
// ensuring that more recent performance has a greater impact, both positively and negatively.
//
// Overall, this indicator dynamically adjusts its calculations based on input settings 
// to provide robust and adaptable signals by leveraging various types of moving averages.
//
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //
//
//
//@version=5
indicator("Adaptive Trend Classification: Moving Averages [InvestorUnknown]",shorttitle = "ATC: MA", overlay = true, max_labels_count = 500, precision = 3, max_bars_back = 5000)

// - - - - - USER INPUTS - - - - - //{

// Adaptability Inputs
La = input.float(0.02, "λ (Lambda)", step = 0.005, minval = 0.005, maxval = 0.5, group = "Adaptability Settings", 
 tooltip = "Specifies the growth rate used in the exponential growth calculation. Adjust this to control the rate at which the growth factor increases.") / 1000
De = input.float(0.03,     "Decay (%)", step = 0.01,     minval = 0.01,     maxval = 0.25,   group = "Adaptability Settings", 
 tooltip = "Determines the depreciation rate applied to the equity over time. A higher value increases the rate of depreciation, reducing the equity more quickly.") / 100
cutout = input.int(0, "CutOut Period", group = "Adaptability Settings", 
 tooltip = "Sets the period after which the equity calculations start. This allows you to ignore initial periods and focus on a specific time range for equity computation.")
robustness = input.string("Medium", "Robustness Lengths", options = ["Narrow", "Medium", "Wide"], group = "Adaptability Settings", 
 tooltip = "Defines the range of robustness for the equity calculation. 'Narrow' provides precise adjustments, 'Medium' offers balanced adjustments, and 'Wide' allows for more flexible adjustments.")
Long_threshold  = input.float(0.1,  "Long Threshold",  step = 0.01, group = "Adaptability Settings")
Short_threshold = input.float(-0.1, "Short Threshold", step = 0.01, group = "Adaptability Settings")
src = input.source(close, "Calculation Source", group = "Adaptability Settings")

// Moving Averages Inputs
ema_len  = input.int(28, "EMA Length",  inline = "E", group = "Moving Averages Settings"), ema_w  = input.float(1.0, "Weight", step = 0.1, inline = "E", group = "Moving Averages Settings", tooltip = "Initial Weight on the average signal")
hull_len = input.int(28, "HULL Length", inline = "H", group = "Moving Averages Settings"), hma_w =  input.float(1.0, "Weight", step = 0.1, inline = "H", group = "Moving Averages Settings", tooltip = "Initial Weight on the average signal")
wma_len  = input.int(28, "WMA Length",  inline = "W", group = "Moving Averages Settings"), wma_w  = input.float(1.0, "Weight", step = 0.1, inline = "W", group = "Moving Averages Settings", tooltip = "Initial Weight on the average signal")
dema_len = input.int(28, "DEMA Length", inline = "D", group = "Moving Averages Settings"), dema_w = input.float(1.0, "Weight", step = 0.1, inline = "D", group = "Moving Averages Settings", tooltip = "Initial Weight on the average signal")
lsma_len = input.int(28, "LSMA Length", inline = "L", group = "Moving Averages Settings"), lsma_w = input.float(1.0, "Weight", step = 0.1, inline = "L", group = "Moving Averages Settings", tooltip = "Initial Weight on the average signal")
kama_len = input.int(28, "KAMA Length", inline = "K", group = "Moving Averages Settings"), kama_w = input.float(1.0, "Weight", step = 0.1, inline = "K", group = "Moving Averages Settings", tooltip = "Initial Weight on the average signal")

// Calibration Mode Indputs
calibrate = input.bool(false, "Calibration Mode", group = "Calibration Mode", inline = "CA", 
 tooltip = "Use this mode for calibrating inputs to fit your desired signal period.")
calfor = input.string("EMA", "Calibrate:", options = ["EMA", "HMA", "WMA", "DEMA", "LSMA", "KAMA"], group = "Calibration Mode", inline = "CA")
strategy = input.bool(false,"Strategy View?", group = "Calibration Mode", tooltip = "Strategy View shifts Entries and Exits by one bar and forces non-repainting, use this for backtesting and calibrating.")

// Tables Inputs
tables_mode = input.string("Dark", "Table Colors", options = ["Light", "Dark"], group = "Tables")
string modeSwitch1  = input.string('Top Right', title='Weight Table', options=['Center Top', 'Center Bottom', 'Middle Left', 'Middle Right','Bottom Right','Bottom Left','Top Left','Top Right'], group = "Tables", inline = "T1")
string position1 = switch modeSwitch1
    'Center Top'    => position.top_center
    'Center Bottom' => position.bottom_center 
    'Middle Left'   => position.middle_left
    'Middle Right'  => position.middle_right
    'Bottom Right'  => position.bottom_right
    'Top Left'      => position.top_left
    'Top Right'     => position.top_right
    "Bottom Left"   => position.bottom_left
plot_t1 = input.bool(true, "Plot?", group = "Tables", inline = "T1")
string modeSwitch2  = input.string('Middle Right', title='Exp. Mult. Table', options=['Center Top', 'Center Bottom', 'Middle Left', 'Middle Right','Bottom Right','Bottom Left','Top Left','Top Right'], group = "Tables", inline = "T2")
string position2 = switch modeSwitch2 
    'Center Top'    => position.top_center
    'Center Bottom' => position.bottom_center 
    'Middle Left'   => position.middle_left
    'Middle Right'  => position.middle_right
    'Bottom Right'  => position.bottom_right
    'Top Left'      => position.top_left
    'Top Right'     => position.top_right
    "Bottom Left"   => position.bottom_left
plot_t2 = input.bool(true, "Plot?", group = "Tables", inline = "T2")

// Visualization Inputs
colbars =  input.bool(true, "Color bars?", group = "Visualization", inline = "CB"),      colbase = input.string("Average", "Color bars from:", options = ["Average", "EMA", "HMA", "WMA", "DEMA", "LSMA", "KAMA"], group = "Visualization", inline = "CB")
plot_ema = input.bool(true, "Plot EMA?",   group = "Visualization", inline = "P1"),      plot_hma =  input.bool(true, "Plot HMA?",  group = "Visualization", inline = "P1")
plot_wma = input.bool(true, "Plot WMA?",   group = "Visualization", inline = "P2"),      plot_dema = input.bool(true, "Plot DEMA?", group = "Visualization", inline = "P2")
plot_lsma = input.bool(true, "Plot LSMA?", group = "Visualization", inline = "P3"),      plot_kama = input.bool(true, "Plot KAMA?", group = "Visualization", inline = "P3")
colup =  input.color(color.green, "Bull Color", group = "Visualization", inline = "C")
coldw =  input.color(color.red, "Bear Color",   group = "Visualization", inline = "C")
arrow =  input.bool(true, "Plot Signal Arrows?",  group = "Visualization")
labels = input.bool(true, "Plot Signal Labels?",  group = "Visualization")

// Alerts Inputs
alertbase = input.string("Average", "Alert from:", options = ["Average", "EMA", "HMA", "WMA", "DEMA", "LSMA", "KAMA"], group = "Alerts")
//}

// - - - - - IMPORTS & CUSTOM FUNCTIONS - - - - - //{

// Imports
import TradingView/ta/7 as ta

// Custom functions

// Function to calculate the rate of change
R = (close - close[1]) / close[1]

// Linear regression function
lsma(source,length) =>
    lsma = ta.linreg(source, length, 0)
    lsma

// Kaufman's Adaptive Moving Average (KAMA) function
kama(source, length) =>
    fast= 0.666
    slow = 0.064
    noisex = math.abs(source - source[1])
    KAMA = 0.0
    signal = math.abs(source - source[length])
    noise = math.sum(noisex, length)
    ratio = noise != 0 ? signal / noise : 0
    smooth = math.pow(ratio * (fast - slow) + slow, 2)
    KAMA := nz(KAMA[1]) + smooth * (source - nz(KAMA[1]))
    KAMA

// Function to determine lengths for moving averages based on robustness level
diflen(length) =>
    int L1 = na,       int L_1 = na
    int L2 = na,       int L_2 = na
    int L3 = na,       int L_3 = na
    int L4 = na,       int L_4 = na
    if robustness == "Narrow"
        L1 := length + 1,        L_1 := length - 1
        L2 := length + 2,        L_2 := length - 2
        L3 := length + 3,        L_3 := length - 3
        L4 := length + 4,        L_4 := length - 4
    else if robustness == "Medium"
        L1 := length + 1,        L_1 := length - 1
        L2 := length + 2,        L_2 := length - 2
        L3 := length + 4,        L_3 := length - 4
        L4 := length + 6,        L_4 := length - 6
    else
        L1 := length + 1,        L_1 := length - 1
        L2 := length + 3,        L_2 := length - 3
        L3 := length + 5,        L_3 := length - 5
        L4 := length + 7,        L_4 := length - 7        

    [L1,L2,L3,L4,L_1,L_2,L_3,L_4]

// Function to display correct ρ in the table
p(n, robustness, pos) =>
    string p = na,         string p_ = na
    if n == 1 
        p := "+1ρ",          p_ := "-1ρ"
    else if n == 2
        if not (robustness == "Wide")
            p := "+2ρ",          p_ := "-2ρ"            
        else 
            p := "+3ρ",          p_ := "-3ρ"            
    else if n == 3
        if robustness == "Narrow"
            p := "+3ρ",          p_ := "-3ρ"          
        else if robustness == "Medium"
            p := "+4ρ",          p_ := "-4ρ"       
        else
            p := "+5ρ",          p_ := "-5ρ"            
    else
        if robustness == "Narrow"
            p := "+4ρ",          p_ := "-4ρ"  
        else if robustness == "Medium"
            p := "+6ρ",          p_ := "-6ρ"  
        else 
            p := "+7ρ",          p_ := "-7ρ"  
    ex = pos == "+" ? p : p_
    ex
     
  // Function to calculate different types of moving averages
ma_calculation(source, length, ma_type) =>
    if ma_type == "EMA"
        ta.ema(source, length)
    else if ma_type == "HMA"
        ta.sma(source, length)
    else if ma_type == "WMA"
        ta.wma(source, length)
    else if ma_type == "DEMA"
        ta.dema(source, length)
    else if ma_type == "LSMA"
        lsma(source,length)
    else if ma_type == "KAMA"
        kama(source, length)
    else
        na

// Function to create a set of moving averages with different lengths
SetOfMovingAverages(length, source, ma_type) =>
    [L1,L2,L3,L4,L_1,L_2,L_3,L_4] = diflen(length)
    MA   = ma_calculation(source,  length, ma_type)
    MA1  = ma_calculation(source,  L1,     ma_type)
    MA2  = ma_calculation(source,  L2,     ma_type)
    MA3  = ma_calculation(source,  L3,     ma_type)
    MA4  = ma_calculation(source,  L4,     ma_type)
    MA_1 = ma_calculation(source, L_1,     ma_type)
    MA_2 = ma_calculation(source, L_2,     ma_type)
    MA_3 = ma_calculation(source, L_3,     ma_type)
    MA_4 = ma_calculation(source, L_4,     ma_type)
    [MA, MA1, MA2, MA3, MA4, MA_1, MA_2, MA_3, MA_4]

// The function `e(L)` calculates an exponential growth factor based on the current bar index and a given growth rate `L`.
e(L) =>
    // Calculate the number of bars elapsed.
    // If the `bar_index` is 0 (i.e., the very first bar), set `bars` to 1 to avoid division by zero.
    bars = bar_index == 0 ? 1 : bar_index    
    // Define the cuttime time using the `cutout` parameter, which specifies how many bars will be cut out off the time series.
    cuttime = time[cutout]    
    // Initialize the exponential growth factor `x` to 1.0.
    x = 1.0    
    // Check if `cuttime` is not `na` and the current time is greater than or equal to `cuttime`.
    if not na(cuttime) and time >= cuttime
        // Use the mathematical constant `e` raised to the power of `L * (bar_index - cutout)`.
        // This represents exponential growth over the number of bars since the `cutout`.
        x := math.pow(math.e, L * (bar_index - cutout))    
    x

// Function to generate signals based on crossovers
signal(ma) =>
    var int sig = 0
    if ta.crossover(close, ma)
        sig := 1
    if ta.crossunder(close, ma)
        sig := -1
    sig

// This function calculates the equity based on the starting equity, signals, and rate of change (R).
eq(starting_equity, sig, R) =>
    cuttime = time[cutout]
    if not na(cuttime) and time >= cuttime
        // Calculate the rate of return `r` by multiplying the rate of change `R` with the exponential growth factor `e(La)`.
        r = R * e(La)
        // Calculate the depreciation factor `d` as 1 minus the depreciation rate `De`.
        d = 1 - De
        var float a = 0.0
        // If the previous signal `sig[1]` is positive, set `a` to `r`.
        if (sig[1] > 0)
            a := r
        // If the previous signal `sig[1]` is negative, set `a` to `-r`.
        else if (sig[1] < 0)
            a := -r
        // Declare the variable `e` to store equity and initialize it to `na`.
        var float e = na
        // If `e[1]` (the previous equity value) is not available (first calculation):
        if na(e[1])
            e := starting_equity
        else
            // Update `e` based on the previous equity value, depreciation factor `d`, and adjustment factor `a`.
            e := (e[1] * d) * (1 + a)
        // Ensure `e` does not drop below 0.25.
        if (e < 0.25)
            e := 0.25
        e
    else
        na

// Function to calculate weighted signal from multiple moving averages
Signal(m1, w1, m2, w2, m3, w3, m4, w4, m5, w5, m6, w6, m7, w7, m8, w8, m9, w9) =>
    n = (m1*w1) + (m2*w2) + (m3*w3) + (m4*w4) + (m5*w5) + (m6*w6) + (m7*w7) + (m8*w8) + (m9*w9)
    d = w1 + w2 + w3 + w4 + w5 + w6 + w7 + w8 + w9
    sig = math.round(n/d,2)
    sig

// Function to generate cut-off signal
Cut(x) =>
    c = x > 0.49 ? 1 : x < -0.49 ? - 1 : 0
    c

// Function to determine trend color based on signal
trendcol(signal) =>
    c = strategy ? (signal[1] > 0 ? colup : coldw) : (signal > 0) ? colup : coldw
//}

// - - - - - DECLARE MOVING AVERAGES - - - - - //{
[EMA,   EMA1,  EMA2,  EMA3,  EMA4,  EMA_1,  EMA_2,  EMA_3,  EMA_4] = SetOfMovingAverages(ema_len,  src,  "EMA")
[HMA,   HMA1,  HMA2,  HMA3,  HMA4,  HMA_1,  HMA_2,  HMA_3,  HMA_4] = SetOfMovingAverages(hull_len, src,  "HMA")
[WMA,   WMA1,  WMA2,  WMA3,  WMA4,  WMA_1,  WMA_2,  WMA_3,  WMA_4] = SetOfMovingAverages(wma_len,  src,  "WMA")
[DEMA, DEMA1, DEMA2, DEMA3, DEMA4, DEMA_1, DEMA_2, DEMA_3, DEMA_4] = SetOfMovingAverages(dema_len, src, "DEMA")
[LSMA, LSMA1, LSMA2, LSMA3, LSMA4, LSMA_1, LSMA_2, LSMA_3, LSMA_4] = SetOfMovingAverages(lsma_len, src, "LSMA")
[KAMA, KAMA1, KAMA2, KAMA3, KAMA4, KAMA_1, KAMA_2, KAMA_3, KAMA_4] = SetOfMovingAverages(kama_len, src, "KAMA")
//}

// - - - - - MAIN CALCULATIONS - - - - - //{

// Adaptability Layer 1

// EMA
E   = eq(1, signal(EMA),   R),      sE   =  signal(EMA)
E1  = eq(1, signal(EMA1),  R),      sE1  =  signal(EMA1)
E2  = eq(1, signal(EMA2),  R),      sE2  =  signal(EMA2)
E3  = eq(1, signal(EMA3),  R),      sE3  =  signal(EMA3)
E4  = eq(1, signal(EMA4),  R),      sE4  =  signal(EMA4)
E_1 = eq(1, signal(EMA_1), R),      sE_1 =  signal(EMA_1)
E_2 = eq(1, signal(EMA_2), R),      sE_2 =  signal(EMA_2)
E_3 = eq(1, signal(EMA_3), R),      sE_3 =  signal(EMA_3)
E_4 = eq(1, signal(EMA_4), R),      sE_4 =  signal(EMA_4)

EMA_Signal = Signal(sE, E, sE1, E1, sE2, E2, sE3, E3, sE4, E4, sE_1, E_1, sE_2, E_2, sE_3, E_3, sE_4, E_4)


// HMA
H   = eq(1, signal(HMA),   R),      sH   =  signal(HMA)
H1  = eq(1, signal(HMA1),  R),      sH1  =  signal(HMA1)
H2  = eq(1, signal(HMA2),  R),      sH2  =  signal(HMA2)
H3  = eq(1, signal(HMA3),  R),      sH3  =  signal(HMA3)
H4  = eq(1, signal(HMA4),  R),      sH4  =  signal(HMA4)
H_1 = eq(1, signal(HMA_1), R),      sH_1 =  signal(HMA_1)
H_2 = eq(1, signal(HMA_2), R),      sH_2 =  signal(HMA_2)
H_3 = eq(1, signal(HMA_3), R),      sH_3 =  signal(HMA_3)
H_4 = eq(1, signal(HMA_4), R),      sH_4 =  signal(HMA_4)

HMA_Signal = Signal(sH, H, sH1, H1, sH2, H2, sH3, H3, sH4, H4, sH_1, H_1, sH_2, H_2, sH_3, H_3, sH_4, H_4)


// WMA
W   = eq(1, signal(WMA),   R),      sW   =  signal(WMA)
W1  = eq(1, signal(WMA1),  R),      sW1  =  signal(WMA1)
W2  = eq(1, signal(WMA2),  R),      sW2  =  signal(WMA2)
W3  = eq(1, signal(WMA3),  R),      sW3  =  signal(WMA3)
W4  = eq(1, signal(WMA4),  R),      sW4  =  signal(WMA4)
W_1 = eq(1, signal(WMA_1), R),      sW_1 =  signal(WMA_1)
W_2 = eq(1, signal(WMA_2), R),      sW_2 =  signal(WMA_2)
W_3 = eq(1, signal(WMA_3), R),      sW_3 =  signal(WMA_3)
W_4 = eq(1, signal(WMA_4), R),      sW_4 =  signal(WMA_4)

WMA_Signal = Signal(sW, W, sW1, W1, sW2, W2, sW3, W3, sW4, W4, sW_1, W_1, sW_2, W_2, sW_3, W_3, sW_4, W_4)


// DEMA
D   = eq(1, signal(DEMA),   R),      sD   =  signal(DEMA)
D1  = eq(1, signal(DEMA1),  R),      sD1  =  signal(DEMA1)
D2  = eq(1, signal(DEMA2),  R),      sD2  =  signal(DEMA2)
D3  = eq(1, signal(DEMA3),  R),      sD3  =  signal(DEMA3)
D4  = eq(1, signal(DEMA4),  R),      sD4  =  signal(DEMA4)
D_1 = eq(1, signal(DEMA_1), R),      sD_1 =  signal(DEMA_1)
D_2 = eq(1, signal(DEMA_2), R),      sD_2 =  signal(DEMA_2)
D_3 = eq(1, signal(DEMA_3), R),      sD_3 =  signal(DEMA_3)
D_4 = eq(1, signal(DEMA_4), R),      sD_4 =  signal(DEMA_4)

DEMA_Signal = Signal(sD, D, sD1, D1, sD2, D2, sD3, D3, sD4, D4, sD_1, D_1, sD_2, D_2, sD_3, D_3, sD_4, D_4)


// LSMA
L   = eq(1, signal(LSMA),   R),      sL   =  signal(LSMA)
L1  = eq(1, signal(LSMA1),  R),      sL1  =  signal(LSMA1)
L2  = eq(1, signal(LSMA2),  R),      sL2  =  signal(LSMA2)
L3  = eq(1, signal(LSMA3),  R),      sL3  =  signal(LSMA3)
L4  = eq(1, signal(LSMA4),  R),      sL4  =  signal(LSMA4)
L_1 = eq(1, signal(LSMA_1), R),      sL_1 =  signal(LSMA_1)
L_2 = eq(1, signal(LSMA_2), R),      sL_2 =  signal(LSMA_2)
L_3 = eq(1, signal(LSMA_3), R),      sL_3 =  signal(LSMA_3)
L_4 = eq(1, signal(LSMA_4), R),      sL_4 =  signal(LSMA_4)

LSMA_Signal = Signal(sL, L, sL1, L1, sL2, L2, sL3, L3, sL4, L4, sL_1, L_1, sL_2, L_2, sL_3, L_3, sL_4, L_4)


// KAMA
K   = eq(1, signal(KAMA),   R),      sK   =  signal(KAMA)
K1  = eq(1, signal(KAMA1),  R),      sK1  =  signal(KAMA1)
K2  = eq(1, signal(KAMA2),  R),      sK2  =  signal(KAMA2)
K3  = eq(1, signal(KAMA3),  R),      sK3  =  signal(KAMA3)
K4  = eq(1, signal(KAMA4),  R),      sK4  =  signal(KAMA4)
K_1 = eq(1, signal(KAMA_1), R),      sK_1 =  signal(KAMA_1)
K_2 = eq(1, signal(KAMA_2), R),      sK_2 =  signal(KAMA_2)
K_3 = eq(1, signal(KAMA_3), R),      sK_3 =  signal(KAMA_3)
K_4 = eq(1, signal(KAMA_4), R),      sK_4 =  signal(KAMA_4)

KAMA_Signal = Signal(sK, K, sK1, K1, sK2, K2, sK3, K3, sK4, K4, sK_1, K_1, sK_2, K_2, sK_3, K_3, sK_4, K_4)


// Adaptability Layer 2
EMA_S =  eq(ema_w,  EMA_Signal,  R)
HMA_S =  eq(hma_w,  HMA_Signal,  R)
WMA_S =  eq(wma_w,  WMA_Signal,  R)
DEMA_S = eq(dema_w, DEMA_Signal, R)
LSMA_S = eq(lsma_w, LSMA_Signal, R)
KAMA_S = eq(kama_w, KAMA_Signal, R)


// FINAL CALCULATIONS
nom = (Cut(EMA_Signal) * EMA_S) + (Cut(HMA_Signal) * HMA_S) + (Cut(WMA_Signal) * WMA_S) + (Cut(DEMA_Signal) * DEMA_S) + (Cut(LSMA_Signal) * LSMA_S) + (Cut(KAMA_Signal) * KAMA_S)  
den = (EMA_S + HMA_S + WMA_S + DEMA_S + LSMA_S + KAMA_S)
Average_Signal = nom / den
//}

// - - - - - CALIBRATION MODE - - - - - //{

// Declare values for plots
float  cal = na,                                int scal =  na 
float cal1 = na,      float cal_1 = na,         int scal1 = na,     int scal_1 = na 
float cal2 = na,      float cal_2 = na,         int scal2 = na,     int scal_2 = na
float cal3 = na,      float cal_3 = na,         int scal3 = na,     int scal_3 = na
float cal4 = na,      float cal_4 = na,         int scal4 = na,     int scal_4 = na

// Overwrite the declared values based on calfor value
if calibrate and calfor == "EMA"
    cal  :=  EMA,                               scal  := sE
    cal1 := EMA1,       cal_1 := EMA_1,         scal1 := sE1,       scal_1 := sE_1
    cal2 := EMA2,       cal_2 := EMA_2,         scal2 := sE2,       scal_2 := sE_2
    cal3 := EMA3,       cal_3 := EMA_3,         scal3 := sE3,       scal_3 := sE_3
    cal4 := EMA4,       cal_4 := EMA_4,         scal4 := sE4,       scal_4 := sE_4
else if calibrate and calfor == "HMA"
    cal  :=  HMA,                               scal  := sH
    cal1 := HMA1,       cal_1 := HMA_1,         scal1 := sH1,       scal_1 := sH_1
    cal2 := HMA2,       cal_2 := HMA_2,         scal2 := sH2,       scal_2 := sH_2
    cal3 := HMA3,       cal_3 := HMA_3,         scal3 := sH3,       scal_3 := sH_3
    cal4 := HMA4,       cal_4 := HMA_4,         scal4 := sH4,       scal_4 := sH_4    
else if calibrate and calfor == "WMA"
    cal  :=  WMA,                               scal  := sW
    cal1 := WMA1,       cal_1 := WMA_1,         scal1 := sW1,       scal_1 := sW_1
    cal2 := WMA2,       cal_2 := WMA_2,         scal2 := sW2,       scal_2 := sW_2
    cal3 := WMA3,       cal_3 := WMA_3,         scal3 := sW3,       scal_3 := sW_3
    cal4 := WMA4,       cal_4 := WMA_4,         scal4 := sW4,       scal_4 := sW_4 
else if calibrate and calfor == "DEMA"
    cal  :=  DEMA,                              scal  := sD
    cal1 := DEMA1,       cal_1 := DEMA_1,       scal1 := sD1,       scal_1 := sD_1
    cal2 := DEMA2,       cal_2 := DEMA_2,       scal2 := sD2,       scal_2 := sD_2
    cal3 := DEMA3,       cal_3 := DEMA_3,       scal3 := sD3,       scal_3 := sD_3
    cal4 := DEMA4,       cal_4 := DEMA_4,       scal4 := sD4,       scal_4 := sD_4
else if calibrate and calfor == "LSMA"
    cal  :=  LSMA,                              scal  := sL
    cal1 := LSMA1,       cal_1 := LSMA_1,       scal1 := sL1,       scal_1 := sL_1
    cal2 := LSMA2,       cal_2 := LSMA_2,       scal2 := sL2,       scal_2 := sL_2
    cal3 := LSMA3,       cal_3 := LSMA_3,       scal3 := sL3,       scal_3 := sL_3
    cal4 := LSMA4,       cal_4 := LSMA_4,       scal4 := sL4,       scal_4 := sL_4
else if calibrate and calfor == "KAMA"
    cal  :=  KAMA,                              scal  := sK
    cal1 := KAMA1,       cal_1 := KAMA_1,       scal1 := sK1,       scal_1 := sK_1
    cal2 := KAMA2,       cal_2 := KAMA_2,       scal2 := sK2,       scal_2 := sK_2
    cal3 := KAMA3,       cal_3 := KAMA_3,       scal3 := sK3,       scal_3 := sK_3
    cal4 := KAMA4,       cal_4 := KAMA_4,       scal4 := sK4,       scal_4 := sK_4
else
    na

// Plot the values
plot(cal, "Calibration (Main)", color = trendcol(scal))
plot(cal1, "Calibration +1ρ",   color = trendcol(scal1))
plot(cal2, "Calibration +2ρ",   color = trendcol(scal2))
plot(cal3, "Calibration +3ρ",   color = trendcol(scal3))
plot(cal4, "Calibration +4ρ",   color = trendcol(scal4))
plot(cal_1, "Calibration -1ρ",  color = trendcol(scal_1))
plot(cal_2, "Calibration -2ρ",  color = trendcol(scal_2))
plot(cal_3, "Calibration -3ρ",  color = trendcol(scal_3))
plot(cal_4, "Calibration -4ρ",  color = trendcol(scal_4))
//}

// - - - - - Visualization - - - - - //{

// Visualization code
float cols = na
if colbase == "Average"
    cols := Average_Signal
else if colbase == "EMA"
    cols := EMA_Signal
else if colbase == "HMA"
    cols := HMA_Signal
else if colbase == "WMA"
    cols := WMA_Signal
else if colbase == "DEMA"
    cols := DEMA_Signal
else if colbase == "LSMA"
    cols := LSMA_Signal
else if colbase == "KAMA"
    cols := KAMA_Signal
else
    na

col = color.from_gradient(cols, -1, 1, coldw, colup)
label.new(bar_index, (strategy ? cols[1] : cols) > 0 ? high : low, text = labels ? str.tostring(math.round((strategy ? cols[1] : cols), 1)) : na, 
     xloc= xloc.bar_index, yloc = (strategy ? cols[1] : cols) > 0.01 ? yloc.abovebar : yloc.belowbar, style = label.style_none, textcolor = strategy ? col[1] : col, size = size.normal) 

// Plot Moving Averages
plot(calibrate ? na : (plot_ema  ? EMA  : na),   "EMA", color =  trendcol(sE))
plot(calibrate ? na : (plot_hma  ? HMA  : na),   "HMA", color =  trendcol(sH))
plot(calibrate ? na : (plot_wma  ? WMA  : na),   "WMA", color =  trendcol(sW))
plot(calibrate ? na : (plot_dema ? DEMA : na), "DEMA", color = trendcol(sD))
plot(calibrate ? na : (plot_lsma ? LSMA : na), "LSMA", color = trendcol(sL))
plot(calibrate ? na : (plot_kama ? KAMA : na), "KAMA", color = trendcol(sK))

// Avoid multiple signals in the same direction
var int direction = na
if ta.crossover(strategy ? cols[1] : cols, Long_threshold)
    direction :=  1
if ta.crossunder(strategy ? cols[1] : cols, Short_threshold)
    direction := -1

// Plot Signals
plotchar(direction[1] == -1 and (arrow ? ta.crossover(strategy ?  cols[1] : cols,  Long_threshold) : na), char = "▲", size = size.tiny, color = colup, location = location.belowbar)
plotchar(direction[1] ==  1 and (arrow ? ta.crossunder(strategy ? cols[1] : cols, Short_threshold) : na),char = "▼", size = size.tiny, color = coldw, location = location.abovebar)
barcolor(colbars ? (strategy ? col[1] : col) : na)
//}

// - - - - - TABLES - - - - -//{

// Code for tables
textcol = tables_mode == "Dark" ? color.white : color.black
warning1 =   e(La) > 1.25 ? "☠️"  : e(La) > 1.1 ? "❗" : ""
warning2 =   e(La) > 1.25 ? "Exp Mult. is way too high, reduce λ"  : e(La) > 1.1 ? "Exp Mult. is too high, reduce λ" : ""
warning3 =   e(La) > 1.25 ? "(Lambda) or increase CutOut Period,"  : e(La) > 1.1 ? "(Lambda) or increase CutOut Period" : ""
warningcol = e(La) > 1.25 ? color.red  : e(La) > 1.1 ? color.orange : textcol

// Table 1 - Weights
var table WT = table.new(position1, 13,13)
if barstate.islast and plot_t1
    // Headers
    table.cell(WT, 0,  0, text = "MA",    text_color = textcol, text_size = size.small)
    table.cell(WT, 1,  0, text = "Trend", text_color = textcol, text_size = size.small)
    table.cell(WT, 2,  0, text = "γ",     text_color = textcol, text_size = size.small)
    table.cell(WT, 3,  0, text = "",      text_color = textcol, text_size = size.small, width = 1)
    table.cell(WT, 4,  0, text = p(4, robustness, "+"),   text_color = textcol, text_size = size.small)
    table.cell(WT, 5,  0, text = p(3, robustness, "+"),   text_color = textcol, text_size = size.small)
    table.cell(WT, 6,  0, text = p(2, robustness, "+"),   text_color = textcol, text_size = size.small)
    table.cell(WT, 7,  0, text = p(1, robustness, "+"),   text_color = textcol, text_size = size.small)
    table.cell(WT, 8,  0, text = "ρ",                     text_color = textcol, text_size = size.small)
    table.cell(WT, 9,  0, text = p(1, robustness, "-"),   text_color = textcol, text_size = size.small)
    table.cell(WT, 10, 0, text = p(2, robustness, "-"),   text_color = textcol, text_size = size.small)
    table.cell(WT, 11, 0, text = p(3, robustness, "-"),   text_color = textcol, text_size = size.small)
    table.cell(WT, 12, 0, text = p(4, robustness, "-"),   text_color = textcol, text_size = size.small)
    // EMA
    table.cell(WT, 0,  1, text =  "EMA", text_color = textcol, text_size = size.small)
    table.cell(WT, 1,  1, text =  str.tostring(EMA_Signal), text_color = trendcol(EMA_Signal), text_size = size.small)
    table.cell(WT, 2,  1, text =  str.tostring(math.round(EMA_S[1],2)),   text_color = textcol, text_size = size.small)
    table.cell(WT, 4,  1, text =  str.tostring(math.round(E4[1],2)),      text_color = trendcol(sE4),  text_size = size.small)
    table.cell(WT, 5,  1, text =  str.tostring(math.round(E3[1],2)),      text_color = trendcol(sE3),  text_size = size.small)
    table.cell(WT, 6,  1, text =  str.tostring(math.round(E2[1],2)),      text_color = trendcol(sE2),  text_size = size.small)
    table.cell(WT, 7,  1, text =  str.tostring(math.round(E1[1],2)),      text_color = trendcol(sE1),  text_size = size.small)
    table.cell(WT, 8,  1, text =  str.tostring(math.round(E[1],2)),       text_color = trendcol(sE),   text_size = size.small)    
    table.cell(WT, 9,  1, text =  str.tostring(math.round(E_1[1],2)),     text_color = trendcol(sE_1), text_size = size.small)
    table.cell(WT, 10, 1, text =  str.tostring(math.round(E_2[1],2)),     text_color = trendcol(sE_2), text_size = size.small)
    table.cell(WT, 11, 1, text =  str.tostring(math.round(E_3[1],2)),     text_color = trendcol(sE_3), text_size = size.small)
    table.cell(WT, 12, 1, text =  str.tostring(math.round(E_4[1],2)),     text_color = trendcol(sE_4), text_size = size.small)
    // HMA
    table.cell(WT, 0,  2, text =  "HMA", text_color = textcol, text_size = size.small)
    table.cell(WT, 1,  2, text =  str.tostring(HMA_Signal), text_color = trendcol(HMA_Signal), text_size = size.small)
    table.cell(WT, 2,  2, text =  str.tostring(math.round(HMA_S[1],2)),   text_color = textcol, text_size = size.small)
    table.cell(WT, 4,  2, text =  str.tostring(math.round(H4[1],2)),      text_color = trendcol(sH4),  text_size = size.small)
    table.cell(WT, 5,  2, text =  str.tostring(math.round(H3[1],2)),      text_color = trendcol(sH3),  text_size = size.small)
    table.cell(WT, 6,  2, text =  str.tostring(math.round(H2[1],2)),      text_color = trendcol(sH2),  text_size = size.small)
    table.cell(WT, 7,  2, text =  str.tostring(math.round(H1[1],2)),      text_color = trendcol(sH1),  text_size = size.small)
    table.cell(WT, 8,  2, text =  str.tostring(math.round(H[1],2)),       text_color = trendcol(sH),   text_size = size.small)
    table.cell(WT, 9,  2, text =  str.tostring(math.round(H_1[1],2)),     text_color = trendcol(sH_1), text_size = size.small)
    table.cell(WT, 10, 2, text =  str.tostring(math.round(H_2[1],2)),     text_color = trendcol(sH_2), text_size = size.small)
    table.cell(WT, 11, 2, text =  str.tostring(math.round(H_3[1],2)),     text_color = trendcol(sH_3), text_size = size.small)
    table.cell(WT, 12, 2, text =  str.tostring(math.round(H_4[1],2)),     text_color = trendcol(sH_4), text_size = size.small)    
    // WMA
    table.cell(WT, 0,  3, text =  "WMA", text_color = textcol, text_size = size.small)
    table.cell(WT, 1,  3, text =  str.tostring(WMA_Signal), text_color = trendcol(WMA_Signal), text_size = size.small)
    table.cell(WT, 2,  3, text =  str.tostring(math.round(WMA_S[1],2)),   text_color = textcol, text_size = size.small)
    table.cell(WT, 4,  3, text =  str.tostring(math.round(W4[1],2)),      text_color = trendcol(sW4),  text_size = size.small)
    table.cell(WT, 5,  3, text =  str.tostring(math.round(W3[1],2)),      text_color = trendcol(sW3),  text_size = size.small)
    table.cell(WT, 6,  3, text =  str.tostring(math.round(W2[1],2)),      text_color = trendcol(sW2),  text_size = size.small)
    table.cell(WT, 7,  3, text =  str.tostring(math.round(W1[1],2)),      text_color = trendcol(sW1),  text_size = size.small)
    table.cell(WT, 8,  3, text =  str.tostring(math.round(W[1],2)),       text_color = trendcol(sW),   text_size = size.small)
    table.cell(WT, 9,  3, text =  str.tostring(math.round(W_1[1],2)),     text_color = trendcol(sW_1), text_size = size.small)
    table.cell(WT, 10, 3, text =  str.tostring(math.round(W_2[1],2)),     text_color = trendcol(sW_2), text_size = size.small)
    table.cell(WT, 11, 3, text =  str.tostring(math.round(W_3[1],2)),     text_color = trendcol(sW_3), text_size = size.small)
    table.cell(WT, 12, 3, text =  str.tostring(math.round(W_4[1],2)),     text_color = trendcol(sW_4), text_size = size.small)     
    // DEMA
    table.cell(WT, 0,  4, text =  "DEMA", text_color = textcol, text_size = size.small)
    table.cell(WT, 1,  4, text =  str.tostring(DEMA_Signal), text_color = trendcol(DEMA_Signal), text_size = size.small)
    table.cell(WT, 2,  4, text =  str.tostring(math.round(DEMA_S[1],2)),   text_color = textcol, text_size = size.small)
    table.cell(WT, 4,  4, text =  str.tostring(math.round(D4[1],2)),       text_color = trendcol(sD4),  text_size = size.small)
    table.cell(WT, 5,  4, text =  str.tostring(math.round(D3[1],2)),       text_color = trendcol(sD3),  text_size = size.small)
    table.cell(WT, 6,  4, text =  str.tostring(math.round(D2[1],2)),       text_color = trendcol(sD2),  text_size = size.small)
    table.cell(WT, 7,  4, text =  str.tostring(math.round(D1[1],2)),       text_color = trendcol(sD1),  text_size = size.small)
    table.cell(WT, 8,  4, text =  str.tostring(math.round(D[1],2)),        text_color = trendcol(sD),   text_size = size.small)
    table.cell(WT, 9,  4, text =  str.tostring(math.round(D_1[1],2)),      text_color = trendcol(sD_1), text_size = size.small)
    table.cell(WT, 10, 4, text =  str.tostring(math.round(D_2[1],2)),      text_color = trendcol(sD_2), text_size = size.small)
    table.cell(WT, 11, 4, text =  str.tostring(math.round(D_3[1],2)),      text_color = trendcol(sD_3), text_size = size.small)
    table.cell(WT, 12, 4, text =  str.tostring(math.round(D_4[1],2)),      text_color = trendcol(sD_4), text_size = size.small)    
    // LSMA
    table.cell(WT, 0,  5, text =  "LSMA", text_color = textcol, text_size = size.small)
    table.cell(WT, 1,  5, text =  str.tostring(LSMA_Signal), text_color = trendcol(LSMA_Signal), text_size = size.small)
    table.cell(WT, 2,  5, text =  str.tostring(math.round(LSMA_S[1],2)),   text_color = textcol, text_size = size.small)
    table.cell(WT, 4,  5, text =  str.tostring(math.round(L4[1],2)),       text_color = trendcol(sL4),  text_size = size.small)
    table.cell(WT, 5,  5, text =  str.tostring(math.round(L3[1],2)),       text_color = trendcol(sL3),  text_size = size.small)
    table.cell(WT, 6,  5, text =  str.tostring(math.round(L2[1],2)),       text_color = trendcol(sL2),  text_size = size.small)
    table.cell(WT, 7,  5, text =  str.tostring(math.round(L1[1],2)),       text_color = trendcol(sL1),  text_size = size.small)
    table.cell(WT, 8,  5, text =  str.tostring(math.round(L[1],2)),        text_color = trendcol(sL),   text_size = size.small)
    table.cell(WT, 9,  5, text =  str.tostring(math.round(L_1[1],2)),      text_color = trendcol(sL_1), text_size = size.small)
    table.cell(WT, 10, 5, text =  str.tostring(math.round(L_2[1],2)),      text_color = trendcol(sL_2), text_size = size.small)
    table.cell(WT, 11, 5, text =  str.tostring(math.round(L_3[1],2)),      text_color = trendcol(sL_3), text_size = size.small)
    table.cell(WT, 12, 5, text =  str.tostring(math.round(L_4[1],2)),      text_color = trendcol(sL_4), text_size = size.small) 
    // KAMA
    table.cell(WT, 0,  6, text =  "KAMA", text_color = textcol, text_size = size.small)
    table.cell(WT, 1,  6, text =  str.tostring(KAMA_Signal), text_color = trendcol(KAMA_Signal), text_size = size.small)
    table.cell(WT, 2,  6, text =  str.tostring(math.round(KAMA_S[1],2)),   text_color = textcol, text_size = size.small)
    table.cell(WT, 4,  6, text =  str.tostring(math.round(K4[1],2)),       text_color = trendcol(sK4),  text_size = size.small)
    table.cell(WT, 5,  6, text =  str.tostring(math.round(K3[1],2)),       text_color = trendcol(sK3),  text_size = size.small)
    table.cell(WT, 6,  6, text =  str.tostring(math.round(K2[1],2)),       text_color = trendcol(sK2),  text_size = size.small)
    table.cell(WT, 7,  6, text =  str.tostring(math.round(K1[1],2)),       text_color = trendcol(sK1),  text_size = size.small)
    table.cell(WT, 8,  6, text =  str.tostring(math.round(K[1],2)),        text_color = trendcol(sK),   text_size = size.small)
    table.cell(WT, 9,  6, text =  str.tostring(math.round(K_1[1],2)),      text_color = trendcol(sK_1), text_size = size.small)
    table.cell(WT, 10, 6, text =  str.tostring(math.round(K_2[1],2)),      text_color = trendcol(sK_2), text_size = size.small)
    table.cell(WT, 11, 6, text =  str.tostring(math.round(K_3[1],2)),      text_color = trendcol(sK_3), text_size = size.small)
    table.cell(WT, 12, 6, text =  str.tostring(math.round(K_4[1],2)),      text_color = trendcol(sK_4), text_size = size.small) 

// Table 2 - Exponential Multiplier and Warnings 
var table ET = table.new(position2, 4, 4)
if barstate.islast and plot_t2
    table.cell(ET, 0, 0, "Exponential Multiplier:", text_color = textcol)
    table.cell(ET, 1, 0, text = str.tostring(math.round(e(La),3)), text_color = warningcol)
    table.cell(ET, 2, 0, text = warning1, text_color = warningcol)
    table.cell(ET, 0, 1, text = warning2, text_color = warningcol), table.merge_cells(ET, 0, 1, 2, 1)
    table.cell(ET, 0, 2, text = warning3, text_color = warningcol), table.merge_cells(ET, 0, 2, 2, 2)
//}

// - - - - - Alerts Code - - - - - //{

// Alert Base
float alertb = na
if alertbase == "Average"
    alertb := Average_Signal
else if alertbase == "EMA"
    alertb := EMA_Signal
else if alertbase == "HMA"
    alertb := HMA_Signal
else if alertbase == "WMA"
    alertb := WMA_Signal
else if alertbase == "DEMA"
    alertb := DEMA_Signal
else if alertbase == "LSMA"
    alertb := LSMA_Signal
else if alertbase == "KAMA"
    alertb := KAMA_Signal
else
    na

// Alert Conditons
long =  ta.crossover(alertb,  Long_threshold) and direction[1] == -1
short = ta.crossunder(alertb, Short_threshold) and direction[1] ==  1

alertcondition(long,  "Long",   "Go Long ▲")
alertcondition(short, "Short", "Go Short ▼")
//}