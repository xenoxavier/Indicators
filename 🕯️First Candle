ğŸ•¯ï¸First Candle

//@version=6
indicator("ğŸ•¯ï¸First Candle", overlay=true)
// MUST BE AT TOP OF SCRIPT (outside any block)
var bool swActive = false

// ===== SETTINGS =====
sessionHour   = input.int(9,  "NY Start Hour", minval = 0, maxval = 23)
sessionMinute = input.int(30, "NY Start Minute", minval = 0, maxval = 59)
refLengthMin  = input.int(15, "Reference Candle Duration (minutes)")

lineColor     = input.color(color.fuchsia, "Locked Line Color")
lineWidth     = input.int(2, "Locked Line Width", minval = 1, maxval = 5)

fvgLookback   = input.int(15, "Impulse FVG lookback (bars)", minval = 1, maxval = 100)

bullBreakClr  = input.color(color.new(color.green, 0),  "Bullish Breakout Candle Color")
bearBreakClr  = input.color(color.new(color.red,   0),  "Bearish Breakout Candle Color")
returnClr     = input.color(color.new(color.yellow, 0), "Return-to-Range Candle Color")

const string TZ = "America/New_York"

// ===== STATE =====
var float refHigh = na
var float refLow  = na
var bool  locked  = false
var line  hiLine  = na
var line  loLine  = na
var int   lastDay = na
var bool  didBullBreak = false
var bool  didBearBreak = false

// ===== TIME =====
nyY  = year(time, TZ)
nyM  = month(time, TZ)
nyD  = dayofmonth(time, TZ)
sessStart = timestamp(TZ, nyY, nyM, nyD, sessionHour, sessionMinute)   // 09:30 NY
sessEnd   = sessStart + refLengthMin * 60 * 1000                       // 09:45 NY

// ===== DAILY RESET =====
if na(lastDay) or dayofmonth(time, TZ) != lastDay
    refHigh := na
    refLow  := na
    locked  := false
    didBullBreak := false
    didBearBreak := false
    if not na(hiLine)
        line.delete(hiLine)
    if not na(loLine)
        line.delete(loLine)
    hiLine := na
    loLine := na
    lastDay := dayofmonth(time, TZ)

// ===== CAPTURE 9:30â€“9:45 CANDLE (on ANY chart TF) =====
inWindow    = time >= sessStart and time < sessEnd
afterWindow = time >= sessEnd

if inWindow
    refHigh := na(refHigh) ? high : math.max(refHigh, high)
    refLow  := na(refLow)  ? low  : math.min(refLow,  low)

// Lock once the window is over â€” create HORIZONTAL lines only
if afterWindow and not locked and not na(refHigh) and not na(refLow)
    locked := true
    // horizontal lines (x1!=x2) + extend right
    hiLine := line.new(bar_index - 1, refHigh, bar_index, refHigh, xloc = xloc.bar_index, extend = extend.right, color = lineColor, width = lineWidth)
    loLine := line.new(bar_index - 1, refLow,  bar_index, refLow,  xloc = xloc.bar_index, extend = extend.right, color = lineColor, width = lineWidth)

if locked
    // keep them anchored to the same price levels
    line.set_y1(hiLine, refHigh)
    line.set_y2(hiLine, refHigh)
    line.set_y1(loLine, refLow)
    line.set_y2(loLine, refLow)

// ===== BODY HELPERS =====
fullBodyAbove(level)    => math.min(open, close) > level
fullBodyBelow(level)    => math.max(open, close) < level
fullBodyInside(lo, hi)  => math.min(open, close) > lo and math.max(open, close) < hi

// ===== ICT 3-BAR FVG completion (on current bar) =====
// Bullish: bar[2].high < bar[0].low    (gap between #1 high and #3 low)
// Bearish: bar[2].low  > bar[0].high
bullFVG_here = high[2] < low
bearFVG_here = low[2]  > high

// Most recent completion indices
lastBullFVGBar = ta.valuewhen(bullFVG_here, bar_index, 0)
lastBearFVGBar = ta.valuewhen(bearFVG_here, bar_index, 0)

// â€œSame-impulseâ€ rule: the last FVG in the past N bars must be of the
// same direction as the trigger and NEWER than the opposite FVG.
barsSinceBull = na(lastBullFVGBar) ? 10e6 : (bar_index - lastBullFVGBar)
barsSinceBear = na(lastBearFVGBar) ? 10e6 : (bar_index - lastBearFVGBar)

bullRecent    = barsSinceBull <= fvgLookback
bearRecent    = barsSinceBear <= fvgLookback

bullNewerThanOpp = not na(lastBullFVGBar) and (na(lastBearFVGBar) or lastBullFVGBar > lastBearFVGBar)
bearNewerThanOpp = not na(lastBearFVGBar) and (na(lastBullFVGBar) or lastBearFVGBar > lastBullFVGBar)

bullImpulseOK = bullRecent and bullNewerThanOpp
bearImpulseOK = bearRecent and bearNewerThanOpp

// ===== COLORING =====
var color candleColor = na
candleColor := na

if locked
    // GREEN â€” only the first bullish breakout of the day
    bullBreak = not didBullBreak and fullBodyAbove(refHigh) and bullImpulseOK
    if bullBreak
        candleColor := bullBreakClr
        didBullBreak := true

    // RED â€” only the first bearish breakout of the day
    bearBreak = not didBearBreak and fullBodyBelow(refLow) and bearImpulseOK
    if bearBreak
        candleColor := bearBreakClr
        didBearBreak := true

    // YELLOW â€” every valid return into range (body back inside + matching impulse FVG)
    returnedFromBelow = close[1] < refLow  and fullBodyInside(refLow, refHigh) and bullImpulseOK
    returnedFromAbove = close[1] > refHigh and fullBodyInside(refLow, refHigh) and bearImpulseOK
    if returnedFromBelow or returnedFromAbove
        candleColor := returnClr

// Apply color globally (only after levels are locked)
barcolor(locked ? candleColor : na)
 //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
///â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  SWEEP ADD-ON (GLOBAL swActive VERSION)
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

//===== INPUTS =====
sw_enabled     = input.bool(true,  "SW: Enable Sweep Logic")
sw_entryPct    = input.float(65.0, "SW: Entry % of Body", minval=0.0, maxval=100.0)
sw_maxBulls    = input.int(9,      "SW: # of bullish candles after sweep", minval=1, maxval=20)
sw_entryW      = input.int(1,      "SW: Entry line width", minval=1, maxval=4)
sw_slW         = input.int(1,      "SW: SL line width",    minval=1, maxval=4)
sw_maxShown    = input.int(4,      "SW: Max Sweep Signals to Show", minval=1, maxval=20)
sw_iconPips    = input.int(10,     "SW: Icon Offset (pips below wick)", minval=1, maxval=50)

//===== INTERNAL STATE =====
var bool  swPending   = false
var float swClose     = na
var int   swBar       = na
var int   swBullCount = 0

//===== ARRAYS =====
var label[] swIcons   = array.new_label()
var line[]  swBuys    = array.new_line()
var label[] swBuyLbls = array.new_label()
var line[]  swSLs     = array.new_line()
var label[] swSLLbls  = array.new_label()

//===== DELETE OLDEST SWEEP =====
f_delete_oldest_sweep() =>
    if array.size(swIcons) > 0
        label.delete(array.shift(swIcons))
        line.delete(array.shift(swBuys))
        label.delete(array.shift(swBuyLbls))
        line.delete(array.shift(swSLs))
        label.delete(array.shift(swSLLbls))

//===== DAILY RESET =====
if nyD != nyD[1]
    swActive    := false
    swPending   := false
    swClose     := na
    swBar       := na
    swBullCount := 0
    for i = 0 to array.size(swIcons) - 1
        f_delete_oldest_sweep()

//===== CANDLE CONDITIONS =====
isBull      = close > open
inNeutral   = locked and open >= refLow and open <= refHigh
sweptLow    = low < low[1]
poppedAbove = high >= refHigh or close > refHigh

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1) DETECT SWEEP CANDLE
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if sw_enabled and not swActive and not swPending and inNeutral and isBull and sweptLow and poppedAbove
    swPending := true
    swClose   := close
    swBar     := bar_index

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 2) CONFIRM OR CANCEL SWEEP
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if swPending and not swActive

    if close < swClose
        // CANCEL
        swPending   := false
        swClose     := na
        swBar       := na
        swBullCount := 0

    else
        // CONFIRM SWEEP
        swPending  := false
        swActive   := true        // â­ GLOBAL STATE UPDATE
        swBullCount := 0

        sweepLow = low[1]
        sweepY   = sweepLow - (sw_iconPips * syminfo.mintick)

        icon = label.new(
            swBar, sweepY, "ğŸ¥¶",
            style     = label.style_label_center,
            textcolor = color.blue,
            color     = color.new(color.white,100),
            size      = size.large
        )
        array.push(swIcons, icon)

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 3) MEASURE NEXT BULLISH CANDLES
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if swActive

    if isBull and swBullCount < sw_maxBulls and bar_index >= 1

        swBullCount += 1

        prevWick = high[1]
        bodyHigh = math.max(open, close)
        bodyLow  = math.min(open, close)
        invalid  = bodyHigh <= prevWick

        if not invalid
            bodySize = bodyHigh - bodyLow

            entryLvl = bodyLow + bodySize * (sw_entryPct / 100.0)

            buyLine = line.new(bar_index, entryLvl, bar_index + 1, entryLvl,
                               extend=extend.none, color=color.blue, width=sw_entryW)
            buyLbl  = label.new(bar_index + 1, entryLvl, "Buy",
                                style=label.style_label_left, textcolor=color.blue,
                                color=color.new(color.white,100), size=size.tiny)

            slLine = line.new(bar_index, prevWick, bar_index + 1, prevWick,
                              extend=extend.none, color=color.purple, width=sw_slW)
            slLbl  = label.new(bar_index + 1, prevWick, "SL",
                               style=label.style_label_left, textcolor=color.purple,
                               color=color.new(color.white,100), size=size.tiny)

            array.push(swBuys, buyLine)
            array.push(swBuyLbls, buyLbl)
            array.push(swSLs, slLine)
            array.push(swSLLbls, slLbl)

            while array.size(swIcons) > sw_maxShown
                f_delete_oldest_sweep()

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 4) END SWEEP
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if swActive and swBullCount >= sw_maxBulls
    swActive := false       // â­ GLOBAL RESET
    swClose  := na
    swBar    := na
    swBullCount := 0
//  BULLISH FVG ADD-ON (ABC structure, limit adjustable)
//  ALL MARK LINES = VERY THIN (width = 1)
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

//===== USER SETTINGS =====
bfvg_enabled    = input.bool(true,  "Enable Bullish FVG Add-On")
bfvg_entryPct   = input.float(50.0, "Entry % (Buy level)", minval=0, maxval=100)
bfvg_tinyPct    = input.float(10.0, "Tiny FVG threshold (% of B body)", minval=0, maxval=100)
bfvg_maxShown   = input.int(4, "Max Bullish FVGs to show", minval=1, maxval=20)

//===== ARRAYS TO STORE FVG OBJECTS =====
var line[]  fvgBuyLines  = array.new_line()
var label[] fvgBuyLabels = array.new_label()
var line[]  fvgSLLines   = array.new_line()
var label[] fvgSLLabels  = array.new_label()

//===== DELETE OLDEST FVG =====
f_delete_oldest_fvg() =>
    if array.size(fvgBuyLines) > 0
        line.delete(array.shift(fvgBuyLines))
        label.delete(array.shift(fvgBuyLabels))
        line.delete(array.shift(fvgSLLines))
        label.delete(array.shift(fvgSLLabels))

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  BULLISH FVG DETECTION (ABC STRUCTURE)
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if bfvg_enabled and barstate.isconfirmed and bar_index >= 2

    A_high  = high[2]      // Candle A
    B_open  = open[1]      // Candle B
    B_close = close[1]
    B_body  = math.abs(B_open - B_close)
    C_low   = low          // Candle C

    // ICT Bullish FVG logic
    bullFVG_here = A_high < C_low

    if bullFVG_here and B_body > 0

        fvgTop    = A_high
        fvgBottom = C_low
        fvgSize   = fvgBottom - fvgTop

        if fvgSize > 0

            tinyThreshold = B_body * (bfvg_tinyPct / 100.0)
            SLlevel = fvgSize < tinyThreshold ? B_open : A_high

            entryLevel = fvgTop + fvgSize * (bfvg_entryPct / 100.0)

            //â”€â”€â”€â”€â”€â”€â”€â”€ VERY THIN BUY LINE (width = 1)
            buyLine = line.new(
                bar_index - 1, entryLevel,
                bar_index,     entryLevel,
                extend = extend.none,
                color  = color.green,
                width  = 1      // VERY THIN
            )

            // Buy label
            buyLabel = label.new(
                bar_index, entryLevel, "Buy",
                style     = label.style_label_left,
                textcolor = color.green,
                size      = size.tiny,
                color     = color.new(color.white,100)
            )

            //â”€â”€â”€â”€â”€â”€â”€â”€ VERY THIN SL LINE (width = 1)
            slLine = line.new(
                bar_index - 1, SLlevel,
                bar_index,     SLlevel,
                extend = extend.none,
                color  = color.red,
                width  = 1      // VERY THIN
            )

            // SL label
            slLabel = label.new(
                bar_index, SLlevel, "SL",
                style     = label.style_label_left,
                textcolor = color.red,
                size      = size.tiny,
                color     = color.new(color.white,100)
            )

            //â”€â”€â”€â”€â”€â”€â”€â”€ STORE FVG OBJECTS
            array.push(fvgBuyLines,  buyLine)
            array.push(fvgBuyLabels, buyLabel)
            array.push(fvgSLLines,   slLine)
            array.push(fvgSLLabels,  slLabel)

            //â”€â”€â”€â”€â”€â”€â”€â”€ LIMIT: KEEP ONLY LAST bfvg_maxShown FVGs
            while array.size(fvgBuyLines) > bfvg_maxShown
                f_delete_oldest_fvg()
 //â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  BEARISH FVG ADD-ON (Sell/SL Labels on RIGHT)
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

//===== USER SETTINGS =====
bfvgBear_enabled   = input.bool(true,  "Bearish FVG: Enable Add-On?")
bfvgBear_entryPct  = input.float(35.0, "Bearish FVG: Entry % (Sell level)", minval=0, maxval=100)
bfvgBear_maxShown  = input.int(4, "Bearish FVG: Max FVGs Visible", minval=1, maxval=20)
bfvgBear_lineW     = input.int(1, "Bearish FVG: Sell Line Thickness", minval=1, maxval=2)
bfvgBear_slLineW   = input.int(1, "Bearish FVG: SL Line Thickness",   minval=1, maxval=2)

//===== ARRAYS =====
var line[]  bfvgBear_sellLines  = array.new_line()
var label[] bfvgBear_sellLabels = array.new_label()
var line[]  bfvgBear_slLines    = array.new_line()
var label[] bfvgBear_slLabels   = array.new_label()

//===== DELETE OLDEST FVG =====
bfvgBear_delete_oldest() =>
    if array.size(bfvgBear_sellLines) > 0
        line.delete(array.shift(bfvgBear_sellLines))
        label.delete(array.shift(bfvgBear_sellLabels))
        line.delete(array.shift(bfvgBear_slLines))
        label.delete(array.shift(bfvgBear_slLabels))

//===== CONDITIONS TO RUN =====
canRunBFVGBear =
     bfvgBear_enabled and
     barstate.isconfirmed and
     bar_index >= 2

//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  BEARISH FVG ABC STRUCTURE
//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if canRunBFVGBear

    A_low   = low[2]
    A_close = close[2]
    B_high  = high[1]
    B_open  = open[1]
    B_close = close[1]
    B_body  = math.abs(B_open - B_close)
    C_high  = high

    // bearish FVG condition
    bfvgBear_condition = C_high < A_low

    if bfvgBear_condition and B_body > 0

        gapTop    = A_low
        gapBottom = C_high
        gapSize   = gapTop - gapBottom

        if gapSize > 0

            //------------------------------------------
            // SELL ENTRY LEVEL
            //------------------------------------------
            entryLvl = gapBottom + gapSize * (bfvgBear_entryPct / 100.0)

            sellLine = line.new(
                bar_index - 1, entryLvl,
                bar_index,     entryLvl,
                extend = extend.none,
                color  = color.orange,
                width  = bfvgBear_lineW
            )

            // â­ SELL LABEL ALWAYS ON RIGHT
            sellLbl = label.new(
                bar_index + 1, entryLvl, "Sell",
                style     = label.style_label_right,
                textcolor = color.orange,
                color     = color.new(color.white,100),
                size      = size.tiny
            )

            //------------------------------------------
            // STOP LOSS: highest of B.high or A.close
            //------------------------------------------
            SLlevel = math.max(B_high, A_close)

            slLine = line.new(
                bar_index - 1, SLlevel,
                bar_index,     SLlevel,
                extend = extend.none,
                color  = color.red,
                width  = bfvgBear_slLineW
            )

            // â­ SL LABEL ALWAYS ON RIGHT
            slLbl = label.new(
                bar_index + 1, SLlevel, "SL",
                style     = label.style_label_right,
                textcolor = color.red,
                color     = color.new(color.white,100),
                size      = size.tiny
            )

            //------------------------------------------
            // FIFO STORAGE
            //------------------------------------------
            array.push(bfvgBear_sellLines,  sellLine)
            array.push(bfvgBear_sellLabels, sellLbl)
            array.push(bfvgBear_slLines,    slLine)
            array.push(bfvgBear_slLabels,   slLbl)

            while array.size(bfvgBear_sellLines) > bfvgBear_maxShown
                bfvgBear_delete_oldest()