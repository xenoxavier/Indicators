Range Oscillator (Zeiierman)

// This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International  
// https://creativecommons.org/licenses/by-nc-sa/4.0/
// Â© Zeiierman {
//@version=6
indicator('Range Oscillator (Zeiierman)', overlay = false, precision = 1)
//~~}

// ~~ Tooltips {
var string t1 = 'The minimum number of bars required to qualify a range box. A higher value ensures the range is well-established, but may reduce responsiveness.'
var string t2 = 'Multiplier that adjusts the vertical size of the range box based on ATR. Larger values create wider boxes and accommodate higher volatility.'
var string t4 = 'Number of horizontal levels (bands) used in the heatmap. More levels give finer granularity but may introduce noise.'
var string t5 = 'Defines how many bars must touch a level to consider it \'hot\'. Lower values make the heatmap more reactive.'
var string t6 = 'Color for strong bullish zones. Highlights areas where price faces less resistance in uptrends.'
var string t7 = 'Color for strong bearish zones. Highlights areas where price faces less resistance in downtrends.'
var string t8 = 'Color for weak bearish zones. Highlights pressure zones in downtrends.'
var string t9 = 'Color for weak bullish zones. Highlights pressure zones in uptrends.'
var string t10 = 'Color used during trend transitions or when no valid heatmap color is available.'
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Inputs {
length = input.int(50, minval = 1, step = 1, title = 'Minimum Range Length', tooltip = t1, group = 'Range Oscillator')
mult   = input.float(2.0, minval = 0.1, step = 0.1, title = 'Range Width Multiplier', tooltip = t2, group = 'Range Oscillator')

levelsInp  = input.int(2, title = 'Number of Heat Levels', minval = 2, maxval = 100, group = 'Heat-map', tooltip = t4)
heatThresh = input.int(1, title = 'Minimum Touches per Level', minval = 1, group = 'Heat-map', tooltip = t5)

strongbullish  = input.color(#09ff00, title = 'Strong Bullish Color', group = 'Style', inline = 'c', tooltip = t6)
strongbearish  = input.color(color.rgb(255, 0, 0), title = 'Strong Bearish Color', group = 'Style', inline = 'c1', tooltip = t7)
weakbearish    = input.color(color.maroon, title = 'Weak Bearish Color', group = 'Style', inline = 'c1', tooltip = t7 + ' ' + ' ' + t8)
weakbullish    = input.color(color.green, title = 'Weak Bullish Color', group = 'Style', inline = 'c', tooltip = t6 + ' ' + ' ' + t9)
transitionzone = input.color(color.blue, title = 'Transition Color', group = 'Style', inline = 'c2', tooltip = t10)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Heatmap Function {
getHeatColor(float val, int trendDir, int levelsInp, int heatThresh, color weakbullish, color strongbullish, color weakbearish, color strongbearish, series float high_ser = high, series float low_ser = low, bool pointMode = false) =>
    series float source = high_ser
    float hi = ta.highest(pointMode ? source : high_ser, 100)
    float lo = ta.lowest(pointMode ? source : low_ser, 100)
    float rng = hi - lo
    float step = rng > 0 ? rng / levelsInp : na

    color coldTrendCol = trendDir == 1 ? weakbullish : weakbearish
    color hotTrendCol = trendDir == 1 ? weakbullish : weakbearish

    var array<float> levelVals = array.new<float>(101, na)
    var array<color> levelColors = array.new<color>(101, na)
    var array<int> levelCounts = array.new<int>(101, na)

    if na(step) or step == 0
        na
    else
        for i = 0 to levelsInp - 1 by 1
            float lvl = lo + step * i
            if pointMode
                lvl := lo + step * (i + 0.5)
                lvl
            int cnt = 0
            for j = 0 to 100 - 1 by 1
                bool touch = false
                if pointMode
                    touch := source[j] >= lvl - step / 2 and source[j] < lvl + step / 2
                    touch
                else
                    touch := high_ser[j] >= lvl and low_ser[j] <= lvl
                    touch
                if touch
                    cnt := cnt + 1
                    cnt
            color col = color.from_gradient(cnt, heatThresh, heatThresh + 10, color.new(coldTrendCol, 80 - cnt), hotTrendCol)
            array.set(levelVals, i, lvl)
            array.set(levelColors, i, col)
            array.set(levelCounts, i, cnt)

        for i = levelsInp to 100 by 1
            array.set(levelVals, i, na)
            array.set(levelColors, i, na)
            array.set(levelCounts, i, na)

        float minD = 1e10
        color best = na
        for k = 0 to levelsInp - 1 by 1
            float lvl = array.get(levelVals, k)
            if not na(lvl)
                float d = math.abs(val - lvl)
                if d < minD
                    minD := d
                    best := array.get(levelColors, k)
                    best
        best
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Calculations {
atrRaw   = nz(ta.atr(2000), ta.atr(200))
rangeATR = atrRaw * mult

sumWeightedClose = 0.0
sumWeights = 0.0
for i = 0 to length - 1 by 1
    delta = math.abs(close[i] - close[i + 1])
    w = delta / close[i + 1]
    sumWeightedClose := sumWeightedClose + close[i] * w
    sumWeights := sumWeights + w
    sumWeights
ma = sumWeights != 0 ? sumWeightedClose / sumWeights : na

distances = array.new_float(length)
for i = 0 to length - 1 by 1
    array.set(distances, i, math.abs(close[i] - ma))
maxDist = array.max(distances)
inRange = maxDist <= rangeATR
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Trend Direction for Heatmap {
var int trendDir = 0
trendDir := close > ma ? 1 : close < ma ? -1 : nz(trendDir[1])
noColorOnFlip = trendDir != trendDir[1]
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Oscillator {
osc = rangeATR != 0 ? 100 * (close - ma) / rangeATR : na

blue = transitionzone
green = strongbullish
red = strongbearish
heatColor = getHeatColor(osc, trendDir, levelsInp, heatThresh, weakbullish, strongbullish, weakbearish, strongbearish, osc, osc, true)
oscColor = na(heatColor) or noColorOnFlip ? blue : heatColor

breakUp = close > ma + rangeATR
breakDn = close < ma - rangeATR
oscColor := breakUp ? green : breakDn ? red : oscColor

osc_ = plot(osc, 'Range Oscillator', color = oscColor, linewidth = 2)
hline(100, 'Upper Bound', color = color.gray, linestyle = hline.style_dotted)
hline(0, 'Zero', color = color.gray, linestyle = hline.style_dotted)
hline(-100, 'Lower Bound', color = color.gray, linestyle = hline.style_dotted)
zero_ = plot(0, '', display = display.none, editable = false)
fill(osc_, zero_, ta.highest(osc, 100), 0, oscColor, color(na))
fill(osc_, zero_, 0, ta.lowest(osc, 100), color(na), oscColor)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
