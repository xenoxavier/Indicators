Holographic Market Microstructure | AlphaNatt

//@version=6
indicator("Holographic Market Microstructure | AlphaNatt", "HMS | AlphaNatt", overlay=true, max_labels_count=500, max_lines_count=500, max_boxes_count=500)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grpMicro            = "ðŸ”¬ Microstructure Analysis"
microDepth          = input.int(50,   "Analysis Depth",         minval=20,   maxval=200, step=1,  group=grpMicro)
liquidityThreshold  = input.float(1.5,"Liquidity Threshold",    minval=1.0,  maxval=3.0,   step=0.1,group=grpMicro)
imbalanceRatio      = input.float(2.0,"Imbalance Ratio",        minval=1.5,  maxval=5.0,   step=0.1,group=grpMicro)
showLiquidityVoids  = input.bool(true,"Show Liquidity Voids",  group=grpMicro)
showOrderFlow       = input.bool(false,"Show Order Flow",       group=grpMicro)

grpSmart            = "ðŸ§  Smart Money Tracking"
smartMoneyLength    = input.int(20,  "Smart Money Period",     minval=10,  maxval=100, group=grpSmart)
accumThreshold      = input.float(70, "Accumulation Threshold %",minval=50,  maxval=90,  group=grpSmart)
showSmartMoney      = input.bool(true,"Show Smart Money Zones",group=grpSmart)
showDivergence      = input.bool(true,"Show Price/Volume Divergence", group=grpSmart)

grpFractal          = "ðŸŒ€ Fractal Structure"
fractalPeriod       = input.int(5,   "Fractal Period",         minval=3,   maxval=15, group=grpFractal)
structureDepth      = input.int(3,   "Structure Depth",        minval=1,   maxval=5,  group=grpFractal)
showFractals        = input.bool(true,"Show Fractal Levels",    group=grpFractal)
showStructure       = input.bool(true,"Show Market Structure",  group=grpFractal)

grpHeat             = "ðŸ”¥ Volume Heat Map"
heatmapBars         = input.int(100, "Heat Map Bars",          minval=50,  maxval=300,group=grpHeat)
heatmapLevels       = input.int(10,  "Heat Map Levels",        minval=5,   maxval=20, group=grpHeat)
showHeatmap         = input.bool(true,"Show Volume Heat Map",   group=grpHeat)
heatmapOpacity      = input.int(95,  "Heat Map Opacity",       minval=50,  maxval=100,group=grpHeat)

grpVisual           = "ðŸ’Ž Holographic Visuals"
theme               = input.string("Aeon","Visual Theme", options=["Aeon", "Cyber","Quantum","Neural","Plasma","Crystal"], group=grpVisual)
glowEffect          = input.bool(true,"Enable Glow Effects",   group=grpVisual)
pulseAnimation      = input.bool(true,"Enable Pulse Animation",group=grpVisual)
showHUD             = input.bool(true,"Show HUD Display",       group=grpVisual)
hudPosition         = input.string("middle_right","HUD Position", options=["top_left","top_right","middle_left","middle_right"], group=grpVisual)
//    "Aeon"   => [#4cc9f0, #f72585, #4361ee, #7209b7, #3a0ca3]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLOR THEMES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
[primary, secondary, accent, glow, dark] = switch theme
    "Aeon"   => [#4cc9f0, #f72585, #4361ee, #7209b7, #3a0ca3]
    "Cyber"   => [#00ffff, #ff00ff, #ffff00, #00ff00, #000033]
    "Quantum" => [#4169e1, #ff1493, #00ff7f, #ffa500, #000022]
    "Neural"  => [#7fff00, #ff69b4, #00ced1, #ffd700, #001122]
    "Plasma"  => [#ff00ff, #00ffff, #ff69b4, #7fff00, #110022]
    =>           [#00bfff, #ff6347, #32cd32, #ffd700, #000044]

holo1 = color.from_gradient(50, 0, 100, color.new(primary, 90), color.new(secondary, 70))
holo2 = color.from_gradient(70, 0, 100, color.new(secondary, 85), color.new(accent, 75))
holo3 = color.from_gradient(30, 0, 100, color.new(accent, 95),   color.new(glow,    80))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CALCULATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var float[] volumeProfile   = array.new_float(heatmapLevels, 0)
var float[] priceProfile    = array.new_float(heatmapLevels, 0)

highest     = ta.highest(high, heatmapBars)
lowest      = ta.lowest(low,   heatmapBars)
priceRange  = highest - lowest
levelHeight = priceRange / heatmapLevels

if barstate.isconfirmed
    for i = 0 to heatmapLevels - 1
        array.set(volumeProfile, i, 0)
        array.set(priceProfile,  i, lowest + (i * levelHeight) + levelHeight/2)

for j = 0 to math.min(heatmapBars - 1, bar_index)
    barPrice   = (high[j] + low[j]) / 2
    barVol     = volume[j]
    levelIndex = int((barPrice - lowest) / levelHeight)
    if levelIndex >= 0 and levelIndex < heatmapLevels
        array.set(volumeProfile, levelIndex, array.get(volumeProfile, levelIndex) + barVol)

buyVolume   = volume * (close - low)  / (high - low)
sellVolume  = volume * (high - close) / (high - low)
orderFlowImbalance = buyVolume - sellVolume
ofi            = ta.cum(orderFlowImbalance)
ofiMA          = ta.sma(ofi, smartMoneyLength)

avgRange       = ta.atr(14)
voidThreshold  = avgRange * liquidityThreshold
smaVol20       = ta.sma(volume, 20)
isLiquidityVoid= (high - low) > voidThreshold and volume < smaVol20 * 0.7

priceROC       = ta.roc(close,  smartMoneyLength)
volumeROC      = ta.roc(volume, smartMoneyLength)
smartMoneyIndex= (priceROC > 0 and volumeROC > accumThreshold) ? 1 : (priceROC < 0 and volumeROC > accumThreshold) ? -1 : 0

fractalHigh    = high[fractalPeriod] == ta.highest(high, fractalPeriod * 2 + 1)
fractalLow     = low[fractalPeriod]  == ta.lowest(low,  fractalPeriod * 2 + 1)

var float[] structureHighs     = array.new_float(structureDepth, na)
var float[] structureLows      = array.new_float(structureDepth, na)
var int[]   structureHighTimes = array.new_int(structureDepth, 0)
var int[]   structureLowTimes  = array.new_int(structureDepth, 0)

if fractalHigh
    array.shift(structureHighs)
    array.push( structureHighs,    high[fractalPeriod])
    array.shift(structureHighTimes)
    array.push( structureHighTimes, bar_index - fractalPeriod)

if fractalLow
    array.shift(structureLows)
    array.push( structureLows,     low[fractalPeriod])
    array.shift(structureLowTimes)
    array.push( structureLowTimes,  bar_index - fractalPeriod)

microTrend = 0
for i = 0 to structureDepth - 2
    if not na(array.get(structureHighs, i)) and not na(array.get(structureHighs, i+1))
        microTrend += array.get(structureHighs, i) > array.get(structureHighs, i+1) ? 1 : -1
    if not na(array.get(structureLows, i))  and not na(array.get(structureLows, i+1))
        microTrend += array.get(structureLows,  i) > array.get(structureLows,  i+1) ? 1 : -1

var bool isDivergence = false
priceTrend   = ta.linreg(close,  smartMoneyLength, 0)
volumeTrend  = ta.linreg(volume, smartMoneyLength, 0)
isDivergence := showDivergence and ((priceTrend > 0 and volumeTrend < 0) or (priceTrend < 0 and volumeTrend > 0))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VISUALIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if showHeatmap
    maxVolume = array.max(volumeProfile)
    for i = 0 to heatmapLevels - 1
        levelVol   = array.get(volumeProfile, i)
        levelPrice = array.get(priceProfile,  i)
        volRatio   = levelVol / maxVolume
        heatColor  = color.from_gradient(volRatio * 100, 0, 100, color.new(dark,95), color.new(glow,heatmapOpacity))
        boxWidth   = int(volRatio * 40)
        if levelVol > 0
            box.new(bar_index - boxWidth, levelPrice + levelHeight/2,bar_index,                   levelPrice - levelHeight/2,bgcolor=heatColor, border_color=color.new(primary,90))

if showLiquidityVoids and isLiquidityVoid[1]
    box.new(bar_index - 1, high[1], bar_index, low[1],bgcolor=color.new(accent,95), border_color=color.new(accent,50))
    if pulseAnimation
        box.new(bar_index - 1, high[1], bar_index, low[1],bgcolor=color.new(accent,98), border_color=color.new(accent,80))

ofiNormalized = (ofi - ofiMA) / ta.stdev(ofi - ofiMA, smartMoneyLength)

plot(showOrderFlow ? ofi   : na, "Order Flow",     color=color.new(primary,100), display=display.none)
plot(showOrderFlow ? ofiMA : na, "Order Flow MA",  color=color.new(secondary,100), display=display.none)
bgcolor(showOrderFlow ? color.new(ofiNormalized > 0 ? primary : secondary, 95 - math.abs(ofiNormalized)*10) : na)

if showSmartMoney and smartMoneyIndex != 0
    zoneColor = smartMoneyIndex == 1 ? primary : secondary
    for i = 0 to 4
        alpha = 95 - i * 5
        box.new(bar_index - smartMoneyLength + i*5, high,bar_index - smartMoneyLength + i*5 + 5, low,bgcolor=color.new(zoneColor,alpha), border_color=na)

if showStructure
    for i = 0 to structureDepth - 2
        if not na(array.get(structureHighs, i)) and not na(array.get(structureHighs, i+1))
            line.new(array.get(structureHighTimes, i),   array.get(structureHighs, i),
                     array.get(structureHighTimes, i+1), array.get(structureHighs, i+1),
                     color=color.new(primary,70), width=2, style=line.style_dashed)
            if glowEffect
                line.new(array.get(structureHighTimes, i),   array.get(structureHighs, i),
                         array.get(structureHighTimes, i+1), array.get(structureHighs, i+1),
                         color=color.new(glow,90),   width=4, style=line.style_dashed)
        if not na(array.get(structureLows, i))  and not na(array.get(structureLows, i+1))
            line.new(array.get(structureLowTimes, i),    array.get(structureLows, i),
                     array.get(structureLowTimes, i+1),  array.get(structureLows, i+1),
                     color=color.new(secondary,70), width=2, style=line.style_dashed)
            if glowEffect
                line.new(array.get(structureLowTimes, i),    array.get(structureLows, i),
                         array.get(structureLowTimes, i+1),  array.get(structureLows, i+1),
                         color=color.new(glow,90),     width=4, style=line.style_dashed)

plotshape(showFractals and fractalHigh,title="Fractal High", location=location.abovebar,color=color.new(primary,30), size=size.tiny, offset=-fractalPeriod)
plotshape(showFractals and fractalLow,title="Fractal Low",   location=location.belowbar,color=color.new(secondary,30), size=size.tiny, offset=-fractalPeriod)

if showDivergence and isDivergence
    label.new(bar_index, high, "âš ",color=color.new(accent,0), textcolor=accent,style=label.style_none, size=size.large)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HUD DISPLAY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if showHUD
    hudPos = switch hudPosition
        "top_left"     => position.top_left
        "top_right"    => position.top_right
        "middle_left"  => position.middle_left
        =>               position.middle_right

    var table hud = table.new(hudPos, 2, 6)
    hudBg     = color.new(dark,90)
    hudBorder = color.new(primary,50)

    table.cell(hud, 0, 0, "MICROSTRUCTURE", bgcolor=hudBg, text_color=primary,   text_size=size.normal)

    ofiStatus = ofiNormalized > 1 ? "â–² BUYING" : ofiNormalized < -1 ? "â–¼ SELLING" : "â—† NEUTRAL"
    ofiCol    = ofiNormalized > 1 ? primary       : ofiNormalized < -1 ? secondary    : accent
    table.cell(hud, 0, 1, "Flow:", bgcolor=hudBg, text_color=color.gray, text_size=size.small)
    table.cell(hud, 1, 1, ofiStatus, bgcolor=hudBg, text_color=ofiCol,   text_size=size.small)

    structStatus = microTrend > 2 ? "â–² BULLISH" : microTrend < -2 ? "â–¼ BEARISH" : "â—† RANGING"
    structCol    = microTrend > 2 ? primary     : microTrend < -2 ? secondary    : accent
    table.cell(hud, 0, 2, "Struct:", bgcolor=hudBg, text_color=color.gray, text_size=size.small)
    table.cell(hud, 1, 2, structStatus, bgcolor=hudBg, text_color=structCol, text_size=size.small)

    smStatus = smartMoneyIndex == 1  ? "â—ˆ ACCUM" : smartMoneyIndex == -1 ? "â—ˆ DISTRIB" : "â—‹ IDLE"
    smCol    = smartMoneyIndex == 1  ? primary       : smartMoneyIndex == -1 ? secondary     : color.gray
    table.cell(hud, 0, 3, "Smart$:", bgcolor=hudBg, text_color=color.gray, text_size=size.small)
    table.cell(hud, 1, 3, smStatus,  bgcolor=hudBg, text_color=smCol,    text_size=size.small)

    liqStatus = isLiquidityVoid ? "âš¡ VOID" : "â— NORMAL"
    table.cell(hud, 0, 4, "Liquid:", bgcolor=hudBg, text_color=color.gray, text_size=size.small)
    table.cell(hud, 1, 4, liqStatus, bgcolor=hudBg, text_color=isLiquidityVoid ? accent : color.gray, text_size=size.small)

    divStatus = isDivergence ? "âš  ALERT" : "âœ“ CLEAR"
    table.cell(hud, 0, 5, "Diverg:", bgcolor=hudBg, text_color=color.gray, text_size=size.small)
    table.cell(hud, 1, 5, divStatus, bgcolor=hudBg, text_color=isDivergence ? glow : color.gray, text_size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALERTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
alertcondition(isLiquidityVoid,                    "Liquidity Void Detected",      "HMS: Liquidity void formed")
alertcondition(math.abs(ofiNormalized) > 2,       "Strong Order Flow",            "HMS: Strong order flow detected")
alertcondition(smartMoneyIndex != 0,              "Smart Money Activity",         "HMS: Smart money accumulation/distribution")
alertcondition(isDivergence,                      "Price/Volume Divergence",      "HMS: Divergence detected")
alertcondition(microTrend > 3 or microTrend < -3, "Structure Change",             "HMS: Market structure shift")
