// Match Finder [theUltimator5]

// Match Finder is the dating app of indicators. It takes your current ticker and finds the most compatible match over a recent time period. The match may not be Mr. right, but it is Mr. right now. It doesn't forecast future connection, but it tells you current compatibility for today.

// Jokes aside, it is a pattern–comparison tool that was designed to find the ticker that tracks most closely to the one you are currently looking at. It scans a user-defined list of 40 tickers (pre-set to a bunch of liquid ETFs) and finds which one most closely matches the recent price action of the current chart over a fixed lookback window.

// LOGIC BEHIND THE SCENES
// For each bar, the script:
// Takes the last N bars (Correlation Window Length) of the current symbol.
// Takes the last N bars of each selected comparison ticker.
// Calculates the Pearson correlation between the current symbol and each comparison ticker.
// Identifies the single best-matching ticker (highest positive correlation, excluding the current symbol itself).
// Rescales and overlays that matched segment on the chart so you can visually compare shapes.
// Optionally shows a correlation table with all tickers and their correlation values.


// The use case of this indicator is to help you see which symbol has recently moved most similarly to your current chart, and how that shape looks when overlaid in the same panel. It helps you see which sectors it may be following most closely to.

// Here is an image with arrows showing the elements of this indicator that will be mostly explained later.
// snapshot


// USER INPUTS

// 1. Correlation Window Length
// Default: 30
// Range: 10–500
// This is the number of bars used to compare the current symbol against each ticker.
// Important - Larger values produce more “global” shape comparison but increase computational load and may cause the indicator to timeout if the length is too long

// 2. Drawing Mode
// Options:
// Scale Only - Adjusts min and max of the plotted line segment to match the chart over the range
// Scale & Rotate - Scales as above, but matches the first and last point to the close of the chart over the range. This effectively rotates the pattern to force it to track the chart to an extent.


// 3. Show Correlation Table
// When enabled (disabled by default), shows a table in the bottom-right of the chart that displays the correlation values over the lookback range for all 40 tickers. The best fit ticker is highlighted.

// 4. Best Fit Line Color
// Color used to draw the overlaid best-match segment (yellow by default).

// 5. Ticker inputs (1–40)
// Default set to a broad universe of major ETFs (e.g., SPY, QQQ, IWM, sector and bond ETFs, commodities, etc.).
// You can replace these with any symbols supported by your data feed (stocks, ETFs, indexes, etc.).

// The script always excludes the current chart’s symbol from being considered as its own best match.


// NOTE: THIS INDICATOR IS EXTREMELY MEMORY INTENSIVE AND MAY TAKE SEVERAL SECONDS TO LOAD. PLEASE BE PATIENT AND GIVE THE INDICATOR UP TO 20 SECONDS FOR THE DATA TO DISPLAY
// Open-source script

// In true TradingView spirit, the creator of this script has made it open-source, so that traders can review and verify its functionality. Kudos to the author! While you can use it for free, remember that republishing the code is subject to our House Rules.


// TheUltimator5

// Follow
// Also on:
// Disclaimer
// The information and publications are not meant to be, and do not constitute, financial, investment, trading, or other types of advice or recommendations supplied or endorsed by Tradi

// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © TheUltimator5

//@version=6
indicator("Match Finder [theUltimator5]", overlay=true, max_bars_back = 5000, max_lines_count = 500, max_boxes_count = 500)

// –– USER INPUTS ––
l                 = input.int(30,             title="Correlation Window Length", minval=10, maxval=500)
matchMode = input.string("Scale Only", title="Drawing Mode", options=["Scale Only", "Rotate & Scale"])
showTickerTable         = input.bool(false,         title="Show Correlation Table (All Tickers)")
color1            = input.color(color.yellow, title="Best Fit Line Color")

// –– TICKER INPUTS (40 tickers) ––
ticker1  = input.symbol("SPY", title="Ticker 1")
ticker2  = input.symbol("QQQ", title="Ticker 2")
ticker3  = input.symbol("IWM", title="Ticker 3")
ticker4  = input.symbol("DIA", title="Ticker 4")
ticker5  = input.symbol("EEM", title="Ticker 5")
ticker6  = input.symbol("TLT", title="Ticker 6")
ticker7  = input.symbol("GLD", title="Ticker 7")
ticker8  = input.symbol("XLE", title="Ticker 8")
ticker9  = input.symbol("XLF", title="Ticker 9")
ticker10 = input.symbol("XLK", title="Ticker 10")
ticker11 = input.symbol("XLV", title="Ticker 11")
ticker12 = input.symbol("XLI", title="Ticker 12")
ticker13 = input.symbol("XLP", title="Ticker 13")
ticker14 = input.symbol("XLY", title="Ticker 14")
ticker15 = input.symbol("XLU", title="Ticker 15")
ticker16 = input.symbol("XLB", title="Ticker 16")
ticker17 = input.symbol("XLRE", title="Ticker 17")
ticker18 = input.symbol("XLC", title="Ticker 18")
ticker19 = input.symbol("VTI", title="Ticker 19")
ticker20 = input.symbol("VOO", title="Ticker 20")
ticker21 = input.symbol("VGK", title="Ticker 21")
ticker22 = input.symbol("VWO", title="Ticker 22")
ticker23 = input.symbol("AGG", title="Ticker 23")
ticker24 = input.symbol("BND", title="Ticker 24")
ticker25 = input.symbol("SHY", title="Ticker 25")
ticker26 = input.symbol("IEF", title="Ticker 26")
ticker27 = input.symbol("LQD", title="Ticker 27")
ticker28 = input.symbol("HYG", title="Ticker 28")
ticker29 = input.symbol("SLV", title="Ticker 29")
ticker30 = input.symbol("USO", title="Ticker 30")
ticker31 = input.symbol("UNG", title="Ticker 31")
ticker32 = input.symbol("VNQ", title="Ticker 32")
ticker33 = input.symbol("EFA", title="Ticker 33")
ticker34 = input.symbol("EWJ", title="Ticker 34")
ticker35 = input.symbol("FXI", title="Ticker 35")
ticker36 = input.symbol("GDX", title="Ticker 36")
ticker37 = input.symbol("SMH", title="Ticker 37")
ticker38 = input.symbol("XBI", title="Ticker 38")
ticker39 = input.symbol("IBB", title="Ticker 39")
ticker40 = input.symbol("KRE", title="Ticker 40")

// –– REQUEST TICKER DATA ––
close1  = request.security(ticker1,  timeframe.period, close, lookahead=barmerge.lookahead_off)
close2  = request.security(ticker2,  timeframe.period, close, lookahead=barmerge.lookahead_off)
close3  = request.security(ticker3,  timeframe.period, close, lookahead=barmerge.lookahead_off)
close4  = request.security(ticker4,  timeframe.period, close, lookahead=barmerge.lookahead_off)
close5  = request.security(ticker5,  timeframe.period, close, lookahead=barmerge.lookahead_off)
close6  = request.security(ticker6,  timeframe.period, close, lookahead=barmerge.lookahead_off)
close7  = request.security(ticker7,  timeframe.period, close, lookahead=barmerge.lookahead_off)
close8  = request.security(ticker8,  timeframe.period, close, lookahead=barmerge.lookahead_off)
close9  = request.security(ticker9,  timeframe.period, close, lookahead=barmerge.lookahead_off)
close10 = request.security(ticker10, timeframe.period, close, lookahead=barmerge.lookahead_off)
close11 = request.security(ticker11, timeframe.period, close, lookahead=barmerge.lookahead_off)
close12 = request.security(ticker12, timeframe.period, close, lookahead=barmerge.lookahead_off)
close13 = request.security(ticker13, timeframe.period, close, lookahead=barmerge.lookahead_off)
close14 = request.security(ticker14, timeframe.period, close, lookahead=barmerge.lookahead_off)
close15 = request.security(ticker15, timeframe.period, close, lookahead=barmerge.lookahead_off)
close16 = request.security(ticker16, timeframe.period, close, lookahead=barmerge.lookahead_off)
close17 = request.security(ticker17, timeframe.period, close, lookahead=barmerge.lookahead_off)
close18 = request.security(ticker18, timeframe.period, close, lookahead=barmerge.lookahead_off)
close19 = request.security(ticker19, timeframe.period, close, lookahead=barmerge.lookahead_off)
close20 = request.security(ticker20, timeframe.period, close, lookahead=barmerge.lookahead_off)
close21 = request.security(ticker21, timeframe.period, close, lookahead=barmerge.lookahead_off)
close22 = request.security(ticker22, timeframe.period, close, lookahead=barmerge.lookahead_off)
close23 = request.security(ticker23, timeframe.period, close, lookahead=barmerge.lookahead_off)
close24 = request.security(ticker24, timeframe.period, close, lookahead=barmerge.lookahead_off)
close25 = request.security(ticker25, timeframe.period, close, lookahead=barmerge.lookahead_off)
close26 = request.security(ticker26, timeframe.period, close, lookahead=barmerge.lookahead_off)
close27 = request.security(ticker27, timeframe.period, close, lookahead=barmerge.lookahead_off)
close28 = request.security(ticker28, timeframe.period, close, lookahead=barmerge.lookahead_off)
close29 = request.security(ticker29, timeframe.period, close, lookahead=barmerge.lookahead_off)
close30 = request.security(ticker30, timeframe.period, close, lookahead=barmerge.lookahead_off)
close31 = request.security(ticker31, timeframe.period, close, lookahead=barmerge.lookahead_off)
close32 = request.security(ticker32, timeframe.period, close, lookahead=barmerge.lookahead_off)
close33 = request.security(ticker33, timeframe.period, close, lookahead=barmerge.lookahead_off)
close34 = request.security(ticker34, timeframe.period, close, lookahead=barmerge.lookahead_off)
close35 = request.security(ticker35, timeframe.period, close, lookahead=barmerge.lookahead_off)
close36 = request.security(ticker36, timeframe.period, close, lookahead=barmerge.lookahead_off)
close37 = request.security(ticker37, timeframe.period, close, lookahead=barmerge.lookahead_off)
close38 = request.security(ticker38, timeframe.period, close, lookahead=barmerge.lookahead_off)
close39 = request.security(ticker39, timeframe.period, close, lookahead=barmerge.lookahead_off)
close40 = request.security(ticker40, timeframe.period, close, lookahead=barmerge.lookahead_off)

// –– VARIABLES ––
var float   maxCorr       = na
var string  bestETF       = na
var float[] bestFit       = array.new_float(l, 0.0)
var line[]  segmentLines  = array.new_line()
var float   base          = na
var float   target        = na
var float   scaleFactor   = na

// Tables: summary (top-right) + tickers (bottom-right)
var table corrTable  = table.new(position.top_right,   1, 1,  border_width = 1)
var table tickerTable = table.new(position.bottom_right, 6, 21, border_width = 1)


// –– HELPER FUNCTIONS ––

// Function to get the ETF array based on index
// getETFArray(int idx, array<float> arrETF0, array<float> arrETF1, array<float> arrETF2, array<float> arrETF3, array<float> arrETF4,
//             array<float> arrETF5, array<float> arrETF6, array<float> arrETF7, array<float> arrETF8, array<float> arrETF9,
//             array<float> arrETF10, array<float> arrETF11, array<float> arrETF12, array<float> arrETF13, array<float> arrETF14,
//             array<float> arrETF15, array<float> arrETF16, array<float> arrETF17, array<float> arrETF18, array<float> arrETF19,
//             array<float> arrETF20, array<float> arrETF21, array<float> arrETF22, array<float> arrETF23, array<float> arrETF24,
//             array<float> arrETF25, array<float> arrETF26, array<float> arrETF27, array<float> arrETF28, array<float> arrETF29,
//             array<float> arrETF30, array<float> arrETF31, array<float> arrETF32, array<float> arrETF33, array<float> arrETF34,
//             array<float> arrETF35, array<float> arrETF36, array<float> arrETF37, array<float> arrETF38, array<float> arrETF39) =>
//     array<float> result = na
//     switch idx
//         0 => result := arrETF0
//         1 => result := arrETF1
//         2 => result := arrETF2
//         3 => result := arrETF3
//         4 => result := arrETF4
//         5 => result := arrETF5
//         6 => result := arrETF6
//         7 => result := arrETF7
//         8 => result := arrETF8
//         9 => result := arrETF9
//         10 => result := arrETF10
//         11 => result := arrETF11
//         12 => result := arrETF12
//         13 => result := arrETF13
//         14 => result := arrETF14
//         15 => result := arrETF15
//         16 => result := arrETF16
//         17 => result := arrETF17
//         18 => result := arrETF18
//         19 => result := arrETF19
//         20 => result := arrETF20
//         21 => result := arrETF21
//         22 => result := arrETF22
//         23 => result := arrETF23
//         24 => result := arrETF24
//         25 => result := arrETF25
//         26 => result := arrETF26
//         27 => result := arrETF27
//         28 => result := arrETF28
//         29 => result := arrETF29
//         30 => result := arrETF30
//         31 => result := arrETF31
//         32 => result := arrETF32
//         33 => result := arrETF33
//         34 => result := arrETF34
//         35 => result := arrETF35
//         36 => result := arrETF36
//         37 => result := arrETF37
//         38 => result := arrETF38
//         39 => result := arrETF39
//     result

// Function to get close value based on index
// getCloseValue(int idx, float c1, float c2, float c3, float c4, float c5, float c6, float c7, float c8, float c9, float c10,
//               float c11, float c12, float c13, float c14, float c15, float c16, float c17, float c18, float c19, float c20,
//               float c21, float c22, float c23, float c24, float c25, float c26, float c27, float c28, float c29, float c30,
//               float c31, float c32, float c33, float c34, float c35, float c36, float c37, float c38, float c39, float c40) =>
//     float result = na
//     switch idx
//         0 => result := c1
//         1 => result := c2
//         2 => result := c3
//         3 => result := c4
//         4 => result := c5
//         5 => result := c6
//         6 => result := c7
//         7 => result := c8
//         8 => result := c9
//         9 => result := c10
//         10 => result := c11
//         11 => result := c12
//         12 => result := c13
//         13 => result := c14
//         14 => result := c15
//         15 => result := c16
//         16 => result := c17
//         17 => result := c18
//         18 => result := c19
//         19 => result := c20
//         20 => result := c21
//         21 => result := c22
//         22 => result := c23
//         23 => result := c24
//         24 => result := c25
//         25 => result := c26
//         26 => result := c27
//         27 => result := c28
//         28 => result := c29
//         29 => result := c30
//         30 => result := c31
//         31 => result := c32
//         32 => result := c33
//         33 => result := c34
//         34 => result := c35
//         35 => result := c36
//         36 => result := c37
//         37 => result := c38
//         38 => result := c39
//         39 => result := c40
//     result

// Function to calculate pearson correlation
// calcCorrelation(array<float> arrCurrent, array<float> arrETF, int length) =>
//     float sumCurrent = 0.0
//     float sumETF = 0.0
    for j = 0 to length - 1
//         sumCurrent += array.get(arrCurrent, j)
//         sumETF += array.get(arrETF, j)
//     float meanCurrent = sumCurrent / length
//     float meanETF = sumETF / length
//     float num = 0.0
//     float denCurrent = 0.0
//     float denETF = 0.0
    for j = 0 to length - 1
//         float dCurrent = array.get(arrCurrent, j) - meanCurrent
//         float dETF = array.get(arrETF, j) - meanETF
//         num += dCurrent * dETF
//         denCurrent += dCurrent * dCurrent
//         denETF += dETF * dETF
//     float corr = (denCurrent > 0 and denETF > 0) ? num / math.sqrt(denCurrent * denETF) : na
//     corr



//––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
// 1 · SEARCH FOR BEST-MATCH ETF SEGMENT

// This section is EXTREMELY memory heavy, but I haven't found a way (yet) to preserve functionality while
// reducing lag.  ta.correlation does NOT work because I am sweeping through each individual bar and building
// a custom array while ta.correlation simply finds pearson correlation over the total length, rather than on
// each bar.  It doesn't allow for proper shape matching like my function does.

// I also needed to calculate each ticker independently instead of looping through arrays because I couldn't
// figure out a way to store the correlations properly using my bar-by-bar method.

if bar_index >= l
    // Reset best-match trackers for this bar
//     maxCorr     := na
//     bestETF     := na
//     base        := na
//     target      := na
//     scaleFactor := na

    // Ensure bestFit has correct length
    if array.size(bestFit) != l
//         bestFit := array.new_float(l, 0.0)

    // Get current symbol to exclude from matching
    currentSymbol = syminfo.ticker

    // BUILD CURRENT CHART ARRAY
    arrCurrent = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrCurrent, j, close[j])

    // Array to store correlation values
    corrValues = array.new_float(40, na)
    
    // ========== TICKER 0 ==========
    arrETF0 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF0, j, close1[j])
//     float sumCurrent0 = 0.0
//     float sumETF0 = 0.0
    for j = 0 to l - 1
//         sumCurrent0 += array.get(arrCurrent, j)
//         sumETF0 += array.get(arrETF0, j)
//     float meanCurrent0 = sumCurrent0 / l
//     float meanETF0 = sumETF0 / l
//     float num0 = 0.0
//     float denCurrent0 = 0.0
//     float denETF0 = 0.0
    for j = 0 to l - 1
//         float dCurrent0 = array.get(arrCurrent, j) - meanCurrent0
//         float dETF0 = array.get(arrETF0, j) - meanETF0
//         num0 += dCurrent0 * dETF0
//         denCurrent0 += dCurrent0 * dCurrent0
//         denETF0 += dETF0 * dETF0
//     float corr0 = (denCurrent0 > 0 and denETF0 > 0) ? num0 / math.sqrt(denCurrent0 * denETF0) : na
//     array.set(corrValues, 0, corr0)
    
    // ========== TICKER 1 ==========
    arrETF1 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF1, j, close2[j])
//     float sumCurrent1 = 0.0
//     float sumETF1 = 0.0
    for j = 0 to l - 1
//         sumCurrent1 += array.get(arrCurrent, j)
//         sumETF1 += array.get(arrETF1, j)
//     float meanCurrent1 = sumCurrent1 / l
//     float meanETF1 = sumETF1 / l
//     float num1 = 0.0
//     float denCurrent1 = 0.0
//     float denETF1 = 0.0
    for j = 0 to l - 1
//         float dCurrent1 = array.get(arrCurrent, j) - meanCurrent1
//         float dETF1 = array.get(arrETF1, j) - meanETF1
//         num1 += dCurrent1 * dETF1
//         denCurrent1 += dCurrent1 * dCurrent1
//         denETF1 += dETF1 * dETF1
//     float corr1 = (denCurrent1 > 0 and denETF1 > 0) ? num1 / math.sqrt(denCurrent1 * denETF1) : na
//     array.set(corrValues, 1, corr1)
    
    // ========== TICKER 2 ==========
    arrETF2 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF2, j, close3[j])
//     float sumCurrent2 = 0.0
//     float sumETF2 = 0.0
    for j = 0 to l - 1
//         sumCurrent2 += array.get(arrCurrent, j)
//         sumETF2 += array.get(arrETF2, j)
//     float meanCurrent2 = sumCurrent2 / l
//     float meanETF2 = sumETF2 / l
//     float num2 = 0.0
//     float denCurrent2 = 0.0
//     float denETF2 = 0.0
    for j = 0 to l - 1
//         float dCurrent2 = array.get(arrCurrent, j) - meanCurrent2
//         float dETF2 = array.get(arrETF2, j) - meanETF2
//         num2 += dCurrent2 * dETF2
//         denCurrent2 += dCurrent2 * dCurrent2
//         denETF2 += dETF2 * dETF2
//     float corr2 = (denCurrent2 > 0 and denETF2 > 0) ? num2 / math.sqrt(denCurrent2 * denETF2) : na
//     array.set(corrValues, 2, corr2)
    
    // ========== TICKER 3 ==========
    arrETF3 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF3, j, close4[j])
//     float sumCurrent3 = 0.0
//     float sumETF3 = 0.0
    for j = 0 to l - 1
//         sumCurrent3 += array.get(arrCurrent, j)
//         sumETF3 += array.get(arrETF3, j)
//     float meanCurrent3 = sumCurrent3 / l
//     float meanETF3 = sumETF3 / l
//     float num3 = 0.0
//     float denCurrent3 = 0.0
//     float denETF3 = 0.0
    for j = 0 to l - 1
//         float dCurrent3 = array.get(arrCurrent, j) - meanCurrent3
//         float dETF3 = array.get(arrETF3, j) - meanETF3
//         num3 += dCurrent3 * dETF3
//         denCurrent3 += dCurrent3 * dCurrent3
//         denETF3 += dETF3 * dETF3
//     float corr3 = (denCurrent3 > 0 and denETF3 > 0) ? num3 / math.sqrt(denCurrent3 * denETF3) : na
//     array.set(corrValues, 3, corr3)
    
    // ========== TICKER 4 ==========
    arrETF4 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF4, j, close5[j])
//     float sumCurrent4 = 0.0
//     float sumETF4 = 0.0
    for j = 0 to l - 1
//         sumCurrent4 += array.get(arrCurrent, j)
//         sumETF4 += array.get(arrETF4, j)
//     float meanCurrent4 = sumCurrent4 / l
//     float meanETF4 = sumETF4 / l
//     float num4 = 0.0
//     float denCurrent4 = 0.0
//     float denETF4 = 0.0
    for j = 0 to l - 1
//         float dCurrent4 = array.get(arrCurrent, j) - meanCurrent4
//         float dETF4 = array.get(arrETF4, j) - meanETF4
//         num4 += dCurrent4 * dETF4
//         denCurrent4 += dCurrent4 * dCurrent4
//         denETF4 += dETF4 * dETF4
//     float corr4 = (denCurrent4 > 0 and denETF4 > 0) ? num4 / math.sqrt(denCurrent4 * denETF4) : na
//     array.set(corrValues, 4, corr4)
    
    // ========== TICKER 5 ==========
    arrETF5 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF5, j, close6[j])
//     float sumCurrent5 = 0.0
//     float sumETF5 = 0.0
    for j = 0 to l - 1
//         sumCurrent5 += array.get(arrCurrent, j)
//         sumETF5 += array.get(arrETF5, j)
//     float meanCurrent5 = sumCurrent5 / l
//     float meanETF5 = sumETF5 / l
//     float num5 = 0.0
//     float denCurrent5 = 0.0
//     float denETF5 = 0.0
    for j = 0 to l - 1
//         float dCurrent5 = array.get(arrCurrent, j) - meanCurrent5
//         float dETF5 = array.get(arrETF5, j) - meanETF5
//         num5 += dCurrent5 * dETF5
//         denCurrent5 += dCurrent5 * dCurrent5
//         denETF5 += dETF5 * dETF5
//     float corr5 = (denCurrent5 > 0 and denETF5 > 0) ? num5 / math.sqrt(denCurrent5 * denETF5) : na
//     array.set(corrValues, 5, corr5)
    
    // ========== TICKER 6 ==========
    arrETF6 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF6, j, close7[j])
//     float sumCurrent6 = 0.0
//     float sumETF6 = 0.0
    for j = 0 to l - 1
//         sumCurrent6 += array.get(arrCurrent, j)
//         sumETF6 += array.get(arrETF6, j)
//     float meanCurrent6 = sumCurrent6 / l
//     float meanETF6 = sumETF6 / l
//     float num6 = 0.0
//     float denCurrent6 = 0.0
//     float denETF6 = 0.0
    for j = 0 to l - 1
//         float dCurrent6 = array.get(arrCurrent, j) - meanCurrent6
//         float dETF6 = array.get(arrETF6, j) - meanETF6
//         num6 += dCurrent6 * dETF6
//         denCurrent6 += dCurrent6 * dCurrent6
//         denETF6 += dETF6 * dETF6
//     float corr6 = (denCurrent6 > 0 and denETF6 > 0) ? num6 / math.sqrt(denCurrent6 * denETF6) : na
//     array.set(corrValues, 6, corr6)
    
    // ========== TICKER 7 ==========
    arrETF7 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF7, j, close8[j])
//     float sumCurrent7 = 0.0
//     float sumETF7 = 0.0
    for j = 0 to l - 1
//         sumCurrent7 += array.get(arrCurrent, j)
//         sumETF7 += array.get(arrETF7, j)
//     float meanCurrent7 = sumCurrent7 / l
//     float meanETF7 = sumETF7 / l
//     float num7 = 0.0
//     float denCurrent7 = 0.0
//     float denETF7 = 0.0
    for j = 0 to l - 1
//         float dCurrent7 = array.get(arrCurrent, j) - meanCurrent7
//         float dETF7 = array.get(arrETF7, j) - meanETF7
//         num7 += dCurrent7 * dETF7
//         denCurrent7 += dCurrent7 * dCurrent7
//         denETF7 += dETF7 * dETF7
//     float corr7 = (denCurrent7 > 0 and denETF7 > 0) ? num7 / math.sqrt(denCurrent7 * denETF7) : na
//     array.set(corrValues, 7, corr7)
    
    // ========== TICKER 8 ==========
    arrETF8 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF8, j, close9[j])
//     float sumCurrent8 = 0.0
//     float sumETF8 = 0.0
    for j = 0 to l - 1
//         sumCurrent8 += array.get(arrCurrent, j)
//         sumETF8 += array.get(arrETF8, j)
//     float meanCurrent8 = sumCurrent8 / l
//     float meanETF8 = sumETF8 / l
//     float num8 = 0.0
//     float denCurrent8 = 0.0
//     float denETF8 = 0.0
    for j = 0 to l - 1
//         float dCurrent8 = array.get(arrCurrent, j) - meanCurrent8
//         float dETF8 = array.get(arrETF8, j) - meanETF8
//         num8 += dCurrent8 * dETF8
//         denCurrent8 += dCurrent8 * dCurrent8
//         denETF8 += dETF8 * dETF8
//     float corr8 = (denCurrent8 > 0 and denETF8 > 0) ? num8 / math.sqrt(denCurrent8 * denETF8) : na
//     array.set(corrValues, 8, corr8)
    
    // ========== TICKER 9 ==========
    arrETF9 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF9, j, close10[j])
//     float sumCurrent9 = 0.0
//     float sumETF9 = 0.0
    for j = 0 to l - 1
//         sumCurrent9 += array.get(arrCurrent, j)
//         sumETF9 += array.get(arrETF9, j)
//     float meanCurrent9 = sumCurrent9 / l
//     float meanETF9 = sumETF9 / l
//     float num9 = 0.0
//     float denCurrent9 = 0.0
//     float denETF9 = 0.0
    for j = 0 to l - 1
//         float dCurrent9 = array.get(arrCurrent, j) - meanCurrent9
//         float dETF9 = array.get(arrETF9, j) - meanETF9
//         num9 += dCurrent9 * dETF9
//         denCurrent9 += dCurrent9 * dCurrent9
//         denETF9 += dETF9 * dETF9
//     float corr9 = (denCurrent9 > 0 and denETF9 > 0) ? num9 / math.sqrt(denCurrent9 * denETF9) : na
//     array.set(corrValues, 9, corr9)
    
    // ========== TICKER 10 ==========
    arrETF10 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF10, j, close11[j])
//     float sumCurrent10 = 0.0
//     float sumETF10 = 0.0
    for j = 0 to l - 1
//         sumCurrent10 += array.get(arrCurrent, j)
//         sumETF10 += array.get(arrETF10, j)
//     float meanCurrent10 = sumCurrent10 / l
//     float meanETF10 = sumETF10 / l
//     float num10 = 0.0
//     float denCurrent10 = 0.0
//     float denETF10 = 0.0
    for j = 0 to l - 1
//         float dCurrent10 = array.get(arrCurrent, j) - meanCurrent10
//         float dETF10 = array.get(arrETF10, j) - meanETF10
//         num10 += dCurrent10 * dETF10
//         denCurrent10 += dCurrent10 * dCurrent10
//         denETF10 += dETF10 * dETF10
//     float corr10 = (denCurrent10 > 0 and denETF10 > 0) ? num10 / math.sqrt(denCurrent10 * denETF10) : na
//     array.set(corrValues, 10, corr10)
    
    // ========== TICKER 11 ==========
    arrETF11 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF11, j, close12[j])
//     float sumCurrent11 = 0.0
//     float sumETF11 = 0.0
    for j = 0 to l - 1
//         sumCurrent11 += array.get(arrCurrent, j)
//         sumETF11 += array.get(arrETF11, j)
//     float meanCurrent11 = sumCurrent11 / l
//     float meanETF11 = sumETF11 / l
//     float num11 = 0.0
//     float denCurrent11 = 0.0
//     float denETF11 = 0.0
    for j = 0 to l - 1
//         float dCurrent11 = array.get(arrCurrent, j) - meanCurrent11
//         float dETF11 = array.get(arrETF11, j) - meanETF11
//         num11 += dCurrent11 * dETF11
//         denCurrent11 += dCurrent11 * dCurrent11
//         denETF11 += dETF11 * dETF11
//     float corr11 = (denCurrent11 > 0 and denETF11 > 0) ? num11 / math.sqrt(denCurrent11 * denETF11) : na
//     array.set(corrValues, 11, corr11)
    
    // ========== TICKER 12 ==========
    arrETF12 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF12, j, close13[j])
//     float sumCurrent12 = 0.0
//     float sumETF12 = 0.0
    for j = 0 to l - 1
//         sumCurrent12 += array.get(arrCurrent, j)
//         sumETF12 += array.get(arrETF12, j)
//     float meanCurrent12 = sumCurrent12 / l
//     float meanETF12 = sumETF12 / l
//     float num12 = 0.0
//     float denCurrent12 = 0.0
//     float denETF12 = 0.0
    for j = 0 to l - 1
//         float dCurrent12 = array.get(arrCurrent, j) - meanCurrent12
//         float dETF12 = array.get(arrETF12, j) - meanETF12
//         num12 += dCurrent12 * dETF12
//         denCurrent12 += dCurrent12 * dCurrent12
//         denETF12 += dETF12 * dETF12
//     float corr12 = (denCurrent12 > 0 and denETF12 > 0) ? num12 / math.sqrt(denCurrent12 * denETF12) : na
//     array.set(corrValues, 12, corr12)
    
    // ========== TICKER 13 ==========
    arrETF13 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF13, j, close14[j])
//     float sumCurrent13 = 0.0
//     float sumETF13 = 0.0
    for j = 0 to l - 1
//         sumCurrent13 += array.get(arrCurrent, j)
//         sumETF13 += array.get(arrETF13, j)
//     float meanCurrent13 = sumCurrent13 / l
//     float meanETF13 = sumETF13 / l
//     float num13 = 0.0
//     float denCurrent13 = 0.0
//     float denETF13 = 0.0
    for j = 0 to l - 1
//         float dCurrent13 = array.get(arrCurrent, j) - meanCurrent13
//         float dETF13 = array.get(arrETF13, j) - meanETF13
//         num13 += dCurrent13 * dETF13
//         denCurrent13 += dCurrent13 * dCurrent13
//         denETF13 += dETF13 * dETF13
//     float corr13 = (denCurrent13 > 0 and denETF13 > 0) ? num13 / math.sqrt(denCurrent13 * denETF13) : na
//     array.set(corrValues, 13, corr13)
    
    // ========== TICKER 14 ==========
    arrETF14 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF14, j, close15[j])
//     float sumCurrent14 = 0.0
//     float sumETF14 = 0.0
    for j = 0 to l - 1
//         sumCurrent14 += array.get(arrCurrent, j)
//         sumETF14 += array.get(arrETF14, j)
//     float meanCurrent14 = sumCurrent14 / l
//     float meanETF14 = sumETF14 / l
//     float num14 = 0.0
//     float denCurrent14 = 0.0
//     float denETF14 = 0.0
    for j = 0 to l - 1
//         float dCurrent14 = array.get(arrCurrent, j) - meanCurrent14
//         float dETF14 = array.get(arrETF14, j) - meanETF14
//         num14 += dCurrent14 * dETF14
//         denCurrent14 += dCurrent14 * dCurrent14
//         denETF14 += dETF14 * dETF14
//     float corr14 = (denCurrent14 > 0 and denETF14 > 0) ? num14 / math.sqrt(denCurrent14 * denETF14) : na
//     array.set(corrValues, 14, corr14)
    
    // ========== TICKER 15 ==========
    arrETF15 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF15, j, close16[j])
//     float sumCurrent15 = 0.0
//     float sumETF15 = 0.0
    for j = 0 to l - 1
//         sumCurrent15 += array.get(arrCurrent, j)
//         sumETF15 += array.get(arrETF15, j)
//     float meanCurrent15 = sumCurrent15 / l
//     float meanETF15 = sumETF15 / l
//     float num15 = 0.0
//     float denCurrent15 = 0.0
//     float denETF15 = 0.0
    for j = 0 to l - 1
//         float dCurrent15 = array.get(arrCurrent, j) - meanCurrent15
//         float dETF15 = array.get(arrETF15, j) - meanETF15
//         num15 += dCurrent15 * dETF15
//         denCurrent15 += dCurrent15 * dCurrent15
//         denETF15 += dETF15 * dETF15
//     float corr15 = (denCurrent15 > 0 and denETF15 > 0) ? num15 / math.sqrt(denCurrent15 * denETF15) : na
//     array.set(corrValues, 15, corr15)
    
    // ========== TICKER 16 ==========
    arrETF16 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF16, j, close17[j])
//     float sumCurrent16 = 0.0
//     float sumETF16 = 0.0
    for j = 0 to l - 1
//         sumCurrent16 += array.get(arrCurrent, j)
//         sumETF16 += array.get(arrETF16, j)
//     float meanCurrent16 = sumCurrent16 / l
//     float meanETF16 = sumETF16 / l
//     float num16 = 0.0
//     float denCurrent16 = 0.0
//     float denETF16 = 0.0
    for j = 0 to l - 1
//         float dCurrent16 = array.get(arrCurrent, j) - meanCurrent16
//         float dETF16 = array.get(arrETF16, j) - meanETF16
//         num16 += dCurrent16 * dETF16
//         denCurrent16 += dCurrent16 * dCurrent16
//         denETF16 += dETF16 * dETF16
//     float corr16 = (denCurrent16 > 0 and denETF16 > 0) ? num16 / math.sqrt(denCurrent16 * denETF16) : na
//     array.set(corrValues, 16, corr16)
    
    // ========== TICKER 17 ==========
    arrETF17 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF17, j, close18[j])
//     float sumCurrent17 = 0.0
//     float sumETF17 = 0.0
    for j = 0 to l - 1
//         sumCurrent17 += array.get(arrCurrent, j)
//         sumETF17 += array.get(arrETF17, j)
//     float meanCurrent17 = sumCurrent17 / l
//     float meanETF17 = sumETF17 / l
//     float num17 = 0.0
//     float denCurrent17 = 0.0
//     float denETF17 = 0.0
    for j = 0 to l - 1
//         float dCurrent17 = array.get(arrCurrent, j) - meanCurrent17
//         float dETF17 = array.get(arrETF17, j) - meanETF17
//         num17 += dCurrent17 * dETF17
//         denCurrent17 += dCurrent17 * dCurrent17
//         denETF17 += dETF17 * dETF17
//     float corr17 = (denCurrent17 > 0 and denETF17 > 0) ? num17 / math.sqrt(denCurrent17 * denETF17) : na
//     array.set(corrValues, 17, corr17)
    
    // ========== TICKER 18 ==========
    arrETF18 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF18, j, close19[j])
//     float sumCurrent18 = 0.0
//     float sumETF18 = 0.0
    for j = 0 to l - 1
//         sumCurrent18 += array.get(arrCurrent, j)
//         sumETF18 += array.get(arrETF18, j)
//     float meanCurrent18 = sumCurrent18 / l
//     float meanETF18 = sumETF18 / l
//     float num18 = 0.0
//     float denCurrent18 = 0.0
//     float denETF18 = 0.0
    for j = 0 to l - 1
//         float dCurrent18 = array.get(arrCurrent, j) - meanCurrent18
//         float dETF18 = array.get(arrETF18, j) - meanETF18
//         num18 += dCurrent18 * dETF18
//         denCurrent18 += dCurrent18 * dCurrent18
//         denETF18 += dETF18 * dETF18
//     float corr18 = (denCurrent18 > 0 and denETF18 > 0) ? num18 / math.sqrt(denCurrent18 * denETF18) : na
//     array.set(corrValues, 18, corr18)
    
    // ========== TICKER 19 ==========
    arrETF19 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF19, j, close20[j])
//     float sumCurrent19 = 0.0
//     float sumETF19 = 0.0
    for j = 0 to l - 1
//         sumCurrent19 += array.get(arrCurrent, j)
//         sumETF19 += array.get(arrETF19, j)
//     float meanCurrent19 = sumCurrent19 / l
//     float meanETF19 = sumETF19 / l
//     float num19 = 0.0
//     float denCurrent19 = 0.0
//     float denETF19 = 0.0
    for j = 0 to l - 1
//         float dCurrent19 = array.get(arrCurrent, j) - meanCurrent19
//         float dETF19 = array.get(arrETF19, j) - meanETF19
//         num19 += dCurrent19 * dETF19
//         denCurrent19 += dCurrent19 * dCurrent19
//         denETF19 += dETF19 * dETF19
//     float corr19 = (denCurrent19 > 0 and denETF19 > 0) ? num19 / math.sqrt(denCurrent19 * denETF19) : na
//     array.set(corrValues, 19, corr19)
    
    // ========== TICKER 20 ==========
    arrETF20 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF20, j, close21[j])
//     float sumCurrent20 = 0.0
//     float sumETF20 = 0.0
    for j = 0 to l - 1
//         sumCurrent20 += array.get(arrCurrent, j)
//         sumETF20 += array.get(arrETF20, j)
//     float meanCurrent20 = sumCurrent20 / l
//     float meanETF20 = sumETF20 / l
//     float num20 = 0.0
//     float denCurrent20 = 0.0
//     float denETF20 = 0.0
    for j = 0 to l - 1
//         float dCurrent20 = array.get(arrCurrent, j) - meanCurrent20
//         float dETF20 = array.get(arrETF20, j) - meanETF20
//         num20 += dCurrent20 * dETF20
//         denCurrent20 += dCurrent20 * dCurrent20
//         denETF20 += dETF20 * dETF20
//     float corr20 = (denCurrent20 > 0 and denETF20 > 0) ? num20 / math.sqrt(denCurrent20 * denETF20) : na
//     array.set(corrValues, 20, corr20)
    
    // ========== TICKER 21 ==========
    arrETF21 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF21, j, close22[j])
//     float sumCurrent21 = 0.0
//     float sumETF21 = 0.0
    for j = 0 to l - 1
//         sumCurrent21 += array.get(arrCurrent, j)
//         sumETF21 += array.get(arrETF21, j)
//     float meanCurrent21 = sumCurrent21 / l
//     float meanETF21 = sumETF21 / l
//     float num21 = 0.0
//     float denCurrent21 = 0.0
//     float denETF21 = 0.0
    for j = 0 to l - 1
//         float dCurrent21 = array.get(arrCurrent, j) - meanCurrent21
//         float dETF21 = array.get(arrETF21, j) - meanETF21
//         num21 += dCurrent21 * dETF21
//         denCurrent21 += dCurrent21 * dCurrent21
//         denETF21 += dETF21 * dETF21
//     float corr21 = (denCurrent21 > 0 and denETF21 > 0) ? num21 / math.sqrt(denCurrent21 * denETF21) : na
//     array.set(corrValues, 21, corr21)
    
    // ========== TICKER 22 ==========
    arrETF22 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF22, j, close23[j])
//     float sumCurrent22 = 0.0
//     float sumETF22 = 0.0
    for j = 0 to l - 1
//         sumCurrent22 += array.get(arrCurrent, j)
//         sumETF22 += array.get(arrETF22, j)
//     float meanCurrent22 = sumCurrent22 / l
//     float meanETF22 = sumETF22 / l
//     float num22 = 0.0
//     float denCurrent22 = 0.0
//     float denETF22 = 0.0
    for j = 0 to l - 1
//         float dCurrent22 = array.get(arrCurrent, j) - meanCurrent22
//         float dETF22 = array.get(arrETF22, j) - meanETF22
//         num22 += dCurrent22 * dETF22
//         denCurrent22 += dCurrent22 * dCurrent22
//         denETF22 += dETF22 * dETF22
//     float corr22 = (denCurrent22 > 0 and denETF22 > 0) ? num22 / math.sqrt(denCurrent22 * denETF22) : na
//     array.set(corrValues, 22, corr22)
    
    // ========== TICKER 23 ==========
    arrETF23 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF23, j, close24[j])
//     float sumCurrent23 = 0.0
//     float sumETF23 = 0.0
    for j = 0 to l - 1
//         sumCurrent23 += array.get(arrCurrent, j)
//         sumETF23 += array.get(arrETF23, j)
//     float meanCurrent23 = sumCurrent23 / l
//     float meanETF23 = sumETF23 / l
//     float num23 = 0.0
//     float denCurrent23 = 0.0
//     float denETF23 = 0.0
    for j = 0 to l - 1
//         float dCurrent23 = array.get(arrCurrent, j) - meanCurrent23
//         float dETF23 = array.get(arrETF23, j) - meanETF23
//         num23 += dCurrent23 * dETF23
//         denCurrent23 += dCurrent23 * dCurrent23
//         denETF23 += dETF23 * dETF23
//     float corr23 = (denCurrent23 > 0 and denETF23 > 0) ? num23 / math.sqrt(denCurrent23 * denETF23) : na
//     array.set(corrValues, 23, corr23)
    
    // ========== TICKER 24 ==========
    arrETF24 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF24, j, close25[j])
//     float sumCurrent24 = 0.0
//     float sumETF24 = 0.0
    for j = 0 to l - 1
//         sumCurrent24 += array.get(arrCurrent, j)
//         sumETF24 += array.get(arrETF24, j)
//     float meanCurrent24 = sumCurrent24 / l
//     float meanETF24 = sumETF24 / l
//     float num24 = 0.0
//     float denCurrent24 = 0.0
//     float denETF24 = 0.0
    for j = 0 to l - 1
//         float dCurrent24 = array.get(arrCurrent, j) - meanCurrent24
//         float dETF24 = array.get(arrETF24, j) - meanETF24
//         num24 += dCurrent24 * dETF24
//         denCurrent24 += dCurrent24 * dCurrent24
//         denETF24 += dETF24 * dETF24
//     float corr24 = (denCurrent24 > 0 and denETF24 > 0) ? num24 / math.sqrt(denCurrent24 * denETF24) : na
//     array.set(corrValues, 24, corr24)
    
    // ========== TICKER 25 ==========
    arrETF25 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF25, j, close26[j])
//     float sumCurrent25 = 0.0
//     float sumETF25 = 0.0
    for j = 0 to l - 1
//         sumCurrent25 += array.get(arrCurrent, j)
//         sumETF25 += array.get(arrETF25, j)
//     float meanCurrent25 = sumCurrent25 / l
//     float meanETF25 = sumETF25 / l
//     float num25 = 0.0
//     float denCurrent25 = 0.0
//     float denETF25 = 0.0
    for j = 0 to l - 1
//         float dCurrent25 = array.get(arrCurrent, j) - meanCurrent25
//         float dETF25 = array.get(arrETF25, j) - meanETF25
//         num25 += dCurrent25 * dETF25
//         denCurrent25 += dCurrent25 * dCurrent25
//         denETF25 += dETF25 * dETF25
//     float corr25 = (denCurrent25 > 0 and denETF25 > 0) ? num25 / math.sqrt(denCurrent25 * denETF25) : na
//     array.set(corrValues, 25, corr25)
    
    // ========== TICKER 26 ==========
    arrETF26 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF26, j, close27[j])
//     float sumCurrent26 = 0.0
//     float sumETF26 = 0.0
    for j = 0 to l - 1
//         sumCurrent26 += array.get(arrCurrent, j)
//         sumETF26 += array.get(arrETF26, j)
//     float meanCurrent26 = sumCurrent26 / l
//     float meanETF26 = sumETF26 / l
//     float num26 = 0.0
//     float denCurrent26 = 0.0
//     float denETF26 = 0.0
    for j = 0 to l - 1
//         float dCurrent26 = array.get(arrCurrent, j) - meanCurrent26
//         float dETF26 = array.get(arrETF26, j) - meanETF26
//         num26 += dCurrent26 * dETF26
//         denCurrent26 += dCurrent26 * dCurrent26
//         denETF26 += dETF26 * dETF26
//     float corr26 = (denCurrent26 > 0 and denETF26 > 0) ? num26 / math.sqrt(denCurrent26 * denETF26) : na
//     array.set(corrValues, 26, corr26)
    
    // ========== TICKER 27 ==========
    arrETF27 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF27, j, close28[j])
//     float sumCurrent27 = 0.0
//     float sumETF27 = 0.0
    for j = 0 to l - 1
//         sumCurrent27 += array.get(arrCurrent, j)
//         sumETF27 += array.get(arrETF27, j)
//     float meanCurrent27 = sumCurrent27 / l
//     float meanETF27 = sumETF27 / l
//     float num27 = 0.0
//     float denCurrent27 = 0.0
//     float denETF27 = 0.0
    for j = 0 to l - 1
//         float dCurrent27 = array.get(arrCurrent, j) - meanCurrent27
//         float dETF27 = array.get(arrETF27, j) - meanETF27
//         num27 += dCurrent27 * dETF27
//         denCurrent27 += dCurrent27 * dCurrent27
//         denETF27 += dETF27 * dETF27
//     float corr27 = (denCurrent27 > 0 and denETF27 > 0) ? num27 / math.sqrt(denCurrent27 * denETF27) : na
//     array.set(corrValues, 27, corr27)
    
    // ========== TICKER 28 ==========
    arrETF28 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF28, j, close29[j])
//     float sumCurrent28 = 0.0
//     float sumETF28 = 0.0
    for j = 0 to l - 1
//         sumCurrent28 += array.get(arrCurrent, j)
//         sumETF28 += array.get(arrETF28, j)
//     float meanCurrent28 = sumCurrent28 / l
//     float meanETF28 = sumETF28 / l
//     float num28 = 0.0
//     float denCurrent28 = 0.0
//     float denETF28 = 0.0
    for j = 0 to l - 1
//         float dCurrent28 = array.get(arrCurrent, j) - meanCurrent28
//         float dETF28 = array.get(arrETF28, j) - meanETF28
//         num28 += dCurrent28 * dETF28
//         denCurrent28 += dCurrent28 * dCurrent28
//         denETF28 += dETF28 * dETF28
//     float corr28 = (denCurrent28 > 0 and denETF28 > 0) ? num28 / math.sqrt(denCurrent28 * denETF28) : na
//     array.set(corrValues, 28, corr28)
    
    // ========== TICKER 29 ==========
    arrETF29 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF29, j, close30[j])
//     float sumCurrent29 = 0.0
//     float sumETF29 = 0.0
    for j = 0 to l - 1
//         sumCurrent29 += array.get(arrCurrent, j)
//         sumETF29 += array.get(arrETF29, j)
//     float meanCurrent29 = sumCurrent29 / l
//     float meanETF29 = sumETF29 / l
//     float num29 = 0.0
//     float denCurrent29 = 0.0
//     float denETF29 = 0.0
    for j = 0 to l - 1
//         float dCurrent29 = array.get(arrCurrent, j) - meanCurrent29
//         float dETF29 = array.get(arrETF29, j) - meanETF29
//         num29 += dCurrent29 * dETF29
//         denCurrent29 += dCurrent29 * dCurrent29
//         denETF29 += dETF29 * dETF29
//     float corr29 = (denCurrent29 > 0 and denETF29 > 0) ? num29 / math.sqrt(denCurrent29 * denETF29) : na
//     array.set(corrValues, 29, corr29)
    
    // ========== TICKER 30 ==========
    arrETF30 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF30, j, close31[j])
//     float sumCurrent30 = 0.0
//     float sumETF30 = 0.0
    for j = 0 to l - 1
//         sumCurrent30 += array.get(arrCurrent, j)
//         sumETF30 += array.get(arrETF30, j)
//     float meanCurrent30 = sumCurrent30 / l
//     float meanETF30 = sumETF30 / l
//     float num30 = 0.0
//     float denCurrent30 = 0.0
//     float denETF30 = 0.0
    for j = 0 to l - 1
//         float dCurrent30 = array.get(arrCurrent, j) - meanCurrent30
//         float dETF30 = array.get(arrETF30, j) - meanETF30
//         num30 += dCurrent30 * dETF30
//         denCurrent30 += dCurrent30 * dCurrent30
//         denETF30 += dETF30 * dETF30
//     float corr30 = (denCurrent30 > 0 and denETF30 > 0) ? num30 / math.sqrt(denCurrent30 * denETF30) : na
//     array.set(corrValues, 30, corr30)
    
    // ========== TICKER 31 ==========
    arrETF31 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF31, j, close32[j])
//     float sumCurrent31 = 0.0
//     float sumETF31 = 0.0
    for j = 0 to l - 1
//         sumCurrent31 += array.get(arrCurrent, j)
//         sumETF31 += array.get(arrETF31, j)
//     float meanCurrent31 = sumCurrent31 / l
//     float meanETF31 = sumETF31 / l
//     float num31 = 0.0
//     float denCurrent31 = 0.0
//     float denETF31 = 0.0
    for j = 0 to l - 1
//         float dCurrent31 = array.get(arrCurrent, j) - meanCurrent31
//         float dETF31 = array.get(arrETF31, j) - meanETF31
//         num31 += dCurrent31 * dETF31
//         denCurrent31 += dCurrent31 * dCurrent31
//         denETF31 += dETF31 * dETF31
//     float corr31 = (denCurrent31 > 0 and denETF31 > 0) ? num31 / math.sqrt(denCurrent31 * denETF31) : na
//     array.set(corrValues, 31, corr31)
    
    // ========== TICKER 32 ==========
    arrETF32 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF32, j, close33[j])
//     float sumCurrent32 = 0.0
//     float sumETF32 = 0.0
    for j = 0 to l - 1
//         sumCurrent32 += array.get(arrCurrent, j)
//         sumETF32 += array.get(arrETF32, j)
//     float meanCurrent32 = sumCurrent32 / l
//     float meanETF32 = sumETF32 / l
//     float num32 = 0.0
//     float denCurrent32 = 0.0
//     float denETF32 = 0.0
    for j = 0 to l - 1
//         float dCurrent32 = array.get(arrCurrent, j) - meanCurrent32
//         float dETF32 = array.get(arrETF32, j) - meanETF32
//         num32 += dCurrent32 * dETF32
//         denCurrent32 += dCurrent32 * dCurrent32
//         denETF32 += dETF32 * dETF32
//     float corr32 = (denCurrent32 > 0 and denETF32 > 0) ? num32 / math.sqrt(denCurrent32 * denETF32) : na
//     array.set(corrValues, 32, corr32)
    
    // ========== TICKER 33 ==========
    arrETF33 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF33, j, close34[j])
//     float sumCurrent33 = 0.0
//     float sumETF33 = 0.0
    for j = 0 to l - 1
//         sumCurrent33 += array.get(arrCurrent, j)
//         sumETF33 += array.get(arrETF33, j)
//     float meanCurrent33 = sumCurrent33 / l
//     float meanETF33 = sumETF33 / l
//     float num33 = 0.0
//     float denCurrent33 = 0.0
//     float denETF33 = 0.0
    for j = 0 to l - 1
//         float dCurrent33 = array.get(arrCurrent, j) - meanCurrent33
//         float dETF33 = array.get(arrETF33, j) - meanETF33
//         num33 += dCurrent33 * dETF33
//         denCurrent33 += dCurrent33 * dCurrent33
//         denETF33 += dETF33 * dETF33
//     float corr33 = (denCurrent33 > 0 and denETF33 > 0) ? num33 / math.sqrt(denCurrent33 * denETF33) : na
//     array.set(corrValues, 33, corr33)
    
    // ========== TICKER 34 ==========
    arrETF34 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF34, j, close35[j])
//     float sumCurrent34 = 0.0
//     float sumETF34 = 0.0
    for j = 0 to l - 1
//         sumCurrent34 += array.get(arrCurrent, j)
//         sumETF34 += array.get(arrETF34, j)
//     float meanCurrent34 = sumCurrent34 / l
//     float meanETF34 = sumETF34 / l
//     float num34 = 0.0
//     float denCurrent34 = 0.0
//     float denETF34 = 0.0
    for j = 0 to l - 1
//         float dCurrent34 = array.get(arrCurrent, j) - meanCurrent34
//         float dETF34 = array.get(arrETF34, j) - meanETF34
//         num34 += dCurrent34 * dETF34
//         denCurrent34 += dCurrent34 * dCurrent34
//         denETF34 += dETF34 * dETF34
//     float corr34 = (denCurrent34 > 0 and denETF34 > 0) ? num34 / math.sqrt(denCurrent34 * denETF34) : na
//     array.set(corrValues, 34, corr34)
    
    // ========== TICKER 35 ==========
    arrETF35 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF35, j, close36[j])
//     float sumCurrent35 = 0.0
//     float sumETF35 = 0.0
    for j = 0 to l - 1
//         sumCurrent35 += array.get(arrCurrent, j)
//         sumETF35 += array.get(arrETF35, j)
//     float meanCurrent35 = sumCurrent35 / l
//     float meanETF35 = sumETF35 / l
//     float num35 = 0.0
//     float denCurrent35 = 0.0
//     float denETF35 = 0.0
    for j = 0 to l - 1
//         float dCurrent35 = array.get(arrCurrent, j) - meanCurrent35
//         float dETF35 = array.get(arrETF35, j) - meanETF35
//         num35 += dCurrent35 * dETF35
//         denCurrent35 += dCurrent35 * dCurrent35
//         denETF35 += dETF35 * dETF35
//     float corr35 = (denCurrent35 > 0 and denETF35 > 0) ? num35 / math.sqrt(denCurrent35 * denETF35) : na
//     array.set(corrValues, 35, corr35)
    
    // ========== TICKER 36 ==========
    arrETF36 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF36, j, close37[j])
//     float sumCurrent36 = 0.0
//     float sumETF36 = 0.0
    for j = 0 to l - 1
//         sumCurrent36 += array.get(arrCurrent, j)
//         sumETF36 += array.get(arrETF36, j)
//     float meanCurrent36 = sumCurrent36 / l
//     float meanETF36 = sumETF36 / l
//     float num36 = 0.0
//     float denCurrent36 = 0.0
//     float denETF36 = 0.0
    for j = 0 to l - 1
//         float dCurrent36 = array.get(arrCurrent, j) - meanCurrent36
//         float dETF36 = array.get(arrETF36, j) - meanETF36
//         num36 += dCurrent36 * dETF36
//         denCurrent36 += dCurrent36 * dCurrent36
//         denETF36 += dETF36 * dETF36
//     float corr36 = (denCurrent36 > 0 and denETF36 > 0) ? num36 / math.sqrt(denCurrent36 * denETF36) : na
//     array.set(corrValues, 36, corr36)
    
    // ========== TICKER 37 ==========
    arrETF37 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF37, j, close38[j])
//     float sumCurrent37 = 0.0
//     float sumETF37 = 0.0
    for j = 0 to l - 1
//         sumCurrent37 += array.get(arrCurrent, j)
//         sumETF37 += array.get(arrETF37, j)
//     float meanCurrent37 = sumCurrent37 / l
//     float meanETF37 = sumETF37 / l
//     float num37 = 0.0
//     float denCurrent37 = 0.0
//     float denETF37 = 0.0
    for j = 0 to l - 1
//         float dCurrent37 = array.get(arrCurrent, j) - meanCurrent37
//         float dETF37 = array.get(arrETF37, j) - meanETF37
//         num37 += dCurrent37 * dETF37
//         denCurrent37 += dCurrent37 * dCurrent37
//         denETF37 += dETF37 * dETF37
//     float corr37 = (denCurrent37 > 0 and denETF37 > 0) ? num37 / math.sqrt(denCurrent37 * denETF37) : na
//     array.set(corrValues, 37, corr37)
    
    // ========== TICKER 38 ==========
    arrETF38 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF38, j, close39[j])
//     float sumCurrent38 = 0.0
//     float sumETF38 = 0.0
    for j = 0 to l - 1
//         sumCurrent38 += array.get(arrCurrent, j)
//         sumETF38 += array.get(arrETF38, j)
//     float meanCurrent38 = sumCurrent38 / l
//     float meanETF38 = sumETF38 / l
//     float num38 = 0.0
//     float denCurrent38 = 0.0
//     float denETF38 = 0.0
    for j = 0 to l - 1
//         float dCurrent38 = array.get(arrCurrent, j) - meanCurrent38
//         float dETF38 = array.get(arrETF38, j) - meanETF38
//         num38 += dCurrent38 * dETF38
//         denCurrent38 += dCurrent38 * dCurrent38
//         denETF38 += dETF38 * dETF38
//     float corr38 = (denCurrent38 > 0 and denETF38 > 0) ? num38 / math.sqrt(denCurrent38 * denETF38) : na
//     array.set(corrValues, 38, corr38)
    
    // ========== TICKER 39 ==========
    arrETF39 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF39, j, close40[j])
//     float sumCurrent39 = 0.0
//     float sumETF39 = 0.0
    for j = 0 to l - 1
//         sumCurrent39 += array.get(arrCurrent, j)
//         sumETF39 += array.get(arrETF39, j)
//     float meanCurrent39 = sumCurrent39 / l
//     float meanETF39 = sumETF39 / l
//     float num39 = 0.0
//     float denCurrent39 = 0.0
//     float denETF39 = 0.0
    for j = 0 to l - 1
//         float dCurrent39 = array.get(arrCurrent, j) - meanCurrent39
//         float dETF39 = array.get(arrETF39, j) - meanETF39
//         num39 += dCurrent39 * dETF39
//         denCurrent39 += dCurrent39 * dCurrent39
//         denETF39 += dETF39 * dETF39
//     float corr39 = (denCurrent39 > 0 and denETF39 > 0) ? num39 / math.sqrt(denCurrent39 * denETF39) : na
//     array.set(corrValues, 39, corr39)
    
//––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
// 1 · SEARCH FOR BEST-MATCH ETF SEGMENT
if bar_index >= l
    // Reset best-match trackers for this bar
//     maxCorr     := na
//     bestETF     := na
//     base        := na
//     target      := na
//     scaleFactor := na

    // Ensure bestFit has correct length
    if array.size(bestFit) != l
//         bestFit := array.new_float(l, 0.0)

    // Get current symbol to exclude from matching
    currentSymbol = syminfo.ticker

    // BUILD CURRENT CHART ARRAY
    arrCurrent = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrCurrent, j, close[j])

    // Array to store correlation values
    corrValues = array.new_float(40, na)
    
    // Calculate correlations for all 40 tickers
    arrETF0 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF0, j, close1[j])
//     array.set(corrValues, 0, calcCorrelation(arrCurrent, arrETF0, l))
    
    arrETF1 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF1, j, close2[j])
//     array.set(corrValues, 1, calcCorrelation(arrCurrent, arrETF1, l))
    
    arrETF2 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF2, j, close3[j])
//     array.set(corrValues, 2, calcCorrelation(arrCurrent, arrETF2, l))
    
    arrETF3 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF3, j, close4[j])
//     array.set(corrValues, 3, calcCorrelation(arrCurrent, arrETF3, l))
    
    arrETF4 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF4, j, close5[j])
//     array.set(corrValues, 4, calcCorrelation(arrCurrent, arrETF4, l))
    
    arrETF5 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF5, j, close6[j])
//     array.set(corrValues, 5, calcCorrelation(arrCurrent, arrETF5, l))
    
    arrETF6 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF6, j, close7[j])
//     array.set(corrValues, 6, calcCorrelation(arrCurrent, arrETF6, l))
    
    arrETF7 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF7, j, close8[j])
//     array.set(corrValues, 7, calcCorrelation(arrCurrent, arrETF7, l))
    
    arrETF8 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF8, j, close9[j])
//     array.set(corrValues, 8, calcCorrelation(arrCurrent, arrETF8, l))
    
    arrETF9 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF9, j, close10[j])
//     array.set(corrValues, 9, calcCorrelation(arrCurrent, arrETF9, l))
    
    arrETF10 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF10, j, close11[j])
//     array.set(corrValues, 10, calcCorrelation(arrCurrent, arrETF10, l))
    
    arrETF11 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF11, j, close12[j])
//     array.set(corrValues, 11, calcCorrelation(arrCurrent, arrETF11, l))
    
    arrETF12 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF12, j, close13[j])
//     array.set(corrValues, 12, calcCorrelation(arrCurrent, arrETF12, l))
    
    arrETF13 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF13, j, close14[j])
//     array.set(corrValues, 13, calcCorrelation(arrCurrent, arrETF13, l))
    
    arrETF14 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF14, j, close15[j])
//     array.set(corrValues, 14, calcCorrelation(arrCurrent, arrETF14, l))
    
    arrETF15 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF15, j, close16[j])
//     array.set(corrValues, 15, calcCorrelation(arrCurrent, arrETF15, l))
    
    arrETF16 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF16, j, close17[j])
//     array.set(corrValues, 16, calcCorrelation(arrCurrent, arrETF16, l))
    
    arrETF17 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF17, j, close18[j])
//     array.set(corrValues, 17, calcCorrelation(arrCurrent, arrETF17, l))
    
    arrETF18 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF18, j, close19[j])
//     array.set(corrValues, 18, calcCorrelation(arrCurrent, arrETF18, l))
    
    arrETF19 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF19, j, close20[j])
//     array.set(corrValues, 19, calcCorrelation(arrCurrent, arrETF19, l))
    
    arrETF20 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF20, j, close21[j])
//     array.set(corrValues, 20, calcCorrelation(arrCurrent, arrETF20, l))
    
    arrETF21 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF21, j, close22[j])
//     array.set(corrValues, 21, calcCorrelation(arrCurrent, arrETF21, l))
    
    arrETF22 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF22, j, close23[j])
//     array.set(corrValues, 22, calcCorrelation(arrCurrent, arrETF22, l))
    
    arrETF23 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF23, j, close24[j])
//     array.set(corrValues, 23, calcCorrelation(arrCurrent, arrETF23, l))
    
    arrETF24 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF24, j, close25[j])
//     array.set(corrValues, 24, calcCorrelation(arrCurrent, arrETF24, l))
    
    arrETF25 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF25, j, close26[j])
//     array.set(corrValues, 25, calcCorrelation(arrCurrent, arrETF25, l))
    
    arrETF26 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF26, j, close27[j])
//     array.set(corrValues, 26, calcCorrelation(arrCurrent, arrETF26, l))
    
    arrETF27 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF27, j, close28[j])
//     array.set(corrValues, 27, calcCorrelation(arrCurrent, arrETF27, l))
    
    arrETF28 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF28, j, close29[j])
//     array.set(corrValues, 28, calcCorrelation(arrCurrent, arrETF28, l))
    
    arrETF29 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF29, j, close30[j])
//     array.set(corrValues, 29, calcCorrelation(arrCurrent, arrETF29, l))
    
    arrETF30 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF30, j, close31[j])
//     array.set(corrValues, 30, calcCorrelation(arrCurrent, arrETF30, l))
    
    arrETF31 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF31, j, close32[j])
//     array.set(corrValues, 31, calcCorrelation(arrCurrent, arrETF31, l))
    
    arrETF32 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF32, j, close33[j])
//     array.set(corrValues, 32, calcCorrelation(arrCurrent, arrETF32, l))
    
    arrETF33 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF33, j, close34[j])
//     array.set(corrValues, 33, calcCorrelation(arrCurrent, arrETF33, l))
    
    arrETF34 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF34, j, close35[j])
//     array.set(corrValues, 34, calcCorrelation(arrCurrent, arrETF34, l))
    
    arrETF35 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF35, j, close36[j])
//     array.set(corrValues, 35, calcCorrelation(arrCurrent, arrETF35, l))
    
    arrETF36 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF36, j, close37[j])
//     array.set(corrValues, 36, calcCorrelation(arrCurrent, arrETF36, l))
    
    arrETF37 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF37, j, close38[j])
//     array.set(corrValues, 37, calcCorrelation(arrCurrent, arrETF37, l))
    
    arrETF38 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF38, j, close39[j])
//     array.set(corrValues, 38, calcCorrelation(arrCurrent, arrETF38, l))
    
    arrETF39 = array.new_float(l)
    for j = 0 to l - 1
//         array.set(arrETF39, j, close40[j])
//     array.set(corrValues, 39, calcCorrelation(arrCurrent, arrETF39, l))
    




    // ========== FIND BEST MATCH ==========
    tickerNames = array.from(ticker1, ticker2, ticker3, ticker4, ticker5, ticker6, ticker7, ticker8, ticker9, ticker10,
//                              ticker11, ticker12, ticker13, ticker14, ticker15, ticker16, ticker17, ticker18, ticker19, ticker20,
//                              ticker21, ticker22, ticker23, ticker24, ticker25, ticker26, ticker27, ticker28, ticker29, ticker30,
//                              ticker31, ticker32, ticker33, ticker34, ticker35, ticker36, ticker37, ticker38, ticker39, ticker40)
    
    
    // Loop through all tickers to find best match (excluding current symbol)
    for i = 0 to 39
        corrVal = array.get(corrValues, i)
        tickerName = array.get(tickerNames, i)
        
        // Strip exchange prefix from tickerName for comparison (e.g., "AMEX:SPY" -> "SPY")
        tickerSymbolOnly = str.contains(tickerName, ":") ? str.split(tickerName, ":").get(1) : tickerName
        
        if not na(corrVal) and tickerSymbolOnly != currentSymbol and (na(maxCorr) or corrVal > maxCorr)
//             maxCorr := corrVal
//             bestETF := tickerName
            
            // Get the appropriate ETF array
            etfArr = getETFArray(i, arrETF0, arrETF1, arrETF2, arrETF3, arrETF4, arrETF5, arrETF6, arrETF7, arrETF8, arrETF9,
//                                  arrETF10, arrETF11, arrETF12, arrETF13, arrETF14, arrETF15, arrETF16, arrETF17, arrETF18, arrETF19,
//                                  arrETF20, arrETF21, arrETF22, arrETF23, arrETF24, arrETF25, arrETF26, arrETF27, arrETF28, arrETF29,
//                                  arrETF30, arrETF31, arrETF32, arrETF33, arrETF34, arrETF35, arrETF36, arrETF37, arrETF38, arrETF39)
            
            // Copy to bestFit
            for j = 0 to l - 1
//                 array.set(bestFit, j, array.get(etfArr, j))
            
//             base := getCloseValue(i, close1[0], close2[0], close3[0], close4[0], close5[0], close6[0], close7[0], close8[0], close9[0], close10[0],
//                                   close11[0], close12[0], close13[0], close14[0], close15[0], close16[0], close17[0], close18[0], close19[0], close20[0],
//                                   close21[0], close22[0], close23[0], close24[0], close25[0], close26[0], close27[0], close28[0], close29[0], close30[0],
//                                   close31[0], close32[0], close33[0], close34[0], close35[0], close36[0], close37[0], close38[0], close39[0], close40[0])
            
//             target := close[0]
            etfRange = array.max(bestFit) - array.min(bestFit)
            chartRange = ta.highest(close, l) - ta.lowest(close, l)
//             scaleFactor := etfRange / (chartRange == 0.0 ? 1.0 : chartRange)

    //––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    // TABLE: SHOW ALL TICKER CORRELATIONS
    if showTickerTable
        // Header row - left columns
//         table.cell(tickerTable, 0, 0, "#",   text_color = color.white, bgcolor = color.new(color.black, 0), text_size = size.tiny)
//         table.cell(tickerTable, 1, 0, "Ticker", text_color = color.white, bgcolor = color.new(color.black, 0), text_size = size.tiny)
//         table.cell(tickerTable, 2, 0, "Corr",   text_color = color.white, bgcolor = color.new(color.black, 0), text_size = size.tiny)
        
        // Header row - right columns
//         table.cell(tickerTable, 3, 0, "#",   text_color = color.white, bgcolor = color.new(color.black, 0), text_size = size.tiny)
//         table.cell(tickerTable, 4, 0, "Ticker", text_color = color.white, bgcolor = color.new(color.black, 0), text_size = size.tiny)
//         table.cell(tickerTable, 5, 0, "Corr",   text_color = color.white, bgcolor = color.new(color.black, 0), text_size = size.tiny)

        // Fill rows: split 40 tickers into two columns (20 each)
        for i = 0 to 19
            row = i + 1
            
            // LEFT COLUMN SET (tickers 0-19)
            tName = array.get(tickerNames, i)
            // Strip exchange prefix
            tNameDisplay = str.contains(tName, ":") ? str.split(tName, ":").get(1) : tName
            cVal = array.get(corrValues, i)
            isBestRow = (not na(bestETF) and tName == bestETF)
            rowBg = isBestRow ? color.new(color.green, 0) : color.new(color.black, 80)

//             table.cell(tickerTable, 0, row, str.tostring(i),  text_color = color.white, bgcolor = rowBg, text_size = size.tiny)
//             table.cell(tickerTable, 1, row, tNameDisplay,     text_color = color.white, bgcolor = rowBg, text_size = size.tiny)
            corrText = na(cVal) ? "n/a" : str.tostring(cVal * 100.0, "#.##") + "%"
//             table.cell(tickerTable, 2, row, corrText,         text_color = color.white, bgcolor = rowBg, text_size = size.tiny)
            
            // RIGHT COLUMN SET (tickers 20-39)
            rightIdx = i + 20
            tName2 = array.get(tickerNames, rightIdx)
            // Strip exchange prefix
            tName2Display = str.contains(tName2, ":") ? str.split(tName2, ":").get(1) : tName2
            cVal2 = array.get(corrValues, rightIdx)
            isBestRow2 = (not na(bestETF) and tName2 == bestETF)
            rowBg2 = isBestRow2 ? color.new(color.green, 0) : color.new(color.black, 80)

//             table.cell(tickerTable, 3, row, str.tostring(rightIdx),  text_color = color.white, bgcolor = rowBg2, text_size = size.tiny)
//             table.cell(tickerTable, 4, row, tName2Display,           text_color = color.white, bgcolor = rowBg2, text_size = size.tiny)
            corrText2 = na(cVal2) ? "n/a" : str.tostring(cVal2 * 100.0, "#.##") + "%"
//             table.cell(tickerTable, 5, row, corrText2,               text_color = color.white, bgcolor = rowBg2, text_size = size.tiny)
//     else
        // If hidden, clear cells so it doesn't ghost
//         table.clear(tickerTable, start_row = 0, start_column = 0)

//––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
// 2 · CLEAR OLD GRAPHICS
if bar_index >= l
    if array.size(segmentLines) > 0
        for k = 0 to array.size(segmentLines) - 1
//             line.delete(array.get(segmentLines, k))
//         array.clear(segmentLines)

//––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
// 3 · DRAW MATCHED SEGMENT
if array.size(bestFit) == l and not na(base) and not na(target) and not na(scaleFactor) and scaleFactor != 0
    // Calculate range-based scale factor (used by both modes)
    chartHigh = ta.highest(close, l)
    chartLow = ta.lowest(close, l)
    chartRange = chartHigh - chartLow
    
    etfHigh = array.max(bestFit)
    etfLow = array.min(bestFit)
    etfRange = etfHigh - etfLow
    
    rangeScaleFactor = etfRange != 0 ? chartRange / etfRange : 1.0
    
    if matchMode == "Scale Only"
        // Scale to match ranges, centered at current price
        etfCurrent = array.get(bestFit, 0)
        chartCurrent = close[0]
        
        for j = 0 to l - 2
            etfVal1 = array.get(bestFit, j)
            etfVal2 = array.get(bestFit, j + 1)
            
            // Transform: scale then shift to match current price
            y1 = chartCurrent + (etfVal1 - etfCurrent) * rangeScaleFactor
            y2 = chartCurrent + (etfVal2 - etfCurrent) * rangeScaleFactor
            
            x1 = bar_index - j
            x2 = bar_index - (j + 1)
            
            ln = line.new(x1, y1, x2, y2, color=color1, width=2)
//             array.push(segmentLines, ln)
//     else
        // Match first & last points with range-based scaling
        firstETF = array.get(bestFit, 0)
        lastETF = array.get(bestFit, l - 1)
        
        firstChart = close[0]
        lastChart = close[l - 1]
        
        for j = 0 to l - 2
            etfVal1 = array.get(bestFit, j)
            etfVal2 = array.get(bestFit, j + 1)
            
            // First, scale to match ranges
            scaledVal1 = firstETF + (etfVal1 - firstETF) * rangeScaleFactor
            scaledVal2 = firstETF + (etfVal2 - firstETF) * rangeScaleFactor
            
            // Then, linearly interpolate to anchor both endpoints
            // Calculate position along the window (0 at j=0, 1 at j=l-1)
            t1 = float(j) / float(l - 1)
            t2 = float(j + 1) / float(l - 1)
            
            // Scaled first and last values
            scaledFirst = firstETF
            scaledLast = firstETF + (lastETF - firstETF) * rangeScaleFactor
            
            // Linear blend from chart endpoints
            y1 = firstChart + (scaledVal1 - scaledFirst) + t1 * ((lastChart - firstChart) - (scaledLast - scaledFirst))
            y2 = firstChart + (scaledVal2 - scaledFirst) + t2 * ((lastChart - firstChart) - (scaledLast - scaledFirst))
            
            x1 = bar_index - j
            x2 = bar_index - (j + 1)
            
            ln = line.new(x1, y1, x2, y2, color=color1, width=2)
//             array.push(segmentLines, ln)

//––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
// 4 · BEST-MATCH SUMMARY TABLE (single line at top right)
if not na(maxCorr) and not na(bestETF)
    corrPercent = maxCorr * 100.0

    // Color blending from orange to blue based on correlation
    blendRatioRaw = (corrPercent - 70.0) / 30.0
    blendRatio    = math.max(0.0, math.min(1.0, blendRatioRaw))

    r = math.round(255.0 * (1.0 - blendRatio) + 0.0   * blendRatio)
    g = math.round(120.0 * (1.0 - blendRatio) + 140.0 * blendRatio)
    b = math.round(0.0   * (1.0 - blendRatio) + 255.0 * blendRatio)

    bgColor   = color.rgb(r, g, b)
    tableText = "Best Match: " + bestETF + " (" + str.tostring(corrPercent, format.percent) + ")"

//     table.cell(corrTable, 0, 0, text=tableText, text_color=color.white, bgcolor=bgColor, text_size = size.small)
// else
//     table.cell(corrTable, 0, 0, text="No Ticker Match Found", text_color=color.white, bgcolor=color.gray, text_size = size.small)




    