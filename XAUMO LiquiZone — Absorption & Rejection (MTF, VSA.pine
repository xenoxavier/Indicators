// XAUMO LiquiZone â€” Absorption & Rejection (MTF, VSA)

// XAUMO LiquiZone â€” Absorption & Rejection (MTF, VSA)
// Free & open-source (MPL-2.0). Educational use only.

// WHAT IT DOES
// LiquiZone detects liquidity absorption & distribution zones using wick/volume anatomy and simple pivot structure, then plots them for both Higher Time Frame (HTF) and Lower Time Frame (LTF). An optional HTF Extension Engine projects selected historical HTF zones to the right (nearest or N zones above/below the current price) so you can track â€œinstitutional memoryâ€ into the live session.

// HOW IT WORKS (LOGIC)
// â€¢ Absorption rules (VSA-style): long wick on one side, volume > SMA(volume) Ã— multiplier, and a small/controlled body vs full range.
// â€¢ Structure: zones are anchored on local pivot highs/lows (left/right bars).
// â€¢ HTF vs LTF: HTF signals are computed via request.security() on the timeframe you choose; LTF uses the chart timeframe.
// â€¢ Extension Engine: choose Bullish / Bearish / Both, Nearest Only or By Up/Down Count, custom colors, with safe forward limits to respect Pineâ€™s x-distance constraints.

// RECOMMENDED SETUP (BEST FOR XAUUSD 15m TF)
// â€¢ Chart timeframe: 15m
// â€¢ HTF timeframe: 30m
// â€¢ Volume MA length: 20
// â€¢ Min wick % of range: 0.30
// â€¢ Volume over MA Ã—: 1.5
// â€¢ Pivot Left/Right: 2 / 2
// â€¢ Zone look-ahead bars: 500
// â€¢ HTF Extension: Enabled
// â€“ Extension length: 500 bars
// â€“ Selection mode: By Up/Down Count
// â€“ Zones Above (Up): 1
// â€“ Zones Below (Down): 2
// â€“ Extension color(s): purple tint (opacity ~80) for both bull/bear
// â€¢ Style: separate colors/opacity for HTF/LTF bull & bear zones (fully user-configurable)

// INPUTS (KEY SETTINGS)
// â€¢ HTF timeframe (default 30m), Volume MA length, Wick % threshold, Volume multiplier, Pivot L/R, Zone look-ahead bars (default 500).
// â€¢ Zone Style: independent colors & opacities for HTF/LTF bull & bear zones.
// â€¢ HTF Extension: enable toggle, extension length, side filter, selection mode, counts up/down, and custom colors for extended HTF zones.

// NOTES / BEST PRACTICE
// â€¢ Use HTF zones for context and LTF zones for execution.
// â€¢ Combine with volume profile (POC/VAL/VAH), VWAP, delta/tape tools for confirmation.
// â€¢ Uses pivots (confirmed after Pivot Right bars); this is a visualization/education tool, not a signal generator.

// LICENSE & DISCLAIMER
// â€¢ License: Mozilla Public License 2.0 (MPL-2.0).
// â€¢ Educational purpose only. No financial advice. You are fully responsible for your own trading decisions.

// FRAUD / SCAM WARNING
// â€¢ This script is free and open-source. No one is authorized to sell it, rent it, or ask you for money, DMs, or â€œaccount management.â€
// â€¢ If someone impersonates the author or offers paid access, treat it as fraud/scam and report via TradingView.

// CHANGELOG v1.0
// â€¢ Initial public release: HTF/LTF absorption zones + HTF Extension Engine + full styling controls.

// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© ICHIMOKUontheNILE

//@version=5
indicator("XAUMO LiquiZone â€” Absorption & Rejection (MTF, VSA)", "liquizone", overlay=true, max_labels_count=500, max_lines_count=500, max_boxes_count=200)

//========= CORE INPUTS =========
tfHTF     = input.timeframe("30", "HTF timeframe")
lenVolMA  = input.int(9, "Volume MA length", minval=5)
wickPct   = input.float(0.30, "Min wick % of full range", minval=0.05, maxval=0.90, step=0.01)
volMult   = input.float(1.5, "Volume over MA Ã—", minval=1.0, step=0.1)
pivotL    = input.int(2, "Pivot Left", minval=1)
pivotR    = input.int(2, "Pivot Right", minval=1)
zoneLook  = input.int(500, "Zone look-ahead bars", minval=50)
showHTF   = input.bool(true,  "Show HTF zones", inline="sh")
showLTF   = input.bool(false,  "Show LTF zones", inline="sh")

//========= XAUMO FVRP â€¢ ZONE STYLE =========
grpZoneStyle   = "ðŸŽ¨ XAUMO FVRP â€¢ Zone Style"
htfBullColor   = input.color(color.lime,   "HTF Bull BG",     group=grpZoneStyle)
htfBullOpacity = input.int(85, "HTF Bull Opacity", minval=0, maxval=100, group=grpZoneStyle)
htfBearColor   = input.color(color.red,    "HTF Bear BG",     group=grpZoneStyle)
htfBearOpacity = input.int(85, "HTF Bear Opacity", minval=0, maxval=100, group=grpZoneStyle)
ltfBullColor   = input.color(color.teal,   "LTF Bull BG",     group=grpZoneStyle)
ltfBullOpacity = input.int(82, "LTF Bull Opacity", minval=0, maxval=100, group=grpZoneStyle)
ltfBearColor   = input.color(color.orange, "LTF Bear BG",     group=grpZoneStyle)
ltfBearOpacity = input.int(82, "LTF Bear Opacity", minval=0, maxval=100, group=grpZoneStyle)

// Helper creators
// f_new_htf_bull_box(x1, y1, x2, y2) => box.new(x1, y1, x2, y2, bgcolor=color.new(htfBullColor, htfBullOpacity), border_color=color.new(htfBullColor, 0))
// f_new_htf_bear_box(x1, y1, x2, y2) => box.new(x1, y1, x2, y2, bgcolor=color.new(htfBearColor, htfBearOpacity), border_color=color.new(htfBearColor, 0))
// f_new_ltf_bull_box(x1, y1, x2, y2) => box.new(x1, y1, x2, y2, bgcolor=color.new(ltfBullColor, ltfBullOpacity), border_color=color.new(ltfBullColor, 0))
// f_new_ltf_bear_box(x1, y1, x2, y2) => box.new(x1, y1, x2, y2, bgcolor=color.new(ltfBearColor, ltfBearOpacity), border_color=color.new(ltfBearColor, 0))

//========= WICK/BODY HELPERS =========
// getWicks(o,h,l,c) =>
    upper    = h - math.max(o, c)
    lower    = math.min(o, c) - l
    body     = math.abs(c - o)
    barRange = h - l
    uPct     = barRange > 0 ? upper / barRange : 0.0
    lPct     = barRange > 0 ? lower / barRange : 0.0
    [uPct, lPct, body, barRange]

//========= HTF SERIES =========
oH = request.security(syminfo.tickerid, tfHTF, open)
hH = request.security(syminfo.tickerid, tfHTF, high)
lH = request.security(syminfo.tickerid, tfHTF, low)
cH = request.security(syminfo.tickerid, tfHTF, close)
vH = request.security(syminfo.tickerid, tfHTF, volume)

vHma = ta.sma(vH, lenVolMA)
vLma = ta.sma(volume, lenVolMA)

//========= ABSORPTION DETECTORS =========
// Bullish absorption: long lower wick + high volume + controlled body/close
// bullAbs(o_,h_,l_,c_,v_,vma_) =>
    [u, l, body, barRange] = getWicks(o_,h_,l_,c_)
    condWick  = l >= wickPct
    condVol   = v_ > vma_ * volMult
    condClose = c_ > o_ ? true : (body <= barRange * 0.25)
//     condWick and condVol and condClose

// Bearish absorption: long upper wick + high volume + controlled body/close
// bearAbs(o_,h_,l_,c_,v_,vma_) =>
    [u, l, body, barRange] = getWicks(o_,h_,l_,c_)
    condWick  = u >= wickPct
    condVol   = v_ > vma_ * volMult
    condClose = c_ < o_ ? true : (body <= barRange * 0.25)
//     condWick and condVol and condClose

//========= PIVOTS =========
isPivotHigh = ta.pivothigh(high, pivotL, pivotR)
isPivotLow  = ta.pivotlow(low,  pivotL, pivotR)

//========= BUILD ZONES =========
// HTF boxes
var box[] htfBull = array.new_box()
var box[] htfBear = array.new_box()

newBullHTF = showHTF and bullAbs(oH,hH,lH,cH,vH,vHma) and isPivotLow
newBearHTF = showHTF and bearAbs(oH,hH,lH,cH,vH,vHma) and isPivotHigh

if newBullHTF
    b = f_new_htf_bull_box(bar_index, hH, bar_index + zoneLook, lH)
//     array.push(htfBull, b)

if newBearHTF
    b = f_new_htf_bear_box(bar_index, hH, bar_index + zoneLook, lH)
//     array.push(htfBear, b)

// LTF boxes
var box[] ltfBull = array.new_box()
var box[] ltfBear = array.new_box()

newBullLTF = showLTF and bullAbs(open,high,low,close,volume,vLma) and isPivotLow
newBearLTF = showLTF and bearAbs(open,high,low,close,volume,vLma) and isPivotHigh

if newBullLTF
    b = f_new_ltf_bull_box(bar_index, ta.highest(high, pivotR + 1), bar_index + zoneLook/2, ta.lowest(low, pivotR + 1))
//     array.push(ltfBull, b)

if newBearLTF
    b = f_new_ltf_bear_box(bar_index, ta.highest(high, pivotR + 1), bar_index + zoneLook/2, ta.lowest(low, pivotR + 1))
//     array.push(ltfBear, b)

// Labels
plotshape(newBullHTF, title="HTF Bull Abs",  style=shape.triangleup,   color=color.lime,   size=size.tiny, location=location.belowbar, text="HTF Absâ†‘")
plotshape(newBearHTF, title="HTF Bear Abs",  style=shape.triangledown, color=color.red,    size=size.tiny, location=location.abovebar, text="HTF Absâ†“")
plotshape(newBullLTF, title="LTF Bull Abs",  style=shape.circle,       color=color.teal,   size=size.tiny, location=location.belowbar, text="Absâ†‘")
plotshape(newBearLTF, title="LTF Bear Abs",  style=shape.circle,       color=color.orange, size=size.tiny, location=location.abovebar, text="Absâ†“")

//================ HTF EXTENSION SECTION (SAFE) ================
groupExtHTF      = "HTF Zone Extension"
extHTF_enable    = input.bool(true,  "Extend HTF Zones to the Right", group=groupExtHTF)
extHTF_len       = input.int(500,    "Extension Bars to the Right",   minval=1, group=groupExtHTF)
extHTF_side      = input.string("Both", "Which HTF Zones?", options=["Bullish Only","Bearish Only","Both"], group=groupExtHTF)
extHTF_mode      = input.string("By Up/Down Count", "Selection Mode", options=["Nearest Only","By Up/Down Count"], group=groupExtHTF)
extHTF_upCnt     = input.int(1, "Zones Above Price (Up)",  minval=0, group=groupExtHTF)
extHTF_dnCnt     = input.int(2, "Zones Below Price (Down)", minval=0, group=groupExtHTF)
// Use purple-tinted color for both extensions (matches your screenshot vibe)
extHTF_bullCol   = input.color(color.new(color.purple, 80), "Bullish HTF Extension Color", group=groupExtHTF)
extHTF_bearCol   = input.color(color.new(color.purple, 80), "Bearish HTF Extension Color", group=groupExtHTF)

// Helper arrays
var float[] ext_zMid     = array.new_float()
var bool[]  ext_zIsBull  = array.new_bool()
var bool[]  ext_zIsAbove = array.new_bool()
var int[]   ext_zSrc     = array.new_int()   // 0 = htfBull, 1 = htfBear
var int[]   ext_zIdx     = array.new_int()
var bool[]  ext_zUsed    = array.new_bool()

// Pine x-distance safety
maxBarsDist = 5000
safeExt     = math.min(extHTF_len, maxBarsDist)

// extend_htf_zone(int idxJ) =>
//     bool  isBull = array.get(ext_zIsBull, idxJ)
//     int   src    = array.get(ext_zSrc, idxJ)
//     int   idxBox = array.get(ext_zIdx, idxJ)
//     box   b      = src == 0 ? array.get(htfBull, idxBox) : array.get(htfBear, idxBox)
//     color col    = isBull ? extHTF_bullCol : extHTF_bearCol
//     box.set_right(b, bar_index + safeExt)
//     box.set_bgcolor(b, col)
//     box.set_border_color(b, col)

// Reset HTF boxes (recent only)
// int bullCount = array.size(htfBull)
// int bearCount = array.size(htfBear)

if bullCount > 0
    for i = 0 to bullCount - 1
//         box b  = array.get(htfBull, i)
//         int lx = box.get_left(b)
        if bar_index - lx <= maxBarsDist
//             box.set_right(b, lx + zoneLook)
//             box.set_bgcolor(b, color.new(htfBullColor, htfBullOpacity))
//             box.set_border_color(b, color.new(htfBullColor, 0))

if bearCount > 0
    for i = 0 to bearCount - 1
//         box b  = array.get(htfBear, i)
//         int lx = box.get_left(b)
        if bar_index - lx <= maxBarsDist
//             box.set_right(b, lx + zoneLook)
//             box.set_bgcolor(b, color.new(htfBearColor, htfBearOpacity))
//             box.set_border_color(b, color.new(htfBearColor, 0))

// Selection logic
if extHTF_enable and showHTF and (bullCount + bearCount > 0)
//     array.clear(ext_zMid)
//     array.clear(ext_zIsBull)
//     array.clear(ext_zIsAbove)
//     array.clear(ext_zSrc)
//     array.clear(ext_zIdx)
//     array.clear(ext_zUsed)

//     bool useBull = extHTF_side == "Bullish Only" or extHTF_side == "Both"
//     bool useBear = extHTF_side == "Bearish Only" or extHTF_side == "Both"

    if useBull and bullCount > 0
        for i = 0 to bullCount - 1
//             box  b    = array.get(htfBull, i)
//             int  lx   = box.get_left(b)
            if bar_index - lx <= maxBarsDist
//                 float top = box.get_top(b)
//                 float bot = box.get_bottom(b)
//                 float mid = (top + bot) * 0.5
//                 array.push(ext_zMid, mid)
//                 array.push(ext_zIsBull, true)
//                 array.push(ext_zIsAbove, mid >= close)
//                 array.push(ext_zSrc, 0)
//                 array.push(ext_zIdx, i)
//                 array.push(ext_zUsed, false)

    if useBear and bearCount > 0
        for i = 0 to bearCount - 1
//             box  b    = array.get(htfBear, i)
//             int  lx   = box.get_left(b)
            if bar_index - lx <= maxBarsDist
//                 float top = box.get_top(b)
//                 float bot = box.get_bottom(b)
//                 float mid = (top + bot) * 0.5
//                 array.push(ext_zMid, mid)
//                 array.push(ext_zIsBull, false)
//                 array.push(ext_zIsAbove, mid >= close)
//                 array.push(ext_zSrc, 1)
//                 array.push(ext_zIdx, i)
//                 array.push(ext_zUsed, false)

//     int totalZones = array.size(ext_zMid)

    if totalZones > 0
        if extHTF_mode == "Nearest Only"
//             int   bestJ   = -1
//             float bestDst = na
            for j = 0 to totalZones - 1
//                 float mid = array.get(ext_zMid, j)
//                 float dst = math.abs(mid - close)
                if na(bestDst) or dst < bestDst
//                     bestDst := dst
//                     bestJ   := j
            if bestJ != -1
//                 extend_htf_zone(bestJ)
//         else
            // UP (above price)
            for n = 0 to extHTF_upCnt - 1
//                 int   bestJ   = -1
//                 float bestDst = na
                for j = 0 to totalZones - 1
//                     bool isAbv = array.get(ext_zIsAbove, j)
//                     bool used  = array.get(ext_zUsed, j)
                    if isAbv and not used
//                         float mid = array.get(ext_zMid, j)
//                         float dst = math.abs(mid - close)
                        if na(bestDst) or dst < bestDst
//                             bestDst := dst
//                             bestJ   := j
                if bestJ != -1
//                     array.set(ext_zUsed, bestJ, true)
//                     extend_htf_zone(bestJ)

            // DOWN (below price)
            for n = 0 to extHTF_dnCnt - 1
//                 int   bestJ   = -1
//                 float bestDst = na
                for j = 0 to totalZones - 1
//                     bool isAbv = array.get(ext_zIsAbove, j)
//                     bool used  = array.get(ext_zUsed, j)
                    if not isAbv and not used
//                         float mid = array.get(ext_zMid, j)
//                         float dst = math.abs(mid - close)
                        if na(bestDst) or dst < bestDst
//                             bestDst := dst
//                             bestJ   := j
                if bestJ != -1
//                     array.set(ext_zUsed, bestJ, true)
//                     extend_htf_zone(bestJ)
