// BE-Indicator Aggregator toolkit

// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © TradeWiseWithEase

//@version=6
indicator(title = "BE-Indicator Aggregator toolkit", shorttitle = "BE-IA-V0.0", overlay = true, max_labels_count = 500, max_lines_count = 500, max_bars_back = 5000)

//#region Functions & Methods
var int StorValues              = 99998
var int HistoryValues           = 10
// type bar
//     int B                       = bar_index
//     float C                     = close
//     float H                     = high
//     float L                     = low
// type tradeInfo
//     int EnBar
//     float EnPrice
//     float SL
//     float TP

// method arrayStorage(array<string> id, int StorageCapacity, string Value)=>
    if not id.includes(Value)
//         id.push(Value)
        if id.size() > StorageCapacity
//             id.shift()

// method arrayStorage(array<bool> id, int StorageCapacity, bool Value)=>
//     id.push(Value)
    if id.size() > StorageCapacity
//         id.shift()

// method arrayStorage(array<bar> id, int StorageCapacity, bar Value)=>
//     id.push(Value)
    if id.size() > StorageCapacity
//         id.shift()

// method arrayStorage(array<int> id, int StorageCapacity, int Value)=>
//     id.push(Value)
    if id.size() > StorageCapacity
//         id.shift()

// method arrayStorage(array<label> id, int StorageCapacity, label Value)=>
//     id.push(Value)
    if id.size() > StorageCapacity
//         id.shift()

// OperatorChk(float val2chk, string OperatorTxt, float CompareVal1, float CompareVal2 = 0) =>
//     bool isAboveWithE           = val2chk >=    math.min(CompareVal1,CompareVal2)    ? true : false
//     bool isBelowWithE           = val2chk <=    math.max(CompareVal1,CompareVal2)    ? true : false
//     bool isAboveWithOutE        = val2chk >     math.min(CompareVal1,CompareVal2)    ? true : false
//     bool isBelowWithOutE        = val2chk <     math.max(CompareVal1,CompareVal2)    ? true : false
    a = switch OperatorTxt
//         "E"                     => val2chk == CompareVal1                               ? true : false
//         "NE"                    => val2chk != CompareVal1                               ? true : false
//         "NEOR"                  => val2chk != CompareVal1 or val2chk != CompareVal2     ? true : false
//         "NEAND"                 => val2chk != CompareVal1 and val2chk != CompareVal2    ? true : false
//         "G"                     => val2chk > CompareVal1                                ? true : false
//         "GE"                    => val2chk >= CompareVal1                               ? true : false
//         "L"                     => val2chk < CompareVal1                                ? true : false
//         "LE"                    => val2chk <= CompareVal1                               ? true : false
//         "B"                     => isAboveWithOutE and isBelowWithOutE                  ? true : false
//         "BE"                    => isAboveWithE and isBelowWithE                        ? true : false
//         "OSE"                   => (val2chk < math.min(CompareVal1,CompareVal2)) or (val2chk > math.max(CompareVal1,CompareVal2))   ? true : false
//         "OSI"                   => (val2chk <= math.min(CompareVal1,CompareVal2)) or (val2chk >= math.max(CompareVal1,CompareVal2)) ? true : false
//         "ERR"                   => na(val2chk) ? true : false
//         "NERR"                  => na(val2chk) ? false : false
//         => false

var loopOnString                            = array.from("O", "H", "L", "C", "V", "ES1", "ES2", "ES3", "ES4", "ES5", "ES6", "ES7", "ES8", "ES9", "ES10", "ESD1", "ESD2", "ESD3", "ESD4", "ESD5", "ESD6", "ESD7", "ESD8", "ESD9", "ESD10")
// LoadSourceValues(string[] loopOnString, series float ES1, series float ES2, series float ES3, series float ES4, series float ES5, series float ES6, series float ES7, series float ES8, series float ES9, series float ES10)=>
    ValueArray                              = array.new_float(0)
    for i = HistoryValues to 0 by 1
        for [index, echString] in loopOnString
            Output = switch echString
//                 "O"                         => i == 0 ? open                    : open[i]
//                 "H"                         => i == 0 ? high                    : high[i]
//                 "L"                         => i == 0 ? low                     : low[i]
//                 "C"                         => i == 0 ? close                   : close[i]
//                 "V"                         => i == 0 ? volume                  : volume[i]
//                 "ES1"                       => i == 0 ? ES1                     : ES1[i]
//                 "ES2"                       => i == 0 ? ES2                     : ES2[i]
//                 "ES3"                       => i == 0 ? ES3                     : ES3[i]
//                 "ES4"                       => i == 0 ? ES4                     : ES4[i]
//                 "ES5"                       => i == 0 ? ES5                     : ES5[i]
//                 "ES6"                       => i == 0 ? ES6                     : ES6[i]
//                 "ES7"                       => i == 0 ? ES7                     : ES7[i]
//                 "ES8"                       => i == 0 ? ES8                     : ES8[i]
//                 "ES9"                       => i == 0 ? ES9                     : ES9[i]
//                 "ES10"                      => i == 0 ? ES10                    : ES10[i]
//                 "ESD1"                      => i == 0 ? close - ES1             : close[i] - ES1[i]
//                 "ESD2"                      => i == 0 ? close - ES2             : close[i] - ES2[i]
//                 "ESD3"                      => i == 0 ? close - ES3             : close[i] - ES3[i]
//                 "ESD4"                      => i == 0 ? close - ES4             : close[i] - ES4[i]
//                 "ESD5"                      => i == 0 ? close - ES5             : close[i] - ES5[i]
//                 "ESD6"                      => i == 0 ? close - ES6             : close[i] - ES6[i]
//                 "ESD7"                      => i == 0 ? close - ES7             : close[i] - ES7[i]
//                 "ESD8"                      => i == 0 ? close - ES8             : close[i] - ES8[i]
//                 "ESD9"                      => i == 0 ? close - ES9             : close[i] - ES9[i]
//                 "ESD10"                     => i == 0 ? close - ES10            : close[i] - ES10[i]
//             ValueArray.push(Output)
//     ValueArray

// fxCheckOutput(string Left, string Compare, string Right1, string Right2 = "0", string[] MthString, float[] LoadedValue, series float ES1, series float ES2, series float ES3, series float ES4)=>
//     bool Output                             = false
    LSrc_idxNo                              = MthString.indexof(Left)
    RSrc_idxNo                              = MthString.indexof(Right1)
    R2Src_idxNo                             = MthString.indexof(Right2)
    CO                                      = ta.crossover(Left == "ES1" ? ES1 : Left == "ES2" ? ES2 : Left == "ES3" ? ES3 : ES4, Right1 == "ES1" ? ES1 : Right1 == "ES2" ? ES2 : Right1 == "ES3" ? ES3 : ES4)
    CU                                      = ta.crossunder(Left == "ES1" ? ES1 : Left == "ES2" ? ES2 : Left == "ES3" ? ES3 : ES4, Right1 == "ES1" ? ES1 : Right1 == "ES2" ? ES2 : Right1 == "ES3" ? ES3 : ES4)
    if LSrc_idxNo                           == -1
//         Output                              := false
//     else
        if Compare                          == "CO"
//             Output                          := CO
//         else if Compare                     == "CU"
//             Output                          := CU
//         else
//             Output                          := OperatorChk(LoadedValue.get(LSrc_idxNo), Compare, RSrc_idxNo == -1 ? str.tonumber(Right1) : LoadedValue.get(RSrc_idxNo), R2Src_idxNo == -1 ? str.tonumber(Right2) : LoadedValue.get(R2Src_idxNo))

// fxCheckAndStore(array<string> id, array<string> Output)=>
    for [x, echLogic] in id
        if not str.contains(echLogic, "|")
//             Output.arrayStorage(150, echLogic)

var ExtractConditionList                    = array.new_string(0)
var MatchString                             = array.new_string(0)
// varip ExtValue                              = array.new_float(0)
// varip VariablesMatch                        = array.new_string(0)
// varip VariablesResult                       = array.new_bool(0)
// type conditions
//     int index
//     int Ref
//     string[] OR_Logics
//     string[] AND_Logics
//     string WasOrIs
//     int WasIsRef
//     string Logic
//     bool LongOrShort
//     bool Inverse
// varip conditionsArray                       = array.new<conditions>(0)
// varip VariablesArray                        = array.new<conditions>(0)

// fxChkConditions(conditions[] conditionsArray, conditions[] PairsArray, string[] MatchString, float[] ExtValue, series float ES1, series float ES2, series float ES3, series float ES4)=>
    loopcondition                           = array.from(true, false)
    Output                                  = array.from(false, false)
    result                                  = array.new_bool(0)
    if PairsArray.size() > 0
        for [index, pairConditionType] in PairsArray
            criteriaResult                  = array.new_bool(0)
            if pairConditionType.Ref <= 2
//                 criteriaResult.clear()
//                 int HowManyTrue             = 0
                for [x, val] in pairConditionType.OR_Logics
                    splitUpVal              = str.split(val, "|")
                    watsResult              = false
                    if not str.contains(val, "|")
                        getIndxString       = VariablesMatch.indexof(val)
//                         watsResult          := getIndxString == -1 ? false : VariablesResult.get(getIndxString) 
//                     else
//                         watsResult          := fxCheckOutput(splitUpVal.get(0), splitUpVal.get(1), splitUpVal.get(2), splitUpVal.size()== 4 ? splitUpVal.get(3) : "0", MatchString, ExtValue, ES1, ES2, ES3, ES4)
//                     criteriaResult.push(watsResult)
                    if watsResult
//                         HowManyTrue         += 1
                BeforeInverse               = pairConditionType.Ref == 1 ? criteriaResult.some(): HowManyTrue >= pairConditionType.WasIsRef ? true : false
//                 VariablesResult.set(index, pairConditionType.Inverse ? not BeforeInverse : BeforeInverse)
//                 HowManyTrue                 := 0
//             else if pairConditionType.Ref == 3
//                 criteriaResult.clear()
                for [x, val] in pairConditionType.AND_Logics
                    splitUpVal              = str.split(val, "|")
                    watsResult              = false
                    if not str.contains(val, "|")
                        getIndxString       = VariablesMatch.indexof(val)
//                         watsResult          := getIndxString == -1 ? false : VariablesResult.get(getIndxString) 
//                     else
//                         watsResult          := fxCheckOutput(splitUpVal.get(0), splitUpVal.get(1), splitUpVal.get(2), splitUpVal.size()== 4 ? splitUpVal.get(3) : "0", MatchString, ExtValue, ES1, ES2, ES3, ES4)
//                     criteriaResult.push(watsResult)
//                 VariablesResult.set(index, pairConditionType.Inverse ? not criteriaResult.every() : criteriaResult.every())
    if conditionsArray.size() > 0
        for [z, truefalse] in loopcondition
//             result.clear()
            for [index, echCondType] in conditionsArray
                if echCondType.LongOrShort == truefalse
                    criteriaResult                  = array.new_bool(0)
                    if echCondType.Ref <= 2
//                         criteriaResult.clear()
//                         int HowManyTrue             = 0
                        for [x, val] in echCondType.OR_Logics
                            splitUpVal              = str.split(val, "|")
                            watsResult              = false
                            if not str.contains(val, "|")
                                getIndxString       = VariablesMatch.indexof(val)
//                                 watsResult          := getIndxString == -1 ? false : VariablesResult.get(getIndxString) 
//                             else
//                                 watsResult          := fxCheckOutput(splitUpVal.get(0), splitUpVal.get(1), splitUpVal.get(2), splitUpVal.size()== 4 ? splitUpVal.get(3) : "0", MatchString, ExtValue, ES1, ES2, ES3, ES4)
//                             criteriaResult.push(watsResult)
                            if watsResult
//                                 HowManyTrue         += 1
                        BeforeInverse               = echCondType.Ref == 1 ? criteriaResult.some(): HowManyTrue >= echCondType.WasIsRef ? true : false
//                         result.push(echCondType.Inverse ? not BeforeInverse : BeforeInverse)
//                         HowManyTrue                 := 0
//                     else if echCondType.Ref == 3
//                         criteriaResult.clear()
                        for [x, val] in echCondType.AND_Logics
                            splitUpVal              = str.split(val, "|")
                            watsResult              = false
                            if not str.contains(val, "|")
                                getIndxString       = VariablesMatch.indexof(val)
//                                 watsResult          := getIndxString == -1 ? false : VariablesResult.get(getIndxString) 
//                             else
//                                 watsResult          := fxCheckOutput(splitUpVal.get(0), splitUpVal.get(1), splitUpVal.get(2), splitUpVal.size()== 4 ? splitUpVal.get(3) : "0", MatchString, ExtValue, ES1, ES2, ES3, ES4)
//                             criteriaResult.push(watsResult)
//                         result.push(echCondType.Inverse ? not criteriaResult.every() : criteriaResult.every())
//                     else if echCondType.Ref <= 5
                        splitUpVal                  = str.split(echCondType.Logic, "|")
                        watsResult                  = fxCheckOutput(splitUpVal.get(0), splitUpVal.get(1), splitUpVal.get(2), splitUpVal.size()== 4 ? splitUpVal.get(3) : "0", MatchString, ExtValue, ES1, ES2, ES3, ES4)
                        if echCondType.WasOrIs == "WAS"
                            barIdxs                 = nz(ta.valuewhen(watsResult, bar_index, 0), 0)
//                             result.push(bar_index - barIdxs <= echCondType.WasIsRef ? true : false)
//                         else if echCondType.WasOrIs == "IS"
                            barIdxs                 = nz(ta.barssince(not watsResult), 0)
//                             result.push(barIdxs >= echCondType.WasIsRef ? true : false)
//                     else if echCondType.Ref == 6
                        splitUpVal                  = str.split(echCondType.Logic, "|")
                        watsResult                  = false
                        if not str.contains(echCondType.Logic, "|")
                            getIndxString           = VariablesMatch.indexof(echCondType.Logic)
//                             watsResult              := getIndxString == -1 ? false : VariablesResult.get(getIndxString) 
//                         else
//                             watsResult              := fxCheckOutput(splitUpVal.get(0), splitUpVal.get(1), splitUpVal.get(2), splitUpVal.size()== 4 ? splitUpVal.get(3) : "0", MatchString, ExtValue, ES1, ES2, ES3, ES4)
//                         result.push(echCondType.Inverse ? not watsResult : watsResult)
//             Output.set(z, result.every())
//     Output

// SetSLTP(SL_Src, SL_IP, TP_Src, TP_IP, Dir)=>
//     float SL_Value                          = na
//     float TP_Value                          = na
//     SL_Value                                := switch SL_Src
//         1   => Dir == -1 ? math.round_to_mintick(close + (close * (SL_IP / 100))) : math.round_to_mintick(close - (close * (SL_IP / 100)))
//         2   => Dir == -1 ? math.round_to_mintick(close + SL_IP) : math.round_to_mintick(close - SL_IP)

//     TP_Value                                := switch TP_Src
//         1   => Dir == -1 ? math.round_to_mintick(close - (close * (TP_IP / 100))) : math.round_to_mintick(close + (close * (TP_IP / 100)))
//         2   => Dir == -1 ? math.round_to_mintick(close - TP_IP) : math.round_to_mintick(close + TP_IP)
//         3   => Dir == -1 ? math.round_to_mintick(close - (math.abs(SL_Value - close) * TP_IP)) : math.round_to_mintick(close + (math.abs(SL_Value - close) * TP_IP))
    [SL_Value, TP_Value]
//#endregion

//#region Inputs & Variables
var string  Grp0                            = "External Conditions | Cross Over & Under Logic Enabled"
var string  Grp1                            = "External Conditions | Other Indicators"
var string  Grp2                            = "Stop Loss Settings"
var string  Grp3                            = "Target Settings."
var string  Grp4                            = "Display Settings."
var label   OutputLabel                     = label.new(1, 1, yloc = yloc.price, color = color.blue, style = label.style_label_left, size = size.normal, text = "", textcolor = color.white)
var string  labelString                     = ""
// float ExSrc1                                = input.source(
 defval                                     = hlcc4,
 group                                      = Grp0,
 inline                                     = "Sr1", 
 title                                      = "Source 1")

// float ExSrc2                                = input.source(
 defval                                     = hlcc4,
 group                                      = Grp0,
 inline                                     = "Sr2", 
 title                                      = "Source 2")

// float ExSrc3                                = input.source(
 defval                                     = hlcc4,
 group                                      = Grp0,
 inline                                     = "Sr3", 
 title                                      = "Source 3")

// float ExSrc4                                = input.source(
 defval                                     = hlcc4,
 group                                      = Grp0,
 inline                                     = "Sr4", 
 title                                      = "Source 4")

// float ExSrc5                                = input.source(
 defval                                     = hlcc4,
 group                                      = Grp1,
 inline                                     = "Sr5", 
 title                                      = "Source 5")

// float ExSrc6                                = input.source(
 defval                                     = hlcc4,
 group                                      = Grp1,
 inline                                     = "ExSrc6", 
 title                                      = "Source 6")

// float ExSrc7                                = input.source(
 defval                                     = hlcc4,
 group                                      = Grp1,
 inline                                     = "Sr7", 
 title                                      = "Source 7")

// float ExSrc8                                = input.source(
 defval                                     = hlcc4,
 group                                      = Grp1,
 inline                                     = "Sr8", 
 title                                      = "Source 8")

// float ExSrc9                                = input.source(
 defval                                     = hlcc4,
 group                                      = Grp1,
 inline                                     = "Sr9", 
 title                                      = "Source 9")

// float ExSrc10                               = input.source(
 defval                                     = hlcc4,
 group                                      = Grp1,
 inline                                     = "Sr10", 
 title                                      = "Source 10")

var string ConditionsInput                  = input.text_area(
 defval                                     = "", 
 group                                      = Grp1,   
 tooltip                                    = "List Out All Conditions for External Sources with | delimited", 
 title                                      = "Condition Builder")

var bool Debug                              = input.bool(
 defval                                     = true,
 group                                      = Grp4,
 inline                                     = "Sr", 
 title                                      = "Plot Output on Candles ?")

var bool ShowTPLbl                          = input.bool(
 defval                                     = false,
 group                                      = Grp4,
 inline                                     = "Sr", 
 title                                      = "Show TGT Achieved Entry Lables ?")

var string  SL_Source_                      = input.string(
 defval                                     = "Abs +/- From Entry",
 title                                      = "SL Source",
 group                                      = Grp2,
 inline                                     = "SLR",
 options                                    = ["% +/- From Entry", "Abs +/- From Entry"])

var int     SL_Source                       = switch SL_Source_
//     "% +/- From Entry"                      => 1
//     "Abs +/- From Entry"                    => 2
//     => 0

var float   SL_Input                        = input.float(
 defval                                     = 1,
 title                                      = "",
 group                                      = Grp2,
 minval                                     = 0.005,
 step                                       = 0.5,
 inline                                     = "SLR")

var string  TP_Source_                      = input.string(
 defval                                     = "RR Ratio",
 title                                      = "TP Source",
 group                                      = Grp3,
 inline                                     = "TPR",
 options                                    = ["% +/- From Entry", "Abs +/- From Entry", "RR Ratio"])

var int     TP_Source                       = switch TP_Source_
//     "% +/- From Entry"                      => 1
//     "Abs +/- From Entry"                    => 2
//     "RR Ratio"                              => 3
//     => 0

var float   TP_Input                        = input.float(
 defval                                     = 2,
 title                                      = "",
 group                                      = Grp3,
 minval                                     = 0.005,
 step                                       = 0.5,
 inline                                     = "TPR")
//#endregion

//#region Inialize
if barstate.isfirst
    CleaningVars                                    = array.new_string(0)
    for i = HistoryValues to 0 by 1
        for [index, echString] in loopOnString
//             string StringConstructor                = echString + (i == 0 ? "" : "[" + str.tostring(i) + "]")
//             MatchString.push(StringConstructor)
    if str.length(ConditionsInput) > 0
//         ExtractConditionList                        := str.split(str.upper(ConditionsInput),"\n")
        toRemoveArray                               = array.new_int(0)
        for [index, value] in ExtractConditionList
            if str.length(value) <= 3 or str.startswith(value, "'")
//                 toRemoveArray.push(index)
        if toRemoveArray.size() > 0
            for i = toRemoveArray.size() - 1 to 0 by 1  
//                 ExtractConditionList.remove(toRemoveArray.get(i))
    if ExtractConditionList.size() > 0 and conditionsArray.size() == 0
        for [ConditionIndex, echCondition] in ExtractConditionList
//             bool isLong                             = false
//             string echCondition_                    = ""
//             bool isA_Variable                       = false
            if str.startswith(echCondition, "L-")
//                 isLong                              := true
//                 echCondition_                       := str.trim(str.replace_all(echCondition, "L-", ""))
//             else if str.startswith(echCondition, "S-")
//                 echCondition_                       := str.trim(str.replace_all(echCondition, "S-", ""))
//             else if str.startswith(echCondition, "VAR-")
//                 echCondition_                       := str.trim(str.replace_all(echCondition, "VAR-", ""))
//                 isA_Variable                        := true
            string2load                             = str.split(echCondition_,":")
            if not isA_Variable
                if str.startswith(echCondition_, "OR") or str.startswith(echCondition_, "NOR")
                    Logics2Load                     = str.split(str.trim(string2load.last()), ", ")
                    createType                      = conditions.new(ConditionIndex, 1, OR_Logics = Logics2Load, LongOrShort = isLong, Inverse = str.startswith(echCondition_, "N"))
//                     conditionsArray.push(createType)
//                     fxCheckAndStore(Logics2Load, CleaningVars)
//                 else if str.startswith(echCondition_, "ATLEAST") or str.startswith(echCondition_, "NATLEAST")
                    Logics2Load                     = str.split(str.trim(string2load.last()), ", ")
                    createType                      = conditions.new(ConditionIndex, 2, WasIsRef = int(str.tonumber(string2load.get(1))), OR_Logics = Logics2Load, LongOrShort = isLong, Inverse = str.startswith(echCondition_, "N"))
//                     conditionsArray.push(createType)
//                     fxCheckAndStore(Logics2Load, CleaningVars)
//                 else if str.startswith(echCondition_, "AND") or str.startswith(echCondition_, "NAND")
                    Logics2Load                     = str.split(str.trim(string2load.last()), ", ")
                    createType                      = conditions.new(ConditionIndex, 3, AND_Logics = Logics2Load, LongOrShort = isLong, Inverse = str.startswith(echCondition_, "N"))
//                     conditionsArray.push(createType)
//                     fxCheckAndStore(Logics2Load, CleaningVars)
//                 else if str.startswith(echCondition_, "WASTRUE")
                    createType                      = conditions.new(ConditionIndex, 4, WasOrIs = "WAS", WasIsRef = int(str.tonumber(string2load.get(1))), Logic = str.trim(string2load.last()), LongOrShort = isLong)
//                     conditionsArray.push(createType)
//                 else if str.startswith(echCondition_, "ISTRUE")
                    createType                      = conditions.new(ConditionIndex, 5, WasOrIs = "IS", WasIsRef = int(str.tonumber(string2load.get(1))), Logic = str.trim(string2load.last()), LongOrShort = isLong)
//                     conditionsArray.push(createType)
//                 else if not str.contains(echCondition_, ":")
                    createType                      = conditions.new(ConditionIndex, 6, Logic = echCondition_, LongOrShort = isLong)
//                     conditionsArray.push(createType)
                    if not str.contains(echCondition_, "|")
//                         CleaningVars.arrayStorage(150, echCondition_)
//             else if isA_Variable
                if str.startswith(string2load.get(1), "OR") or str.startswith(string2load.get(1), "NOR")
                    createType                      = conditions.new(ConditionIndex, 1, OR_Logics = str.split(str.trim(string2load.last()), ", "), WasOrIs = string2load.first(), Inverse = str.startswith(string2load.get(1), "N"))
//                     VariablesArray.push(createType)
//                     VariablesMatch.push(createType.WasOrIs)
//                     VariablesResult.push(false)
//                 else if str.startswith(string2load.get(1), "ATLEAST") or str.startswith(string2load.get(1), "NATLEAST")
                    createType                      = conditions.new(ConditionIndex, 2, WasIsRef = int(str.tonumber(string2load.get(2))), OR_Logics = str.split(str.trim(string2load.last()), ", "), WasOrIs = string2load.first(), Inverse = str.startswith(string2load.get(1), "N"))
//                     VariablesArray.push(createType)
//                     VariablesMatch.push(createType.WasOrIs)
//                     VariablesResult.push(false)
//                 else if str.startswith(string2load.get(1), "AND") or str.startswith(string2load.get(1), "NAND")
                    createType                      = conditions.new(ConditionIndex, 3, AND_Logics = str.split(str.trim(string2load.last()), ", "), WasOrIs = string2load.first(), Inverse = str.startswith(string2load.get(1), "N"))
//                     VariablesArray.push(createType)
//                     VariablesMatch.push(createType.WasOrIs)
//                     VariablesResult.push(false)
        toRemoveUnUsed                              = array.new_int(0)
        for [index, value] in VariablesMatch
            if not CleaningVars.includes(value)
//                 toRemoveUnUsed.push(index)
        if toRemoveUnUsed.size() > 0
            for i = toRemoveUnUsed.size() - 1 to 0 by 1  
//                 VariablesArray.remove(toRemoveUnUsed.get(i))
//                 VariablesMatch.remove(toRemoveUnUsed.get(i))
//                 VariablesResult.remove(toRemoveUnUsed.get(i))
//     log.info("\nLoaded MatchString: {0}\nNo of Conditions: {1}\nNo of Variables Declared: {2} | M:{3} | R:{4}\nLisOfVariables:\n\n{5}", 
//      MatchString.size(), conditionsArray.size(), VariablesArray.size(), VariablesMatch.size(), VariablesResult.size(),
//      VariablesMatch.join("\n"))
//#endregion

//#region Setting up Calculations
var LongShortOutput                                 = array.from(false, false)
// varip LongArray                                     = array.new_bool(0)
// varip ShortArray                                    = array.new_bool(0)
// varip LongIgnoredSignal                             = array.new_int(0)
// varip ShortIgnoredSignal                            = array.new_int(0)
// varip BarsInfo                                      = array.new_int(0)
// varip CandleInfo                                    = array.new<bar>(0)
// varip LongEntries                                   = array.new<tradeInfo>(0)
// varip ShortEntries                                  = array.new<tradeInfo>(0)
// varip HasHitLongTGT                                 = array.new<tradeInfo>(0)
// varip HasHitShortTGT                                = array.new<tradeInfo>(0)
// varip HasHitLongSL                                  = array.new<tradeInfo>(0)
// varip HasHitShortSL                                 = array.new<tradeInfo>(0)
var Tradelabels                                     = array.new_label(0)
// bool longConditionMet                               = false
// bool longEntryConditionMet                          = false
// bool shortConditionMet                              = false
// bool shortEntryConditionMet                         = false
if barstate.isconfirmed
//     CandleInfo.arrayStorage(StorValues, bar.new())
//     BarsInfo.arrayStorage(StorValues, bar_index)    
//     ExtValue                                        := LoadSourceValues(loopOnString, ExSrc1, ExSrc2, ExSrc3, ExSrc4, ExSrc5, ExSrc6, ExSrc7, ExSrc8, ExSrc9, ExSrc10)
//     LongShortOutput                                 := fxChkConditions(conditionsArray, VariablesArray, MatchString, ExtValue, ExSrc1, ExSrc2, ExSrc3, ExSrc4)
    if LongShortOutput.first()
//         longConditionMet                            := true
//         LongArray.arrayStorage(StorValues, LongShortOutput.first())
        if LongEntries.size() == 0 or not LongIgnoredSignal.includes(bar_index)
            [SL, TP]                                = SetSLTP(SL_Source, SL_Input, TP_Source, TP_Input, 1)
//             LongEntries.push(tradeInfo.new(bar_index, close, SL, TP))
//             LongIgnoredSignal.arrayStorage(50, bar_index + 1)
//             longEntryConditionMet                   := true
//         else if LongIgnoredSignal.includes(bar_index)
//             LongIgnoredSignal.arrayStorage(50, bar_index + 1)
    if LongShortOutput.last()
//         shortConditionMet                           := true
//         ShortArray.arrayStorage(StorValues, LongShortOutput.last())
        if ShortEntries.size() == 0 or not ShortIgnoredSignal.includes(bar_index)
            [SL, TP]                                = SetSLTP(SL_Source, SL_Input, TP_Source, TP_Input, -1)
//             ShortEntries.push(tradeInfo.new(bar_index, close, SL, TP))
//             ShortIgnoredSignal.arrayStorage(50, bar_index + 1)
//             shortEntryConditionMet                  := true
//         else if ShortIgnoredSignal.includes(bar_index)
//             ShortIgnoredSignal.arrayStorage(50, bar_index + 1)
    MinEntryBars                                    = math.min(
//      LongEntries.size() == 0 and ShortEntries.size() == 0 ? 0 : StorValues,
//      LongEntries.size() == 0 ? StorValues : LongEntries.first().EnBar, 
//      ShortEntries.size() == 0 ? StorValues : ShortEntries.first().EnBar)
    if MinEntryBars > 0
        CompletedEntries                            = array.new_int(0)
        for [x, LongTrade] in LongEntries
            getIdx2Start                            = math.max(0, BarsInfo.indexof(LongTrade.EnBar))
            for i = getIdx2Start to CandleInfo.size() - 1 by 1
                Candle                              = CandleInfo.get(i)
                if (Candle.L <= LongTrade.SL or Candle.H >= LongTrade.TP) and Candle.B > LongTrade.EnBar
                    if Candle.H >= LongTrade.TP
//                         HasHitLongTGT.push(LongTrade)
                        if ShowTPLbl
//                             Tradelabels.arrayStorage(498, label.new(LongTrade.EnBar, LongTrade.EnPrice, yloc = yloc.belowbar, color = color.green, style = label.style_label_up, size = size.tiny, text = "TGT", textcolor = color.white))
//                     else
//                         HasHitLongSL.push(LongTrade)
//                         Tradelabels.arrayStorage(498, label.new(LongTrade.EnBar, LongTrade.EnPrice, yloc = yloc.belowbar, color = color.red, style = label.style_label_up, size = size.tiny, text = "SL", textcolor = color.white))
//                     CompletedEntries.push(x)
//                     break
//             continue
        if CompletedEntries.size() > 0
            for i = CompletedEntries.size() - 1 to 0 by 1  
//                 LongEntries.remove(CompletedEntries.get(i))
//         CompletedEntries.clear()
        for [x, ShortTrade] in ShortEntries
            getIdx2Start                            = math.max(0, BarsInfo.indexof(ShortTrade.EnBar))
            for i = getIdx2Start to CandleInfo.size() - 1 by 1
                Candle                              = CandleInfo.get(i)
                if (Candle.H >= ShortTrade.SL or Candle.L <= ShortTrade.TP) and Candle.B > ShortTrade.EnBar
                    if Candle.L <= ShortTrade.TP
//                         HasHitShortTGT.push(ShortTrade)
                        if ShowTPLbl
//                             Tradelabels.arrayStorage(498, label.new(ShortTrade.EnBar, ShortTrade.EnPrice, yloc = yloc.abovebar, color = color.green, style = label.style_label_down, size = size.tiny, text = "TGT", textcolor = color.white))
//                     else
//                         HasHitShortSL.push(ShortTrade)
//                         Tradelabels.arrayStorage(498, label.new(ShortTrade.EnBar, ShortTrade.EnPrice, yloc = yloc.abovebar, color = color.red, style = label.style_label_down, size = size.tiny, text = "SL", textcolor = color.white))
//                     CompletedEntries.push(x)
//                     break
//             continue
        if CompletedEntries.size() > 0
            for i = CompletedEntries.size() - 1 to 0 by 1  
//                 ShortEntries.remove(CompletedEntries.get(i))
//         CompletedEntries.clear()

if barstate.isrealtime and str.length(labelString) > 0
//     label.set_text(OutputLabel, labelString)
//     label.set_xy(OutputLabel, bar_index + 1, close)

if barstate.islastconfirmedhistory and (LongArray.size() > 0 or ShortArray.size() > 0)
    LongSetups                                      = HasHitLongTGT.size() + HasHitLongSL.size() + LongEntries.size()
    ShortSetups                                     = HasHitShortTGT.size() + HasHitShortSL.size() + ShortEntries.size()
//     labelString                                     := str.format("Long Sig: {0} | Long Setups: {1} | TGT %: {2,number,percent}\nShort Sig: {3} | Short Setups: {4} | TGT %: {5,number,percent}",
//      LongArray.size(),
//      LongSetups,
//      nz(HasHitLongTGT.size() / LongSetups, 0),
//      ShortArray.size(),
//      ShortSetups,
//      nz(HasHitShortTGT.size() / ShortSetups, 0))

plotshape(not Debug ? false : LongShortOutput.first(), title = "Long External Condition", style = shape.triangleup, location = location.belowbar, display = display.all - display.status_line, size = size.tiny, color= color.blue)
plotshape(not Debug  ? false : LongShortOutput.last(), title = "Short External Condition", style = shape.triangledown, location = location.abovebar, display = display.all - display.status_line, size = size.tiny, color= color.fuchsia)
plot(bar_index)
plot(ExSrc1, title = "Ext1", color = color.aqua, display = display.status_line)
plot(ExSrc2, title = "Ext2",  color = color.aqua, display = display.status_line)
plot(ExSrc3, title = "Ext3",  color = color.aqua, display = display.status_line)
plot(ExSrc4, title = "Ext4",  color = color.aqua, display = display.status_line)
plot(ExSrc5, title = "Ext5",  color = color.aqua, display = display.status_line)
plot(ExSrc6, title = "Ext6",  color = color.aqua, display = display.status_line)
plot(ExSrc7, title = "Ext7",  color = color.aqua, display = display.status_line)
plot(ExSrc8, title = "Ext8",  color = color.aqua, display = display.status_line)
plot(ExSrc9, title = "Ext9",  color = color.aqua, display = display.status_line)
plot(ExSrc10, title = "Ext10",  color = color.aqua, display = display.status_line)
// alertcondition(longEntryConditionMet, "Lont EntryCondition", "Long Trade Entry")
// alertcondition(longConditionMet, "Long Condition", "Long condition met")
// alertcondition(shortEntryConditionMet, "Short EntryCondition", "Short Trade Entry")
// alertcondition(shortConditionMet, "Short Condition", "Short condition met")
//#endregion
