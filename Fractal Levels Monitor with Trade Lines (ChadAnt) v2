Fractal Levels Monitor w/ Trade Lines (ChadAnt) v2

//@version=5
indicator("Fractal Breaks with FVG Entry Filter (ChadAnt)", overlay=true, max_lines_count = 500, max_boxes_count = 500)

// === Original Inputs ===
fractalPeriod = input.int(2, "Fractal Period", minval=1, maxval=10)
bullishColor = input.color(color.rgb(216, 67, 67), "Bullish Fractal Line Color")
bearishColor = input.color(color.rgb(78, 187, 68), "Bearish Fractal Line Color")
lineWidth = input.int(1, "Line Width", minval=1, maxval=4)
showMarkers = input.bool(true, "Show Fractal Markers")

// Candle color settings
crossBullishBody = input.color(color.new(#b9bdbb, 0), "Cross Bullish Level - Body Color")
crossBullishBorder = input.color(color.new(#b9bdbb, 0), "Cross Bullish Level - Border Color")
crossBullishWick = input.color(color.new(#b9bdbb, 0), "Cross Bullish Level - Wick Color")
crossBearishBody = input.color(color.new(#ffffff, 0), "Cross Bearish Level - Body Color")
crossBearishBorder = input.color(color.new(#ffffff, 0), "Cross Bearish Level - Border Color")
crossBearishWick = input.color(color.new(#ffffff, 0), "Cross Bearish Level - Wick Color")

// === Time Filter Inputs ===
grpTime = "Time Filter Settings"
useTimeFilter = input.bool(false, "Enable Time Filter", group=grpTime)
tradeSession = input.session("0930-1600", "Trading Session (e.g. 0930-1600)", group=grpTime)
showSessionBg = input.bool(false, "Highlight Session Background", group=grpTime)
sessionBgColor = input.color(color.new(color.blue, 90), "Session Background Color", group=grpTime)

// === FVG Filter Inputs (MODIFIED) ===
grpFVG = "FVG Filter Settings"
filterFVG = input.bool(true, "Filter Signals Entering FVGs", tooltip="Prevents Buys into Bearish FVGs and Sells into Bullish FVGs", group=grpFVG)
showFVG = input.bool(true, "Show FVG Boxes", group=grpFVG)
bullFVGColor = input.color(color.new(color.green, 85), "Bullish FVG Color", group=grpFVG)
bearFVGColor = input.color(color.new(color.red, 85), "Bearish FVG Color", group=grpFVG)
mitigateType = input.string("Wick", "FVG Mitigation Type", options=["Wick", "Close"], tooltip="How price must interact with FVG to remove it", group=grpFVG)
// NEW INPUT FOR DURATION
fvgFilterDuration = input.int(5, "FVG Filter Duration (Bars)", minval=1, maxval=50, group=grpFVG)


// === Trade Line Inputs ===
grp1 = "Trade Line Settings"
maxTradesToShow = input.int(5, "Max Active Trades to Show", minval=1, maxval=50, group=grp1)
rr1 = input.float(1.0, "Take Profit 1 R:R", minval=0.1, group=grp1)
showTP2 = input.bool(true, "Show Take Profit 2", group=grp1)
rr2 = input.float(2.0, "Take Profit 2 R:R", minval=0.1, group=grp1)
showTP3 = input.bool(true, "Show Take Profit 3", group=grp1)
rr3 = input.float(3.0, "Take Profit 3 R:R", minval=0.1, group=grp1)

grp2 = "Trade Line Colors"
entryColor = input.color(color.new(color.blue, 0), "Entry Line", group=grp2)
slColor = input.color(color.new(color.red, 0), "Stop Loss Line", group=grp2)
tp1Color = input.color(color.new(color.green, 0), "TP1 Line", group=grp2)
tp2Color = input.color(color.new(color.green, 40), "TP2 Line", group=grp2)
tp3Color = input.color(color.new(color.green, 60), "TP3 Line", group=grp2)

// === Fractal detection ===
isBullishFractal(period) =>
    bool result = true
    for i = 1 to period
        if low[period] >= low[period + i] or low[period] >= low[period - i]
            result := false
            break
    result

isBearishFractal(period) =>
    bool result = true
    for i = 1 to period
        if high[period] <= high[period + i] or high[period] <= high[period - i]
            result := false
            break
    result

// Detect fractals
bullFractal = isBullishFractal(fractalPeriod)
bearFractal = isBearishFractal(fractalPeriod)

// Track the last fractal levels
var float lastBullishLevel = na
var float lastBearishLevel = na
var bool bullishLevelCrossed = false
var bool bearishLevelCrossed = false

// Variables to track the cross candle and alert state
var float crossCandleHigh = na
var float crossCandleLow = na
var bool buyAlertTriggered = false
var bool sellAlertTriggered = false

// === Arrays to manage trade lines (UNCHANGED) ===
var tradeDirections = array.new_int(0)
var tradeSLPrices = array.new_float(0)
var tradeTP1Prices = array.new_float(0)
var tradeStatus = array.new_int(0)

var entryLines = array.new_line(0)
var slLines = array.new_line(0)
var tp1Lines = array.new_line(0)
var tp2Lines = array.new_line(0)
var tp3Lines = array.new_line(0)

// === FVG Logic & Arrays (MODIFIED) ===
var bull_fvg_top = array.new_float(0)
var bull_fvg_btm = array.new_float(0)
var bull_fvg_box = array.new_box(0)
var bull_fvg_idx = array.new_int(0) // NEW: Stores creation bar index

var bear_fvg_top = array.new_float(0)
var bear_fvg_btm = array.new_float(0)
var bear_fvg_box = array.new_box(0)
var bear_fvg_idx = array.new_int(0) // NEW: Stores creation bar index


// 2. Manage/Clean FVGs (Duration & Mitigation Check)
clean_bull_fvgs() =>
    if array.size(bull_fvg_top) > 0
        for i = array.size(bull_fvg_top) - 1 to 0
            float top = array.get(bull_fvg_top, i)
            float btm = array.get(bull_fvg_btm, i)
            int idx = array.get(bull_fvg_idx, i)
            
            // Check Mitigation OR Duration Expiration
            bool mitigated = mitigateType == "Close" ? close < btm : low < btm
            bool expired = bar_index - idx > fvgFilterDuration
            
            if mitigated or expired // Remove if filled or expired
                box.delete(array.get(bull_fvg_box, i))
                array.remove(bull_fvg_top, i)
                array.remove(bull_fvg_btm, i)
                array.remove(bull_fvg_box, i)
                array.remove(bull_fvg_idx, i)
                box(na) // <--- FIX: Explicitly return 'series box' here
            else
                box.set_right(array.get(bull_fvg_box, i), bar_index + 5)
                box(na) // This side already returns 'series box'

clean_bear_fvgs() =>
    if array.size(bear_fvg_top) > 0
        for i = array.size(bear_fvg_top) - 1 to 0
            float top = array.get(bear_fvg_top, i)
            float btm = array.get(bear_fvg_btm, i)
            int idx = array.get(bear_fvg_idx, i)
            
            // Check Mitigation OR Duration Expiration
            bool mitigated = mitigateType == "Close" ? close > top : high > top
            bool expired = bar_index - idx > fvgFilterDuration
            
            if mitigated or expired // Remove if filled or expired
                box.delete(array.get(bear_fvg_box, i))
                array.remove(bear_fvg_top, i)
                array.remove(bear_fvg_btm, i)
                array.remove(bear_fvg_box, i)
                array.remove(bear_fvg_idx, i)
                box(na) // <--- FIX: Explicitly return 'series box' here
            else
                box.set_right(array.get(bear_fvg_box, i), bar_index + 5)
                box(na) // This side already returns 'series box'

clean_bull_fvgs()
clean_bear_fvgs()

// === TIME FILTER CALCULATION ===
bool inSession = not useTimeFilter or not na(time(timeframe.period, tradeSession))
bgcolor(useTimeFilter and showSessionBg and inSession ? sessionBgColor : na, title="Session Background")

// === FRACTAL LOGIC ===
if bullFractal
    lastBullishLevel := low[fractalPeriod]
    bullishLevelCrossed := false

if bearFractal
    lastBearishLevel := high[fractalPeriod]
    bearishLevelCrossed := false

plot(lastBullishLevel, "Bullish Fractal Level", color=bullishColor, linewidth=lineWidth, style=plot.style_line)
plot(lastBearishLevel, "Bearish Fractal Level", color=bearishColor, linewidth=lineWidth, style=plot.style_line)

plotshape(showMarkers and bullFractal, "Bullish Fractal", shape.triangleup, location.belowbar, color.new(#c53e3e, 0), offset=-fractalPeriod, size=size.tiny)
plotshape(showMarkers and bearFractal, "Bearish Fractal", shape.triangledown, location.abovebar, color.new(#4dc548, 0), offset=-fractalPeriod, size=size.tiny)

// Detect crosses
crossedBullish = not na(lastBullishLevel) and not bullishLevelCrossed and 
                 (close > lastBullishLevel and close[1] <= lastBullishLevel or 
                  close < lastBullishLevel and close[1] >= lastBullishLevel or
                  low < lastBullishLevel and high > lastBullishLevel)

crossedBearish = not na(lastBearishLevel) and not bearishLevelCrossed and 
                 (close > lastBearishLevel and close[1] <= lastBearishLevel or 
                  close < lastBearishLevel and close[1] >= lastBearishLevel or
                  low < lastBearishLevel and high > lastBearishLevel)

if crossedBullish
    bullishLevelCrossed := true
if crossedBearish
    bearishLevelCrossed := true

isCrossCandle = crossedBullish or crossedBearish

// ... (Lines 1-280, Inputs, Fractal Detection, Arrays are mostly unchanged)

// === FVG Creation (MODIFIED: REVERTING isCrossCandle check) ===

// 1. Detect FVGs (Allows detection on any bar, but still maintains duration/mitigation rules)
if high[2] < low[0] // Bullish FVG
    array.push(bull_fvg_top, low[0])
    array.push(bull_fvg_btm, high[2])
    array.push(bull_fvg_idx, bar_index) // Store creation index
    if showFVG
        array.push(bull_fvg_box, box.new(bar_index[2], low[0], bar_index, high[2], border_color=color.new(bullFVGColor, 100), bgcolor=bullFVGColor))
    else 
        array.push(bull_fvg_box, box.new(na, na, na, na))

if low[2] > high[0] // Bearish FVG
    array.push(bear_fvg_top, low[2])
    array.push(bear_fvg_btm, high[0])
    array.push(bear_fvg_idx, bar_index) // Store creation index
    if showFVG
        array.push(bear_fvg_box, box.new(bar_index[2], low[2], bar_index, high[0], border_color=color.new(bearFVGColor, 100), bgcolor=bearFVGColor))
    else
        array.push(bear_fvg_box, box.new(na, na, na, na))

// ... (Rest of the code is the same, including the time filter, setup storage, and signal generation)

// === SETUP STORAGE LOGIC (Time-Sensitive) ===
if isCrossCandle and inSession
    crossCandleHigh := high
    crossCandleLow := low
    buyAlertTriggered := false
    sellAlertTriggered := false

if not inSession and useTimeFilter
    crossCandleHigh := na
    crossCandleLow := na
    buyAlertTriggered := false
    sellAlertTriggered := false

// === SIGNAL GENERATION ===
bool potentialBuy = not na(crossCandleHigh) and not buyAlertTriggered and high > crossCandleHigh and inSession
bool potentialSell = not na(crossCandleLow) and not sellAlertTriggered and low < crossCandleLow and inSession

// === FVG FILTER CHECK ===
// Checks if the entry price is inside any currently active (unmitigated AND unexpired) FVG
isInsideFVG(float price, float[] tops, float[] btms) =>
    bool inside = false
    float tolerance = 0.0001 // Small buffer for floating point arithmetic safety
    if array.size(tops) > 0
        for i = 0 to array.size(tops) - 1
            float fvg_top = array.get(tops, i)
            float fvg_btm = array.get(btms, i)
            
            // Checks if the price is STRICTLY between the FVG top and bottom (with tolerance)
            if price < fvg_top + tolerance and price > fvg_btm - tolerance
                inside := true
                break
    inside

bool buyBlockedByFVG = filterFVG and potentialBuy and isInsideFVG(crossCandleHigh, bear_fvg_top, bear_fvg_btm)
bool sellBlockedByFVG = filterFVG and potentialSell and isInsideFVG(crossCandleLow, bull_fvg_top, bull_fvg_btm)

// Final Signals
buySignal = potentialBuy and not buyBlockedByFVG
sellSignal = potentialSell and not sellBlockedByFVG

// Prevent Re-Entry & Opposite Signal
if buySignal
    buyAlertTriggered := true
    sellAlertTriggered := true 

if sellSignal
    sellAlertTriggered := true
    buyAlertTriggered := true 

// === Trade Line Creation Logic (UNCHANGED) ===
if buySignal
    float entry = crossCandleHigh
    float sl = crossCandleLow
    float risk = entry - sl
    float tp1 = entry + (risk * rr1)
    float tp2 = showTP2 ? entry + (risk * rr2) : na
    float tp3 = showTP3 ? entry + (risk * rr3) : na

    array.push(tradeDirections, 1)
    array.push(tradeSLPrices, sl)
    array.push(tradeTP1Prices, tp1)
    array.push(tradeStatus, 0)

    array.push(entryLines, line.new(bar_index, entry, bar_index + 1, entry, color=entryColor, extend=extend.right, style=line.style_dashed))
    array.push(slLines, line.new(bar_index, sl, bar_index + 1, sl, color=slColor, extend=extend.right, style=line.style_dotted))
    array.push(tp1Lines, line.new(bar_index, tp1, bar_index + 1, tp1, color=tp1Color, extend=extend.right, style=line.style_dotted))
    if showTP2
        array.push(tp2Lines, line.new(bar_index, tp2, bar_index + 1, tp2, color=tp2Color, extend=extend.right, style=line.style_dotted))
    if showTP3
        array.push(tp3Lines, line.new(bar_index, tp3, bar_index + 1, tp3, color=tp3Color, extend=extend.right, style=line.style_dotted))

if sellSignal
    float entry = crossCandleLow
    float sl = crossCandleHigh
    float risk = sl - entry
    float tp1 = entry - (risk * rr1)
    float tp2 = showTP2 ? entry - (risk * rr2) : na
    float tp3 = showTP3 ? entry - (risk * rr3) : na
    
    array.push(tradeDirections, -1)
    array.push(tradeSLPrices, sl)
    array.push(tradeTP1Prices, tp1)
    array.push(tradeStatus, 0)
    
    array.push(entryLines, line.new(bar_index, entry, bar_index + 1, entry, color=entryColor, extend=extend.right, style=line.style_dashed))
    array.push(slLines, line.new(bar_index, sl, bar_index + 1, sl, color=slColor, extend=extend.right, style=line.style_dotted))
    array.push(tp1Lines, line.new(bar_index, tp1, bar_index + 1, tp1, color=tp1Color, extend=extend.right, style=line.style_dotted))
    if showTP2
        array.push(tp2Lines, line.new(bar_index, tp2, bar_index + 1, tp2, color=tp2Color, extend=extend.right, style=line.style_dotted))
    if showTP3
        array.push(tp3Lines, line.new(bar_index, tp3, bar_index + 1, tp3, color=tp3Color, extend=extend.right, style=line.style_dotted))

// === Trade Line Management Logic (UNCHANGED) ===
deleteOldestTrade() =>
    line.delete(array.shift(entryLines))
    line.delete(array.shift(slLines))
    line.delete(array.shift(tp1Lines))
    if showTP2 and array.size(tp2Lines) > 0
        line.delete(array.shift(tp2Lines))
    if showTP3 and array.size(tp3Lines) > 0
        line.delete(array.shift(tp3Lines))
    array.shift(tradeDirections)
    array.shift(tradeSLPrices)
    array.shift(tradeTP1Prices)
    array.shift(tradeStatus)

while array.size(entryLines) > maxTradesToShow
    deleteOldestTrade()

if array.size(entryLines) > 0
    var int i = 0
    while i < array.size(entryLines)
        int status = array.get(tradeStatus, i)
        if status == 0
            int direction = array.get(tradeDirections, i)
            float sl = array.get(tradeSLPrices, i)
            float tp1 = array.get(tradeTP1Prices, i)
            bool slHit = (direction == 1 and low <= sl) or (direction == -1 and high >= sl)
            bool tp1Hit = (direction == 1 and high >= tp1) or (direction == -1 and low <= tp1)
            if slHit or tp1Hit
                array.set(tradeStatus, i, 1) 
                line entry = array.get(entryLines, i)
                line sl_line = array.get(slLines, i)
                line tp1_line = array.get(tp1Lines, i)
                line.set_extend(entry, extend.none)
                line.set_x2(entry, bar_index)
                line.set_extend(sl_line, extend.none)
                line.set_x2(sl_line, bar_index)
                line.set_extend(tp1_line, extend.none)
                line.set_x2(tp1_line, bar_index)
                if showTP2 and array.size(tp2Lines) > i 
                    line tp2_line = array.get(tp2Lines, i)
                    line.set_extend(tp2_line, extend.none)
                    line.set_x2(tp2_line, bar_index)
                if showTP3 and array.size(tp3Lines) > i
                    line tp3_line = array.get(tp3Lines, i)
                    line.set_extend(tp3_line, extend.none)
                    line.set_x2(tp3_line, bar_index)
            else
                line.set_x2(array.get(entryLines, i), bar_index)
                line.set_x2(array.get(slLines, i), bar_index)
                line.set_x2(array.get(tp1Lines, i), bar_index)
                if showTP2 and array.size(tp2Lines) > i
                    line.set_x2(array.get(tp2Lines, i), bar_index)
                if showTP3 and array.size(tp3Lines) > i
                    line.set_x2(array.get(tp3Lines, i), bar_index)
            i := i + 1
        else
            i := i + 1

// === Plotting & Alerts (UNCHANGED) ===
alertcondition(buySignal, "Buy Signal", "Break above high of fractal cross candle")
alertcondition(sellSignal, "Sell Signal", "Break below low of fractal cross candle")

plotshape(buySignal, "Buy", shape.labelup, location.belowbar, color.new(color.green, 0), 
          text="BUY", textcolor=color.new(color.white, 0), size=size.small)
plotshape(sellSignal, "Sell", shape.labeldown, location.abovebar, color.new(color.red, 0), 
          text="SELL", textcolor=color.new(color.white, 0), size=size.small)

plotshape(buyBlockedByFVG, "Blocked Buy", shape.xcross, location.belowbar, color.gray, size=size.small, title="Blocked Buy (FVG)")
plotshape(sellBlockedByFVG, "Blocked Sell", shape.xcross, location.abovebar, color.gray, size=size.small, title="Blocked Sell (FVG)")

candleBody = crossedBullish ? crossBullishBody : crossedBearish ? crossBearishBody : na
candleBorder = crossedBullish ? crossBullishBorder : crossedBearish ? crossBearishBorder : na
candleWick = crossedBullish ? crossBullishWick : crossedBearish ? crossBearishWick : na

barcolor(candleBody, title="Cross Candle Color")
plotcandle(isCrossCandle ? open : na, 
           isCrossCandle ? high : na, 
           isCrossCandle ? low : na, 
           isCrossCandle ? close : na,
           color=candleBody, wickcolor=candleWick, bordercolor=candleBorder, title="Cross Candles")