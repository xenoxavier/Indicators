Adaptive Market Profile â€“ Auto Detect & Dynamic Activity Zones

// @ Julien_Eche

//@version=6
indicator('Adaptive Market Profile', overlay = true, max_bars_back = 5000)

useAdaptive = input.bool(true, "Automatic detection of optimal trend channel period")
pI = input.int(200, 'Manual channel period (bars)', minval = 2)
devMultiplier = input.float(2.0, 'Deviation Multiplier', minval = 0.1, step = 0.1)
uL = input.bool(true, 'Enable if chart is in logarithmic scale')
regColor = input.color(color.new(color.gray, 0), 'Channel Lines', inline = 'reg_channel')
regLineStyle = input.string('Solid', '', options = ['Solid', 'Dotted', 'Dashed'], inline = 'reg_channel')
regLineWidth = input.int(1, '', minval = 1, maxval = 4, inline = 'reg_channel')
fillColor = input.color(color.new(#909497, 95), 'Channel Fill', inline = 'channel_fill')
showRegLine = input.bool(false, 'Show Mid Line', inline = 'reg_line')
showMostActiveLines = input.bool(true, '', inline = 'lvls')
numActivityLines = input.int(2, 'Show Most Active Lines', minval = 1, maxval = 5, inline = 'lvls')
showProfile = input.bool(true, 'Show Profile', inline = 'profile_labels')
showLabels = input.bool(false, 'Show Labels', inline = 'profile_labels')
activityMethod = input.string('Volume', 'Calculation method', options = ['Touches', 'Volume'])
nFills = input.int(23, 'Number of Profile Sections', minval = 2, maxval = 25)
loActColor = input.color(color.new(#00BBFF, 95), 'Low Activity', inline = 'profile_color')
hiActColor = input.color(color.new(#00BBFF, 25), 'High Activity', inline = 'profile_color')
regLineColor = input.color(color.new(color.gray, 0), '', inline = 'reg_line')
regLineStyleOpt = input.string('Dashed', '', options = ['Solid', 'Dotted', 'Dashed'], inline = 'reg_line')
regLineWidthOpt = input.int(1, '', minval = 1, maxval = 4, inline = 'reg_line')
useCustomColor = input.bool(true, '', inline = 'act_line')
customColor = input.color(color.new(#00BBFF, 50), 'Custom Active Line Color', inline = 'act_line')
actLineStyle = input.string('Solid', '', options = ['Solid', 'Dotted', 'Dashed'], inline = 'act_line')
actLineWidth = input.int(1, '', minval = 1, maxval = 5, inline = 'act_line')

maxProfileBars = 25
effectiveProfileBars = math.max(numActivityLines, math.min(nFills, math.max(maxProfileBars - (numActivityLines - 2), 2)))

srcATF = close
devMultATF = devMultiplier
isLogATF = uL

calcDevATF(src, len) =>
    float base = isLogATF ? math.log(src) : src
    var int n1 = len - 1
    if barstate.islast
        float sumX = 0.0, sumXX = 0.0, sumYX = 0.0, sumY = 0.0
        for i = 1 to len by 1
            float val = base[i - 1]
            sumX += i
            sumXX += i * i
            sumYX += i * val
            sumY += val
        float slope = nz((len * sumYX - sumX * sumY) / (len * sumXX - sumX * sumX))
        float avg = sumY / len
        float intercept = avg - slope * sumX / len + slope
        float sumDev = 0.0, sumDxx = 0.0, sumDyy = 0.0, sumDyx = 0.0
        float reg = intercept + slope * n1 * 0.5
        float sumSlope = intercept
        for i = 0 to n1 by 1
            float v = base[i]
            float dxt = v - avg
            float dyt = sumSlope - reg
            v := v - sumSlope
            sumSlope += slope
            sumDxx += dxt * dxt
            sumDyy += dyt * dyt
            sumDyx += dxt * dyt
            sumDev += v * v
        float unStdDev = math.sqrt(sumDev / n1)
        float divisor = sumDxx * sumDyy
        float r = nz(sumDyx / math.sqrt(divisor))
        [unStdDev, r, slope, intercept]
    else
        [na, na, na, na]

[stdDev01, pr01, slope01, int01] = calcDevATF(srcATF, 50)
[stdDev02, pr02, slope02, int02] = calcDevATF(srcATF, 60)
[stdDev03, pr03, slope03, int03] = calcDevATF(srcATF, 70)
[stdDev04, pr04, slope04, int04] = calcDevATF(srcATF, 80)
[stdDev05, pr05, slope05, int05] = calcDevATF(srcATF, 90)
[stdDev06, pr06, slope06, int06] = calcDevATF(srcATF, 100)
[stdDev07, pr07, slope07, int07] = calcDevATF(srcATF, 115)
[stdDev08, pr08, slope08, int08] = calcDevATF(srcATF, 130)
[stdDev09, pr09, slope09, int09] = calcDevATF(srcATF, 145)
[stdDev10, pr10, slope10, int10] = calcDevATF(srcATF, 160)
[stdDev11, pr11, slope11, int11] = calcDevATF(srcATF, 180)
[stdDev12, pr12, slope12, int12] = calcDevATF(srcATF, 200)
[stdDev13, pr13, slope13, int13] = calcDevATF(srcATF, 220)
[stdDev14, pr14, slope14, int14] = calcDevATF(srcATF, 250)
[stdDev15, pr15, slope15, int15] = calcDevATF(srcATF, 280)
[stdDev16, pr16, slope16, int16] = calcDevATF(srcATF, 310)
[stdDev17, pr17, slope17, int17] = calcDevATF(srcATF, 340)
[stdDev18, pr18, slope18, int18] = calcDevATF(srcATF, 370)
[stdDev19, pr19, slope19, int19] = calcDevATF(srcATF, 400)


var int detectedLongPeriod = na
var float detectedLongSlope = na
var float detectedLongIntercept = na
var float detectedLongStdDev = na
var float detectedLongPearson = na
if barstate.islast
    float highestLong = math.max(pr01, pr02, pr03, pr04, pr05, pr06, pr07, pr08, pr09, pr10, pr11, pr12, pr13, pr14, pr15, pr16, pr17, pr18, pr19)
    if highestLong == pr01
        detectedLongPeriod := 50
        detectedLongSlope := slope01
        detectedLongIntercept := int01
        detectedLongStdDev := stdDev01
        detectedLongPearson := pr01
    else if highestLong == pr02
        detectedLongPeriod := 60
        detectedLongSlope := slope02
        detectedLongIntercept := int02
        detectedLongStdDev := stdDev02
        detectedLongPearson := pr02
    else if highestLong == pr03
        detectedLongPeriod := 70
        detectedLongSlope := slope03
        detectedLongIntercept := int03
        detectedLongStdDev := stdDev03
        detectedLongPearson := pr03
    else if highestLong == pr04
        detectedLongPeriod := 80
        detectedLongSlope := slope04
        detectedLongIntercept := int04
        detectedLongStdDev := stdDev04
        detectedLongPearson := pr04
    else if highestLong == pr05
        detectedLongPeriod := 90
        detectedLongSlope := slope05
        detectedLongIntercept := int05
        detectedLongStdDev := stdDev05
        detectedLongPearson := pr05
    else if highestLong == pr06
        detectedLongPeriod := 100
        detectedLongSlope := slope06
        detectedLongIntercept := int06
        detectedLongStdDev := stdDev06
        detectedLongPearson := pr06
    else if highestLong == pr07
        detectedLongPeriod := 115
        detectedLongSlope := slope07
        detectedLongIntercept := int07
        detectedLongStdDev := stdDev07
        detectedLongPearson := pr07
    else if highestLong == pr08
        detectedLongPeriod := 130
        detectedLongSlope := slope08
        detectedLongIntercept := int08
        detectedLongStdDev := stdDev08
        detectedLongPearson := pr08
    else if highestLong == pr09
        detectedLongPeriod := 145
        detectedLongSlope := slope09
        detectedLongIntercept := int09
        detectedLongStdDev := stdDev09
        detectedLongPearson := pr09
    else if highestLong == pr10
        detectedLongPeriod := 160
        detectedLongSlope := slope10
        detectedLongIntercept := int10
        detectedLongStdDev := stdDev10
        detectedLongPearson := pr10
    else if highestLong == pr11
        detectedLongPeriod := 180
        detectedLongSlope := slope11
        detectedLongIntercept := int11
        detectedLongStdDev := stdDev11
        detectedLongPearson := pr11
    else if highestLong == pr12
        detectedLongPeriod := 200
        detectedLongSlope := slope12
        detectedLongIntercept := int12
        detectedLongStdDev := stdDev12
        detectedLongPearson := pr12
    else if highestLong == pr13
        detectedLongPeriod := 220
        detectedLongSlope := slope13
        detectedLongIntercept := int13
        detectedLongStdDev := stdDev13
        detectedLongPearson := pr13
    else if highestLong == pr14
        detectedLongPeriod := 250
        detectedLongSlope := slope14
        detectedLongIntercept := int14
        detectedLongStdDev := stdDev14
        detectedLongPearson := pr14
    else if highestLong == pr15
        detectedLongPeriod := 280
        detectedLongSlope := slope15
        detectedLongIntercept := int15
        detectedLongStdDev := stdDev15
        detectedLongPearson := pr15
    else if highestLong == pr16
        detectedLongPeriod := 310
        detectedLongSlope := slope16
        detectedLongIntercept := int16
        detectedLongStdDev := stdDev16
        detectedLongPearson := pr16
    else if highestLong == pr17
        detectedLongPeriod := 340
        detectedLongSlope := slope17
        detectedLongIntercept := int17
        detectedLongStdDev := stdDev17
        detectedLongPearson := pr17
    else if highestLong == pr18
        detectedLongPeriod := 370
        detectedLongSlope := slope18
        detectedLongIntercept := int18
        detectedLongStdDev := stdDev18
        detectedLongPearson := pr18
    else
        detectedLongPeriod := 400
        detectedLongSlope := slope19
        detectedLongIntercept := int19
        detectedLongStdDev := stdDev19
        detectedLongPearson := pr19

finalPeriod = useAdaptive ? detectedLongPeriod : pI

eS = extend.right
lI = math.min(bar_index + 1, finalPeriod)

formatNumber(num) =>
    if num >= 1000000
        str.tostring(math.round(num / 1000000, 2)) + 'M'
    else if num >= 1000
        str.tostring(math.round(num / 1000, 2)) + 'K'
    else
        str.tostring(num)

f_adjust(p) =>
    uL ? math.log(p) : p
f_unadjust(p) =>
    uL ? math.exp(p) : p

cS(len) =>
    if not barstate.islast or len <= 1
        [float(na), float(na), float(na)]
    else
        sX = 0.0
        sY = 0.0
        sXS = 0.0
        sXY = 0.0
        for i = 0 to len - 1 by 1
            v = f_adjust(close[i])
            p = i + 1.0
            sX := sX + p
            sY := sY + v
            sXS := sXS + p * p
            sXY := sXY + v * p
            sXY
        sl = (len * sXY - sX * sY) / (len * sXS - sX * sX)
        av = sY / len
        ic = av - sl * sX / len + sl
        [sl, av, ic]

[s, a, i] = cS(lI)
sP = f_unadjust(i + s * (lI - 1))
eP = f_unadjust(i)

var float uSP = na
var float uEP = na
var float lSP = na
var float lEP = na
var line bL = na

if showRegLine
    if na(bL) and not na(sP)
        bL := line.new(bar_index - lI + 1, sP, bar_index, eP, width = regLineWidthOpt, extend = eS, color = regLineColor, style = regLineStyleOpt == 'Solid' ? line.style_solid : regLineStyleOpt == 'Dotted' ? line.style_dotted : line.style_dashed)
        bL
    else
        line.set_xy1(bL, bar_index - lI + 1, sP)
        line.set_xy2(bL, bar_index, eP)
        line.set_color(bL, regLineColor)
        line.set_style(bL, regLineStyleOpt == 'Solid' ? line.style_solid : regLineStyleOpt == 'Dotted' ? line.style_dotted : line.style_dashed)
        line.set_width(bL, regLineWidthOpt)
else
    line.delete(bL)

cD(len, sl, av, ic) =>
    uD = 0.0
    dD = 0.0
    sDA = 0.0
    dxx = 0.0
    dyy = 0.0
    dxy = 0.0
    per = len - 1
    dY = ic + sl * per / 2
    v = ic
    for j = 0 to per by 1
        pr = f_adjust(high[j]) - v
        if pr > uD
            uD := pr
            uD
        pr := v - f_adjust(low[j])
        if pr > dD
            dD := pr
            dD
        pr := f_adjust(close[j])
        dx = pr - av
        dy = v - dY
        pr := pr - v
        sDA := sDA + pr * pr
        dxx := dxx + dx * dx
        dyy := dyy + dy * dy
        dxy := dxy + dx * dy
        v := v + sl
        v
    sD = math.sqrt(sDA / (per == 0 ? 1 : per))
    pR = dxx == 0 or dyy == 0 ? 0 : dxy / math.sqrt(dxx * dyy)
    [sD, pR, uD, dD]

[sD, pR, uD, dD] = cD(lI, s, a, i)

applyDeviation(baseValue, deviation) =>
    f_unadjust(f_adjust(baseValue) + deviation)

uSP := applyDeviation(sP, devMultiplier * sD)
uEP := applyDeviation(eP, devMultiplier * sD)
lSP := applyDeviation(sP, -devMultiplier * sD)
lEP := applyDeviation(eP, -devMultiplier * sD)

var line u = na
var line l = na

if na(u) and not na(uSP)
    u := line.new(bar_index - lI + 1, uSP, bar_index, uEP, width = regLineWidth, extend = eS, color = regColor, style = regLineStyle == 'Solid' ? line.style_solid : regLineStyle == 'Dotted' ? line.style_dotted : line.style_dashed)
    u
else
    line.set_xy1(u, bar_index - lI + 1, uSP)
    line.set_xy2(u, bar_index, uEP)
    line.set_color(u, regColor)
    line.set_style(u, regLineStyle == 'Solid' ? line.style_solid : regLineStyle == 'Dotted' ? line.style_dotted : line.style_dashed)
    line.set_width(u, regLineWidth)

if na(l) and not na(lSP)
    l := line.new(bar_index - lI + 1, lSP, bar_index, lEP, width = regLineWidth, extend = eS, color = regColor, style = regLineStyle == 'Solid' ? line.style_solid : regLineStyle == 'Dotted' ? line.style_dotted : line.style_dashed)
    l
else
    line.set_xy1(l, bar_index - lI + 1, lSP)
    line.set_xy2(l, bar_index, lEP)
    line.set_color(l, regColor)
    line.set_style(l, regLineStyle == 'Solid' ? line.style_solid : regLineStyle == 'Dotted' ? line.style_dotted : line.style_dashed)


    line.set_style(l, regLineStyle == 'Solid' ? line.style_solid : regLineStyle == 'Dotted' ? line.style_dotted : line.style_dashed)
    line.set_width(l, regLineWidth)

linefill.new(u, showRegLine ? bL : l, color = fillColor)
if showRegLine
    linefill.new(bL, l, color = fillColor)

var label pL = na
label.delete(pL[1])
if not na(pR)
    pL := label.new(bar_index - lI + 1, lSP, str.tostring(pR, '#.###'), color = color.new(color.white, 100), textcolor = color.gray, size = size.normal, style = label.style_label_up)
    pL

calcLineValue(startY, endY, currentBar, totalBars) =>
    f_unadjust(f_adjust(startY) + (f_adjust(endY) - f_adjust(startY)) * currentBar / totalBars)

color_from_gradient(percent, color1, color2) =>
    r = color.r(color1) + (color.r(color2) - color.r(color1)) * percent
    g = color.g(color1) + (color.g(color2) - color.g(color1)) * percent
    b = color.b(color1) + (color.b(color2) - color.b(color1)) * percent
    t = color.t(color1) + (color.t(color2) - color.t(color1)) * percent
    color.rgb(r, g, b, t)

var counts = array.new_float(nFills, 0.0)
var activityLines = array.new_line(numActivityLines)
var profileFills = array.new_linefill(nFills)
var countLabels = array.new_label(numActivityLines)

if barstate.islast
    array.clear(counts)

    for actLine in activityLines
        line.delete(actLine)
    array.clear(activityLines)

    for cl in countLabels
        label.delete(cl)
    array.clear(countLabels)

    for pf in profileFills
        linefill.delete(pf)
    array.clear(profileFills)

    for idx1 = 0 to nFills - 1 by 1
        y1_top = calcLineValue(lSP, uSP, idx1, nFills)
        y1_bottom = calcLineValue(lSP, uSP, idx1 + 1, nFills)
        y2_top = calcLineValue(lEP, uEP, idx1, nFills)
        y2_bottom = calcLineValue(lEP, uEP, idx1 + 1, nFills)
        y1_mid = (y1_top + y1_bottom) / 2
        y2_mid = (y2_top + y2_bottom) / 2
        count = 0.0
        for j = 0 to lI - 1 by 1
            lineValue = calcLineValue(y1_mid, y2_mid, j, lI - 1)
            if activityMethod == 'Touches'
                if low[lI - 1 - j] <= lineValue and high[lI - 1 - j] >= lineValue
                    count := count + 1.0
                    count
            else
                if low[lI - 1 - j] <= lineValue and high[lI - 1 - j] >= lineValue
                    count := count + volume[lI - 1 - j]
                    count
        array.push(counts, count)

    maxCount = array.max(counts)
    sortedIndices = array.sort_indices(counts, order.descending)
    var float activitySlope = 0.0
    minActivityThreshold = maxCount * 0.1
    displayedActivityLines = 0

    index = array.get(sortedIndices, 0)
    actY1 = calcLineValue(lSP, uSP, index + 0.5, nFills)
    actY2 = calcLineValue(lEP, uEP, index + 0.5, nFills)
    activitySlope := (f_adjust(actY2) - f_adjust(actY1)) / (bar_index - (bar_index - lI + 1))

    if showMostActiveLines
        for idx2 = 0 to nFills - 1 by 1
            if displayedActivityLines >= numActivityLines
                break
            index := array.get(sortedIndices, idx2)
            count = array.get(counts, index)
            if count >= minActivityThreshold
                actY1 := calcLineValue(lSP, uSP, index + 0.5, nFills)
                actY2 := calcLineValue(lEP, uEP, index + 0.5, nFills)
                percent = count / maxCount
                lineColor = useCustomColor ? customColor : color_from_gradient(percent, loActColor, hiActColor)
                lineStyle = actLineStyle == 'Solid' ? line.style_solid : actLineStyle == 'Dotted' ? line.style_dotted : line.style_dashed
                startX = showProfile ? math.min(bar_index, bar_index - lI + 1 + math.round(count / maxCount * math.round(lI / 5))) : bar_index - lI + 1
                startY = showProfile ? f_unadjust(f_adjust(actY1) + activitySlope * (startX - (bar_index - lI + 1))) : actY1
                actLine = line.new(startX, startY, bar_index, actY2, color = lineColor, width = actLineWidth, style = lineStyle, extend = extend.right)
                array.push(activityLines, actLine)

                if showLabels
                    labelOffsetX = 5
                    labelOffsetY = activitySlope * labelOffsetX
                    labelX = bar_index + labelOffsetX
                    labelY = f_unadjust(f_adjust(actY2) + labelOffsetY)
                    countLabel = label.new(x = labelX, y = labelY, text = formatNumber(count), color = color.new(color.white, 100), textcolor = lineColor, size = size.small, style = label.style_label_left)
                    array.push(countLabels, countLabel)

                displayedActivityLines := displayedActivityLines + 1
                displayedActivityLines

    if showProfile
        profileLength = math.round(lI / 5)
        sortedProfileIndices = array.sort_indices(counts, order.descending)
        for idx3 = 0 to effectiveProfileBars - 1 by 1
            profileIndex = array.get(sortedProfileIndices, idx3)
            y1_top = calcLineValue(lSP, uSP, profileIndex, nFills)
            y1_bottom = calcLineValue(lSP, uSP, profileIndex + 1, nFills)
            y2_top = calcLineValue(lEP, uEP, profileIndex, nFills)
            y2_bottom = calcLineValue(lEP, uEP, profileIndex + 1, nFills)
            count = array.get(counts, profileIndex)
            percent = count / maxCount
            fillColor := color_from_gradient(percent, loActColor, hiActColor)
            lineLength = math.round(count / maxCount * profileLength)
            x2 = math.min(bar_index, bar_index - lI + 1 + lineLength)
            topLine = line.new(bar_index - lI + 1, y1_top, x2, f_unadjust(f_adjust(y1_top) + activitySlope * lineLength), color = color.new(fillColor, 100))
            bottomLine = line.new(bar_index - lI + 1, y1_bottom, x2, f_unadjust(f_adjust(y1_bottom) + activitySlope * lineLength), color = color.new(fillColor, 100))
            profileFill = linefill.new(topLine, bottomLine, color = fillColor)
            array.push(profileFills, profileFill)
