// Langlands-Operadic MÃ¶bius Vortex (LOMV)

//@version=5
indicator("Langlands-Operadic MÃ¶bius Vortex (LOMV)", shorttitle="ðŸ›¸ LOMV", overlay=true, max_lines_count=500, max_labels_count=500, max_boxes_count=500)

///==============================================================================
// ðŸ“š USER GUIDE & THEORY EXPLANATIONS
//==============================================================================
// ðŸŽ¯ DASHBOARD LEGEND:
// â€¢ ðŸ›¸ UNIFIED AI SCORE: -10 to +10 scale, >5 = strong bullish, <-5 = strong bearish
// â€¢ ðŸ”® L-Function: Quantum price resonance (-2 to +2), measures harmonic convergence
// â€¢ âš¡ Galois Rank: Market structure complexity (0-1), higher = more volatile/trending
// â€¢ ðŸŒ€ Operadic: Multi-strategy consensus (-1 to +1), algorithmic agreement strength  
// â€¢ ðŸ”— Correspondence: Theory alignment quality (0-1), higher = more reliable signals
// â€¢ ðŸ“Š OFPI: Order Flow Polarity (-100% to +100%), real buying/selling pressure
// â€¢ ðŸŽ­ Signal Quality: EXCEPTIONAL > STRONG > MODERATE > WEAK
//
// ðŸŽ¨ VISUAL ELEMENTS:
// â€¢ ðŸŒˆ Quantum Aura Bands: Multi-dimensional support/resistance zones
// â€¢ ðŸŒ€ Portal Effects: Directional flow visualization (green=bullish, red=bearish)
// â€¢ âš¡ Wick Pressure Lines: Rejection level predictions
// â€¢ ðŸ“ Fractal Grid: Key price levels with projected L-Scores
// â€¢ ðŸŒŒ Aether Flow: Background intensity showing market regime strength
//
// ðŸ§  TRADING PSYCHOLOGY:
// â€¢ Multiple timeframe confluence increases signal reliability
// â€¢ OFPI momentum shifts often precede major moves
// â€¢ Exceptional quality signals have highest win rates
// â€¢ Use fractal grid for precise entry/exit timing
// â€¢ Combine visual themes with market type (Quantum=general, Holographic=crypto, etc.)

//==============================================================================
// ðŸ”® LANGLANDS PROGRAM PARAMETERS
//==============================================================================
group_langlands = "ðŸ”® Langlands Program Parameters"

modular_level = input.int(30, "ðŸ“Š Modular Level N (L-Function Lookback)", minval=5, maxval=50, group=group_langlands, 
  tooltip="ðŸŽ¯ WHAT IT IS: Primary lookback period for quantum harmonic analysis using MÃ¶bius function\n\n" +
//   "âš¡ HOW IT WORKS: Calculates weighted price returns using number theory (MÃ¶bius Î¼ function)\n\n" +
//   "ðŸ“ˆ POSITIVE ADJUSTMENT: Longer lookback = smoother signals, less noise, slower reaction\n" +
//   "ðŸ“‰ NEGATIVE ADJUSTMENT: Shorter lookback = faster signals, more sensitive, higher noise\n\n" +
//   "ðŸ•’ TIMEFRAME OPTIMIZATION:\n" +
//   "â€¢ 1min-5min: Use 15-25 for scalping\n" +
//   "â€¢ 15min-1H: Use 25-35 for day trading\n" +
//   "â€¢ 4H-1D: Use 35-50 for swing trading\n\n" +
//   "ðŸ¦ SECTOR RECOMMENDATIONS:\n" +
//   "â€¢ Stocks: 30-40 (stable)\n" +
//   "â€¢ Indices: 25-35 (trending)\n" +
//   "â€¢ Crypto: 15-25 (volatile)\n" +
//   "â€¢ Forex: 35-45 (smooth)")

l_function_precision = input.float(1.5, "ðŸ”¬ L-Function Critical Strip (s)", minval=0.5, maxval=2.5, step=0.1, group=group_langlands,
  tooltip="ðŸŽ¯ WHAT IT IS: Mathematical precision parameter for Riemann zeta function convergence\n\n" +
//   "âš¡ HOW IT WORKS: Controls weight decay in harmonic series (1/n^s), affects signal smoothness\n\n" +
//   "ðŸ“ˆ HIGHER VALUES (1.8-2.5): More stable, less reactive, smoother curves\n" +
//   "ðŸ“‰ LOWER VALUES (0.5-1.2): More reactive, noisier, catches quick moves\n\n" +
//   "ðŸ•’ TIMEFRAME OPTIMIZATION:\n" +
//   "â€¢ High Frequency (1min-5min): 0.8-1.2\n" +
//   "â€¢ Medium Frequency (15min-1H): 1.3-1.7\n" +
//   "â€¢ Low Frequency (4H+): 1.8-2.3\n\n" +
//   "ðŸ¦ SECTOR RECOMMENDATIONS:\n" +
//   "â€¢ Stocks: 1.5-1.8 (balanced)\n" +
//   "â€¢ Crypto: 0.8-1.3 (catch volatility)\n" +
//   "â€¢ Forex: 1.6-2.1 (smooth trends)\n" +
//   "â€¢ Commodities: 1.4-1.9 (medium)")

frobenius_lookback = input.int(21, "ðŸ”„ Frobenius Trace Period", minval=5, maxval=50, group=group_langlands,
  tooltip="ðŸŽ¯ WHAT IT IS: Lookback for price-volume correlation analysis (Galois representation)\n\n" +
//   "âš¡ HOW IT WORKS: Measures harmonic relationship between price and volume flows\n\n" +
//   "ðŸ“ˆ LONGER PERIODS: More stable correlations, slower adaptation\n" +
//   "ðŸ“‰ SHORTER PERIODS: Faster correlation changes, more sensitive\n\n" +
//   "ðŸ•’ TIMEFRAME OPTIMIZATION:\n" +
//   "â€¢ Scalping: 8-15 periods\n" +
//   "â€¢ Day Trading: 18-25 periods\n" +
//   "â€¢ Swing Trading: 25-40 periods\n\n" +
//   "ðŸ¦ SECTOR RECOMMENDATIONS:\n" +
//   "â€¢ High Volume Stocks: 15-25\n" +
//   "â€¢ Low Volume Stocks: 25-35\n" +
//   "â€¢ Crypto: 10-20 (fast correlation shifts)\n" +
//   "â€¢ Indices: 20-30 (stable correlations)")

htf_tf = input.timeframe("60", "â° HTF for Multi-Scale Analysis", group=group_langlands,
  tooltip="ðŸŽ¯ WHAT IT IS: Higher timeframe for trend confirmation and bias\n\n" +
//   "âš¡ HOW IT WORKS: Provides market context and filters signals against major trends\n\n" +
//   "ðŸ“Š TIMEFRAME MULTIPLIERS:\n" +
//   "â€¢ Chart TF 1min â†’ HTF 5min-15min\n" +
//   "â€¢ Chart TF 5min â†’ HTF 30min-1H\n" +
//   "â€¢ Chart TF 15min â†’ HTF 1H-4H\n" +
//   "â€¢ Chart TF 1H â†’ HTF 4H-1D\n\n" +
//   "ðŸŽ¯ TRADING STYLES:\n" +
//   "â€¢ Scalping: Use 3-5x multiplier\n" +
//   "â€¢ Day Trading: Use 4-6x multiplier\n" +
//   "â€¢ Swing Trading: Use 6-12x multiplier\n\n" +
//   "ðŸ’¡ PRO TIP: Higher timeframe bias improves win rate by 15-25%")

//==============================================================================
// âˆž OPERADIC COMPOSITION PARAMETERS  
//==============================================================================
group_operadic = "âˆž Operadic Composition Parameters"

composition_arity = input.int(4, "ðŸŽ­ Strategy Composition Arity", minval=2, maxval=5, group=group_operadic,
  tooltip="ðŸŽ¯ WHAT IT IS: Number of trading strategies combined for final signal\n\n" +
//   "âš¡ HOW IT WORKS: Uses category theory to compose multiple algorithms\n\n" +
//   "ðŸ“ˆ MORE STRATEGIES (4-5): Higher confidence, fewer but stronger signals\n" +
//   "ðŸ“‰ FEWER STRATEGIES (2-3): More signals, potentially less reliable\n\n" +
//   "ðŸŽ¯ OPTIMAL SETTINGS:\n" +
//   "â€¢ Conservative Trading: 4-5 strategies\n" +
//   "â€¢ Moderate Trading: 3-4 strategies  \n" +
//   "â€¢ Aggressive Trading: 2-3 strategies\n\n" +
//   "ðŸ¦ MARKET CONDITIONS:\n" +
//   "â€¢ Trending Markets: 3-4 (balance speed/accuracy)\n" +
//   "â€¢ Choppy Markets: 4-5 (need more confirmation)\n" +
//   "â€¢ High Volatility: 4-5 (filter noise)")

agreement_required = input.int(3, "ðŸ¤ Category Agreement Threshold", minval=2, maxval=5, group=group_operadic,
  tooltip="ðŸŽ¯ WHAT IT IS: Minimum number of strategies that must agree for signal\n\n" +
//   "âš¡ HOW IT WORKS: Democratic voting system among composed strategies\n\n" +
//   "ðŸ“ˆ HIGHER AGREEMENT: Fewer but higher quality signals\n" +
//   "ðŸ“‰ LOWER AGREEMENT: More signals but potentially more false positives\n\n" +
//   "ðŸŽ¯ RECOMMENDED RATIOS:\n" +
//   "â€¢ Conservative: Agreement = Arity (100% consensus)\n" +
//   "â€¢ Moderate: Agreement = Arity - 1 (majority++)\n" +
//   "â€¢ Aggressive: Agreement = 50-60% of Arity\n\n" +
//   "ðŸ’¡ OPTIMAL COMBINATIONS:\n" +
//   "â€¢ Arity 5, Agreement 4: Ultra-high quality\n" +
//   "â€¢ Arity 4, Agreement 3: Balanced approach\n" +
//   "â€¢ Arity 3, Agreement 2: More frequent signals")

swiss_cheese_weight = input.float(0.382, "ðŸ§€ Swiss-Cheese Mixing (Ï†â»Â¹)", minval=0.1, maxval=0.5, step=0.05, group=group_operadic,
  tooltip="ðŸŽ¯ WHAT IT IS: Golden ratio based blending of trend alignment factors\n\n" +
//   "âš¡ HOW IT WORKS: Applies Ï†â»Â¹ (inverse golden ratio) for natural market harmonics\n\n" +
//   "ðŸ“ˆ HIGHER VALUES (0.4-0.5): Stronger trend following, less contrarian\n" +
//   "ðŸ“‰ LOWER VALUES (0.1-0.25): More contrarian signals, less trend bias\n\n" +
//   "ðŸŽ¯ MARKET PERSONALITY:\n" +
//   "â€¢ Strong Trending: 0.35-0.45\n" +
//   "â€¢ Range Bound: 0.15-0.25  \n" +
//   "â€¢ Mixed Conditions: 0.30-0.40\n\n" +
//   "ðŸ”¬ MATHEMATICAL NOTE: 0.382 is Ï†â»Â¹, optimal for natural market fractals\n" +
//   "ðŸ’¡ PRO TIP: Fibonacci levels work because markets follow golden ratio dynamics")

ofpi_length = input.int(14, "ðŸ“Š OFPI Lookback Length", minval=5, maxval=30, group=group_operadic,
  tooltip="ðŸŽ¯ WHAT IT IS: Order Flow Polarity Index calculation period\n\n" +
//   "âš¡ HOW IT WORKS: Measures real buying vs selling pressure using volume analysis\n\n" +
//   "ðŸ“ˆ LONGER PERIODS: Smoother OFPI, less noise, slower adaptation\n" +
//   "ðŸ“‰ SHORTER PERIODS: More sensitive to flow changes, faster signals\n\n" +
//   "ðŸ•’ TIMEFRAME OPTIMIZATION:\n" +
//   "â€¢ Scalping (1-5min): 8-12\n" +
//   "â€¢ Intraday (15min-1H): 12-18\n" +
//   "â€¢ Swing (4H+): 18-25\n\n" +
//   "ðŸ¦ VOLUME CHARACTERISTICS:\n" +
//   "â€¢ High Volume Assets: 10-16\n" +
//   "â€¢ Medium Volume: 14-20\n" +
//   "â€¢ Low Volume: 18-25")

ofpi_t3_length = input.int(5, "âš¡ OFPI T3 Smoothing", minval=3, maxval=10, group=group_operadic,
  tooltip="ðŸŽ¯ WHAT IT IS: T3 (Tillson) smoothing for OFPI noise reduction\n\n" +
//   "âš¡ HOW IT WORKS: Advanced exponential smoothing with minimal lag\n\n" +
//   "ðŸ“ˆ HIGHER VALUES: Smoother OFPI, less whipsaws\n" +
//   "ðŸ“‰ LOWER VALUES: More responsive, catches quick shifts\n\n" +
//   "ðŸŽ¯ OPTIMAL SETTINGS:\n" +
//   "â€¢ Noisy Markets: 6-8\n" +
//   "â€¢ Clean Trends: 3-5\n" +
//   "â€¢ Mixed Conditions: 4-6\n\n" +
//   "ðŸ’¡ T3 ADVANTAGE: Superior to regular EMA for reducing lag while maintaining smoothness")

ofpi_t3_vfactor = input.float(0.7, "ðŸŽ›ï¸ OFPI T3 Volume Factor", minval=0.5, maxval=1.0, step=0.1, group=group_operadic,
  tooltip="ðŸŽ¯ WHAT IT IS: T3 algorithm volume factor for smoothing aggressiveness\n\n" +
//   "âš¡ HOW IT WORKS: Controls balance between responsiveness and smoothness\n\n" +
//   "ðŸ“ˆ HIGHER VALUES (0.8-1.0): Maximum smoothness, minimal noise\n" +
//   "ðŸ“‰ LOWER VALUES (0.5-0.7): More responsive, faster reaction\n\n" +
//   "ðŸŽ¯ MARKET ADAPTATION:\n" +
//   "â€¢ Volatile Markets: 0.8-0.9 (need smoothing)\n" +
//   "â€¢ Stable Markets: 0.6-0.7 (want responsiveness)\n" +
//   "â€¢ Crypto: 0.7-0.8 (balance volatility)\n\n" +
//   "ðŸ”¬ TECHNICAL: 0.7 provides optimal lag vs noise reduction ratio")

//==============================================================================
// ðŸŽ¯ UNIFIED SCORING SYSTEM
//==============================================================================
group_scoring = "ðŸŽ¯ Unified Scoring System"

l_function_weight = input.float(0.3, "ðŸ”® L-Function Weight", minval=0.1, maxval=0.5, step=0.05, group=group_scoring,
  tooltip="ðŸŽ¯ WHAT IT IS: Importance weight for quantum harmonic analysis in final score\n\n" +
//   "âš¡ HOW IT WORKS: Mathematical beauty score from number theory patterns\n\n" +
//   "ðŸ“ˆ HIGHER WEIGHT: More emphasis on mathematical harmony and cycles\n" +
//   "ðŸ“‰ LOWER WEIGHT: Less mathematical bias, more practical focus\n\n" +
//   "ðŸŽ¯ TRADING PERSONALITY:\n" +
//   "â€¢ Mathematical Traders: 0.35-0.45\n" +
//   "â€¢ Practical Traders: 0.15-0.25\n" +
//   "â€¢ Balanced Approach: 0.25-0.35\n\n" +
//   "ðŸ¦ ASSET CLASSES:\n" +
//   "â€¢ Indices: 0.30-0.40 (mathematical patterns)\n" +
//   "â€¢ Individual Stocks: 0.20-0.30 (more noise)\n" +
//   "â€¢ Crypto: 0.25-0.35 (pure math markets)")

galois_weight = input.float(0.2, "âš¡ Galois Rank Weight", minval=0.1, maxval=0.5, step=0.05, group=group_scoring,
  tooltip="ðŸŽ¯ WHAT IT IS: Market structure complexity and volatility regime influence\n\n" +
//   "âš¡ HOW IT WORKS: Measures market stress and structural changes\n\n" +
//   "ðŸ“ˆ HIGHER WEIGHT: More focus on volatility and market stress signals\n" +
//   "ðŸ“‰ LOWER WEIGHT: Less emphasis on market structure changes\n\n" +
//   "ðŸŒŠ MARKET CONDITIONS:\n" +
//   "â€¢ High Volatility Periods: 0.25-0.35\n" +
//   "â€¢ Low Volatility Periods: 0.15-0.25\n" +
//   "â€¢ Transition Periods: 0.30-0.40\n\n" +
//   "ðŸŽ¯ STRATEGY FOCUS:\n" +
//   "â€¢ Volatility Traders: 0.30-0.40\n" +
//   "â€¢ Trend Followers: 0.15-0.25\n" +
//   "â€¢ Market Structure: 0.25-0.35")

operadic_weight = input.float(0.3, "ðŸŒ€ Operadic Composition Weight", minval=0.1, maxval=0.5, step=0.05, group=group_scoring,
  tooltip="ðŸŽ¯ WHAT IT IS: Multi-strategy consensus importance in final decision\n\n" +
//   "âš¡ HOW IT WORKS: Democratic weight of all composed trading algorithms\n\n" +
//   "ðŸ“ˆ HIGHER WEIGHT: Trust the wisdom of crowds approach\n" +
//   "ðŸ“‰ LOWER WEIGHT: More mathematical/theoretical focus\n\n" +
//   "ðŸŽ­ TRADING PHILOSOPHY:\n" +
//   "â€¢ Systematic Traders: 0.35-0.45\n" +
//   "â€¢ Discretionary Traders: 0.20-0.30\n" +
//   "â€¢ Hybrid Approach: 0.25-0.35\n\n" +
//   "ðŸ’¡ RELIABILITY: Higher operadic weight typically improves win rates\n" +
//   "ðŸŽ¯ OPTIMAL: Balance with other weights for best performance")

correspondence_weight = input.float(0.2, "ðŸ”— Correspondence Quality Weight", minval=0.1, maxval=0.5, step=0.05, group=group_scoring,
  tooltip="ðŸŽ¯ WHAT IT IS: Theory-practice alignment quality measure\n\n" +
//   "âš¡ HOW IT WORKS: Measures how well mathematical theory matches market reality\n\n" +
//   "ðŸ“ˆ HIGHER WEIGHT: Demand strong theory-practice agreement\n" +
//   "ðŸ“‰ LOWER WEIGHT: Accept some theory-practice divergence\n\n" +
//   "ðŸ”¬ MARKET EFFICIENCY:\n" +
//   "â€¢ Efficient Markets: 0.25-0.35 (theory works)\n" +
//   "â€¢ Inefficient Markets: 0.15-0.25 (theory breaks)\n" +
//   "â€¢ Mixed Efficiency: 0.20-0.30\n\n" +
//   "ðŸŽ¯ SIGNAL QUALITY:\n" +
//   "â€¢ Quality Over Quantity: 0.25-0.35\n" +
//   "â€¢ Quantity Over Quality: 0.15-0.25\n\n" +
//   "ðŸ’¡ NOTE: Weight sum should â‰ˆ 1.0 for optimal balance")

score_threshold = input.float(5.0, "ðŸŽ¯ Signal Score Threshold (0-10)", minval=0.5, maxval=10.0, step=0.5, group=group_scoring,
  tooltip="ðŸŽ¯ WHAT IT IS: Minimum score required for signal generation (-10 to +10 scale)\n\n" +
//   "âš¡ HOW IT WORKS: Quality filter - only scores above/below threshold trigger signals\n\n" +
//   "ðŸ“ˆ HIGHER THRESHOLD: Fewer but higher quality signals\n" +
//   "ðŸ“‰ LOWER THRESHOLD: More signals but potentially more noise\n\n" +
//   "ðŸŽ¯ TRADING FREQUENCY:\n" +
//   "â€¢ Conservative (2-5 signals/day): 6.0-8.0\n" +
//   "â€¢ Moderate (5-10 signals/day): 4.0-6.0\n" +
//   "â€¢ Active (10+ signals/day): 2.0-4.0\n\n" +
//   "ðŸ† QUALITY LEVELS:\n" +
//   "â€¢ 8.0+: EXCEPTIONAL signals only\n" +
//   "â€¢ 6.0-7.9: STRONG signals\n" +
//   "â€¢ 4.0-5.9: MODERATE signals\n" +
//   "â€¢ 2.0-3.9: WEAK signals\n\n" +
//   "ðŸ’¡ BACKTESTING TIP: Start high (7.0+) then adjust based on frequency needs")

//==============================================================================
// ðŸŒŒ VISUAL CONFIGURATION
//==============================================================================
group_visual = "ðŸŒŒ Visual Configuration"

visual_theme = input.string("Quantum", "ðŸŽ¨ Visual Theme", options=["Quantum", "Holographic", "Crystalline", "Plasma", "Cosmic Neon"], group=group_visual,
  tooltip="ðŸŽ¯ WHAT IT IS: Color scheme and visual personality of the indicator\n\n" +
//   "ðŸŒˆ THEME PERSONALITIES:\n" +
//   "â€¢ ðŸ”® QUANTUM: Purple/violet - General trading, mathematical focus\n" +
//   "â€¢ ðŸŒŠ HOLOGRAPHIC: Cyan/magenta - Crypto trading, digital assets\n" +
//   "â€¢ ðŸ’Ž CRYSTALLINE: Blue/turquoise - Conservative trading, stability\n" +
//   "â€¢ ðŸ”¥ PLASMA: Gold/magenta - High energy trading, volatility\n" +
//   "â€¢ ðŸš€ COSMIC NEON: Bright neon - Aggressive trading, maximum visibility\n\n" +
//   "ðŸŽ¯ MARKET MATCHING:\n" +
//   "â€¢ Traditional Markets: Quantum, Crystalline\n" +
//   "â€¢ Crypto Markets: Holographic, Cosmic Neon\n" +
//   "â€¢ Commodities: Plasma, Crystalline\n" +
//   "â€¢ Forex: Quantum, Holographic\n\n" +
//   "ðŸ’¡ PRO TIP: Match theme to your trading personality for better visual comfort")

showFractalGrid = input.bool(true, "ðŸ“ Show Fractal Grid (Key Levels)", group=group_visual,
  tooltip="ðŸŽ¯ WHAT IT IS: Dynamic support/resistance levels with projected L-Scores\n\n" +
//   "âš¡ HOW IT WORKS: Calculates fractal highs/lows with estimated signal scores\n\n" +
//   "ðŸ“ˆ BENEFITS: Precise entry/exit timing, projected signal strength\n" +
//   "ðŸ“‰ DRAWBACKS: Can clutter chart on lower timeframes\n\n" +
//   "ðŸ•’ RECOMMENDED FOR:\n" +
//   "â€¢ Swing Trading: Always ON\n" +
//   "â€¢ Day Trading: ON for major levels\n" +
//   "â€¢ Scalping: OFF (too cluttered)\n\n" +
//   "ðŸ’¡ USAGE: Watch for price approach to grid levels + high L-Score projections")

show_signal_portals = input.bool(true, "ðŸŒ€ Signal Portals & Effects", group=group_visual,
  tooltip="ðŸŽ¯ WHAT IT IS: Entry signals with directional flow visualization\n\n" +
//   "âš¡ FEATURES:\n" +
//   "â€¢ Triangle markers for entries\n" +
//   "â€¢ Colored portal effects showing flow direction\n" +
//   "â€¢ Morphism recursion patterns\n\n" +
//   "ðŸŽ¯ VISUAL BENEFITS:\n" +
//   "â€¢ Instant signal recognition\n" +
//   "â€¢ Flow direction clarity\n" +
//   "â€¢ Market momentum visualization\n\n" +
//   "ðŸ’¡ OPTIMIZATION: Turn OFF for cleaner charts, ON for maximum information")

show_aether_flow = input.bool(true, "ðŸŒŠ Show Aether Flow Background", group=group_visual,
  tooltip="ðŸŽ¯ WHAT IT IS: Background intensity heatmap showing market regime strength\n\n" +
//   "âš¡ HOW IT WORKS: Combines trend, momentum, volatility, and score intensity\n\n" +
//   "ðŸŽ¨ INTENSITY LEVELS:\n" +
//   "â€¢ Black/Dark: Low activity, range-bound\n" +
//   "â€¢ Purple Glow: Moderate activity, building momentum  \n" +
//   "â€¢ Bright Purple: High activity, strong trends\n" +
//   "â€¢ Intense Glow: Extreme activity, major moves\n\n" +
//   "ðŸŽ¯ TRADING INSIGHT: Bright backgrounds = high probability setups\n" +
//   "ðŸ’¡ PRO TIP: Trade more aggressively when background is bright")

field_transparency = input.int(85, "ðŸŒ«ï¸ Field Transparency", minval=70, maxval=95, group=group_visual,
  tooltip="ðŸŽ¯ WHAT IT IS: Transparency level for quantum aura bands and background\n\n" +
//   "âš¡ SETTINGS:\n" +
//   "â€¢ 70-75: More visible, stronger visual impact\n" +
//   "â€¢ 80-85: Balanced visibility\n" +
//   "â€¢ 90-95: Subtle, minimal interference\n\n" +
//   "ðŸŽ¯ CHART PREFERENCES:\n" +
//   "â€¢ Clean Charts: 90-95\n" +
//   "â€¢ Balanced: 80-87\n" +
//   "â€¢ Full Visual: 70-80\n\n" +
//   "ðŸ’¡ OPTIMIZATION: Adjust based on chart background and personal preference")

show_morphism_flow = input.bool(true, "ðŸŒ€ Show Morphism Flow (Portals)", group=group_visual,
  tooltip="ðŸŽ¯ WHAT IT IS: Advanced geometric patterns showing market flow topology\n\n" +
//   "âš¡ VISUAL ELEMENTS:\n" +
//   "â€¢ Layered circular portals\n" +
//   "â€¢ Directional color coding\n" +
//   "â€¢ Recursive depth patterns\n\n" +
//   "ðŸŽ¨ COLOR MEANING:\n" +
//   "â€¢ Green/Cyan: Bullish flow\n" +
//   "â€¢ Red/Orange: Bearish flow\n" +
//   "â€¢ Size: Flow strength\n\n" +
//   "ðŸŽ¯ USAGE: Helps visualize market sentiment and momentum direction\n" +
//   "ðŸ’¡ ADVANCED: Based on category theory and topological data analysis")

visual_transparency = input.int(60, "ðŸŒ«ï¸ Morphism Flow Transparency", minval=0, maxval=100, group=group_visual,
  tooltip="ðŸŽ¯ CONTROL: Transparency of portal effects and morphism patterns\n\n" +
//   "âš¡ SETTINGS:\n" +
//   "â€¢ 0-30: Very visible, strong impact\n" +
//   "â€¢ 40-70: Balanced visibility\n" +
//   "â€¢ 80-100: Subtle/invisible\n\n" +
//   "ðŸŽ¯ OPTIMIZATION: Balance visual appeal with chart readability")

type_recursion_depth = input.int(4, "ðŸ”„ Morphism Recursion Depth", minval=1, maxval=8, group=group_visual,
  tooltip="ðŸŽ¯ WHAT IT IS: Number of recursive portal layers for pattern analysis\n\n" +
//   "âš¡ HOW IT WORKS: Creates nested geometric patterns showing flow evolution\n\n" +
//   "ðŸ“ˆ HIGHER DEPTH: More complex patterns, deeper analysis\n" +
//   "ðŸ“‰ LOWER DEPTH: Simpler patterns, less CPU usage\n\n" +
//   "ðŸŽ¯ PERFORMANCE OPTIMIZATION:\n" +
//   "â€¢ Fast Charts: 2-4 depth\n" +
//   "â€¢ Detailed Analysis: 4-6 depth\n" +
//   "â€¢ Maximum Insight: 6-8 depth\n\n" +
//   "ðŸ’¡ BALANCE: More depth = more insight but also more visual complexity")

show_wick_pressure = input.bool(true, "âš¡ Show Wick Pressure Lines", group=group_visual,
  tooltip="ðŸŽ¯ WHAT IT IS: Rejection level analysis using candle wick patterns\n\n" +
//   "âš¡ HOW IT WORKS: Projects lines from significant wicks to show pressure zones\n\n" +
//   "ðŸ“ˆ UPPER WICKS: Show selling pressure and resistance\n" +
//   "ðŸ“‰ LOWER WICKS: Show buying pressure and support\n\n" +
//   "ðŸŽ¯ TRADING APPLICATION:\n" +
//   "â€¢ Entry: Trade bounces off wick pressure zones\n" +
//   "â€¢ Exit: Watch for wick pressure breakdown\n" +
//   "â€¢ Confluence: Combine with fractal grid levels\n\n" +
//   "ðŸ’¡ PRO TIP: Multiple wick pressure lines = stronger S/R zones")

glowIntensity = input.int(4, "âœ¨ Wick Glow Intensity", minval=1, maxval=8, group=group_visual,
  tooltip="ðŸŽ¯ WHAT IT IS: Visual intensity and reach of wick pressure line effects\n\n" +
//   "âš¡ INTENSITY LEVELS:\n" +
//   "â€¢ 1-2: Minimal glow, subtle lines\n" +
//   "â€¢ 3-5: Moderate glow, balanced visibility\n" +
//   "â€¢ 6-8: Maximum glow, strong visual impact\n\n" +
//   "ðŸŽ¯ CHART OPTIMIZATION:\n" +
//   "â€¢ Busy Charts: 2-4 intensity\n" +
//   "â€¢ Clean Charts: 4-6 intensity\n" +
//   "â€¢ Dramatic Effect: 6-8 intensity\n\n" +
//   "ðŸ’¡ PERFORMANCE: Higher intensity uses more visual resources")

//==============================================================================
// ðŸ“Š DASHBOARD CONFIGURATION
//==============================================================================
group_dashboard_main = "ðŸ“Š Dashboard Configuration"

show_dashboard = input.bool(true, "ðŸ“‹ Show Enhanced Dashboard", group=group_dashboard_main,
  tooltip="ðŸŽ¯ WHAT IT IS: Comprehensive information panel with all key metrics\n\n" +
//   "ðŸ“Š DASHBOARD INCLUDES:\n" +
//   "â€¢ Unified AI Score with quality rating\n" +
//   "â€¢ Component breakdowns (L-Function, Galois, etc.)\n" +
//   "â€¢ OFPI analysis with momentum detection\n" +
//   "â€¢ Signal performance statistics\n" +
//   "â€¢ Current position details\n" +
//   "â€¢ MÃ¶bius field strength\n\n" +
//   "ðŸŽ¯ BENEFITS:\n" +
//   "â€¢ Quick decision making\n" +
//   "â€¢ Performance tracking\n" +
//   "â€¢ Market regime awareness\n\n" +
//   "ðŸ’¡ RECOMMENDED: Always ON for systematic trading")

dashboard_size = input.string("Normal", "ðŸ“ Dashboard Size", options=["Small", "Normal", "Large"], group=group_dashboard_main,
  tooltip="ðŸŽ¯ SIZE OPTIMIZATION:\n\n" +
//   "ðŸ“± SMALL: Essential metrics only, minimal screen space\n" +
//   "â€¢ Best for: Mobile, small screens, overlay trading\n" +
//   "â€¢ Shows: Score, position, basic stats\n\n" +
//   "ðŸ’» NORMAL: Balanced information and space usage\n" +
//   "â€¢ Best for: Desktop trading, general use\n" +
//   "â€¢ Shows: All core metrics with OFPI analysis\n\n" +
//   "ðŸ–¥ï¸ LARGE: Maximum information detail\n" +
//   "â€¢ Best for: Multiple monitors, detailed analysis\n" +
//   "â€¢ Shows: Everything including extended breakdowns\n\n" +
//   "ðŸ’¡ RECOMMENDATION: Start with Normal, adjust based on screen space")

dashboard_position_input = input.string("Top Right", "ðŸ“ Dashboard Position", options=["Top Left", "Top Right", "Bottom Left", "Bottom Right"], group=group_dashboard_main,
  tooltip="ðŸŽ¯ POSITIONING STRATEGY:\n\n" +
//   "ðŸ“ TOP RIGHT: Classic placement, doesn't block price action\n" +
//   "â€¢ Best for: Right-handed traders, standard setups\n\n" +
//   "ðŸ“ TOP LEFT: Alternative placement for wider charts\n" +
//   "â€¢ Best for: Ultra-wide monitors, left-handed preference\n\n" +
//   "ðŸ“ BOTTOM RIGHT: Keeps focus on recent price action\n" +
//   "â€¢ Best for: Short-term trading, scalping\n\n" +
//   "ðŸ“ BOTTOM LEFT: Maximum price visibility\n" +
//   "â€¢ Best for: Swing trading, longer-term analysis\n\n" +
//   "ðŸ’¡ TIP: Choose position that doesn't interfere with your key chart areas")

//==============================================================================
// ðŸ”§ VARIABLE DECLARATIONS - MUST BE AFTER INPUTS
//==============================================================================
// Fixed volatility calculation for consistency
atr_14 = ta.atr(14)
volatility_percentile = ta.percentrank(atr_14, 100)

// Variables that need to be declared for dashboard use
var float entry_price = na
var int direction = 0
var int last_signal_bar = 0
var int total_signals = 0
var int winning_signals = 0
var int max_mobius_n = 50
var bool show_warning = false


//==============================================================================
// THEME COLORS (Quantum Default)
//==============================================================================
// get_theme_colors() => visual_theme == "Holographic" ? array.from(#00ffff, #ff00ff, #ffff00, #00ff00, #ff0066, #808080) : visual_theme == "Crystalline" ? array.from(#4169e1, #9370db, #00ced1, #da70d6, #7b68ee, #b0c4de) : visual_theme == "Plasma" ? array.from(#ff1493, #ff4500, #ffd700, #ff69b4, #dc143c, #ffdab9) : visual_theme == "Cosmic Neon" ? array.from(#ff073a, #00f9ff, #39ff14, #f8f32b, #ff40e0, #ffffff) : array.from(#9400d3, #4b0082, #0000ff, #00ff00, #ff0000, #808080)

// Using the safe assignment method by getting each element from the returned array.
var theme_array = get_theme_colors()
// color c1 = array.get(theme_array, 0)
// color c2 = array.get(theme_array, 1)
// color c3 = array.get(theme_array, 2)
// color c4 = array.get(theme_array, 3)
// color c5 = array.get(theme_array, 4)
// color c_neutral = array.get(theme_array, 5)

// Custom portal colors
portal_color_outer = color.new(#2a003f, 85)
portal_color_inner = color.new(#a259ff, 60)
primaryBull = color.new(#a259ff, 0)
primaryBear = color.new(#2a003f, 0)

//==============================================================================
// FRACTAL GRID COLORS (auto-match theme, no extra inputs)
//==============================================================================
// CORRECTED: Replaced invalid [...] array creation with array.from()
// get_fractal_colors() => visual_theme == "Holographic" ? array.from(color.new(#00ff00, 70), color.new(#00ff00, 10), color.new(#ff0066, 70), color.new(#ff0066, 10)) : visual_theme == "Crystalline" ? array.from(color.new(#00ced1, 70), color.new(#00ced1, 10), color.new(#9370db, 70), color.new(#9370db, 10)) : visual_theme == "Plasma" ? array.from(color.new(#ffd700, 70), color.new(#ffd700, 10), color.new(#ff1493, 70), color.new(#ff1493, 10)) : visual_theme == "Cosmic Neon" ? array.from(color.new(#39ff14, 70), color.new(#39ff14, 10), color.new(#ff073a, 70), color.new(#ff073a, 10)) : array.from(color.new(#00ff00, 70), color.new(#00ff00, 10), color.new(#ff0000, 70), color.new(#ff0000, 10))

// Using the safe assignment method to avoid any issues with [...]
var fractal_color_array = get_fractal_colors()
// color fractalHighGlow = array.get(fractal_color_array, 0)
// color fractalHighSharp = array.get(fractal_color_array, 1)
// color fractalLowGlow = array.get(fractal_color_array, 2)
// color fractalLowSharp = array.get(fractal_color_array, 3)

//==============================================================================
// ADVANCED THEORY FUNCTIONS
//==============================================================================
// tanh(x) => (math.exp(x) - math.exp(-x)) / (math.exp(x) + math.exp(-x))

//==============================================================================
// STATIC MÃ–BIUS ARRAY (FAST, NO TIMEOUT)
//==============================================================================
var float[] mobius_arr = array.from(0.0, 1.0, -1.0, -1.0, 0.0, -1.0, 1.0, -1.0, 0.0, 0.0, 1.0, -1.0, 1.0, -1.0, 0.0, 1.0, 0.0, -1.0, 1.0, 1.0, 0.0, -1.0, 1.0, 0.0, 0.0, 1.0, 1.0, -1.0, 1.0, 0.0, 0.0, -1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, -1.0, 1.0, 1.0, 0.0, 1.0, 0.0, -1.0, 1.0, 0.0, 0.0, 1.0)
//==============================================================================
// HTF (NON-REPAINT) FEATURES
//==============================================================================
htf_close = request.security(syminfo.tickerid, htf_tf, close, lookahead=barmerge.lookahead_off)
htf_rsi = request.security(syminfo.tickerid, htf_tf, ta.rsi(close, 14), lookahead=barmerge.lookahead_off)
htf_sma50 = request.security(syminfo.tickerid, htf_tf, ta.sma(close, 50), lookahead=barmerge.lookahead_off)
htf_trend = htf_close > htf_sma50 ? 1 : htf_close < htf_sma50 ? -1 : 0
htf_vol = request.security(syminfo.tickerid, htf_tf, ta.atr(14), lookahead=barmerge.lookahead_off)

//==============================================================================
// ORDER FLOW POLARITY INDEX (OFPI) INTEGRATION
//==============================================================================
// calculate_ofpi(len, t3_len, t3_vf) =>
    body_pos = (close - low) / (high - low + 1e-6)
    buy_vol = volume * body_pos
    sell_vol = volume * (1 - body_pos)
    net_aggr_vol = buy_vol - sell_vol
    ofpi_raw = 0.0
    total_vol = 0.0
    for i = 0 to len - 1
        if i <= bar_index
//             ofpi_raw += nz(net_aggr_vol[i])
//             total_vol += nz(volume[i])
    ofpi = total_vol != 0 ? ofpi_raw / total_vol : 0
    e1 = ta.ema(ofpi, t3_len)
    e2 = ta.ema(e1, t3_len)
    e3 = ta.ema(e2, t3_len)
    e4 = ta.ema(e3, t3_len)
    e5 = ta.ema(e4, t3_len)
    e6 = ta.ema(e5, t3_len)
    t3_c1 = -t3_vf * t3_vf * t3_vf
    t3_c2 = 3 * t3_vf * t3_vf + 3 * t3_vf * t3_vf * t3_vf
    t3_c3 = -6 * t3_vf * t3_vf - 3 * t3_vf - 3 * t3_vf * t3_vf * t3_vf
    t3_c4 = 1 + 3 * t3_vf + t3_vf * t3_vf * t3_vf + 3 * t3_vf * t3_vf
//     t3_c1 * e6 + t3_c2 * e5 + t3_c3 * e4 + t3_c4 * e3

// detect_momentum_shift(ofpi_current, ofpi_prev1, ofpi_prev2) => (ofpi_prev1 > ofpi_prev2 and ofpi_current < ofpi_prev1) or (ofpi_prev1 < ofpi_prev2 and ofpi_current > ofpi_prev1)

ofpi_value = calculate_ofpi(ofpi_length, ofpi_t3_length, ofpi_t3_vfactor)
momentum_shifting = detect_momentum_shift(ofpi_value, ofpi_value[1], ofpi_value[2])

//==============================================================================
// CORE LOGIC & CALCULATIONS
//==============================================================================
// type LanglandsState
//     float L_value
//     float normalized_L
//     float frobenius_trace
//     float galois_rank
//     float correspondence_error
//     float trend_alignment
//     float htf_trend

// type OperadicStrategy
//     string name
//     float signal
//     float confidence
//     float weight

frobenius_corr = ta.correlation(close, volume, math.min(frobenius_lookback, bar_index+1))
galois_rank_val = ta.percentrank(ta.atr(14), math.min(frobenius_lookback, bar_index+1)) / 100
sma50_val = ta.sma(close, 50)

// calculate_langlands_state(lookback_period, frobenius_corr, galois_rank_val, sma50_val) =>
    if bar_index < 20
//         LanglandsState.new(0, 0, 0, 0, 0, 0, 0)
//     else
        state = LanglandsState.new()
        L_sum = 0.0
        weight_sum = 0.0
        max_n = math.min(lookback_period, bar_index, max_mobius_n)
        for n = 1 to max_n
            if n <= bar_index
                return_val = (close[n-1] - close[n]) / close[n]
                mob = array.get(mobius_arr, n)
                weight = mob / math.pow(n, l_function_precision)
//                 L_sum += return_val * weight * 100
//                 weight_sum += math.abs(weight)
//         state.L_value := weight_sum > 0 ? L_sum / weight_sum : 0.001
        x = state.L_value
//         state.normalized_L := tanh(x)
//         state.frobenius_trace := frobenius_corr
//         state.galois_rank := galois_rank_val
//         state.correspondence_error := math.abs(state.normalized_L - nz(frobenius_corr))
//         state.trend_alignment := close > sma50_val ? 1 : close < sma50_val ? -1 : 0
//         state.htf_trend := htf_trend
//         state

// create_base_strategies() =>
    strats = array.new<OperadicStrategy>()
    rsi_val = ta.rsi(close, 14)
//     array.push(strats, OperadicStrategy.new("Momentum", (rsi_val - 50) / 50, math.abs(rsi_val - 50) / 50, 1.0))
    bb_middle = ta.sma(close, 20)
    bb_width = ta.stdev(close, 20) * 2
//     array.push(strats, OperadicStrategy.new("Reversion", -(close - bb_middle) / bb_width, math.abs((close - bb_middle) / bb_width), 1.0))
    ofpi_signal = momentum_shifting ? ofpi_value * 1.5 : ofpi_value
    ofpi_confidence = momentum_shifting ? math.min(1.0, math.abs(ofpi_value) * 1.3) : math.abs(ofpi_value)
//     array.push(strats, OperadicStrategy.new("Order Flow", ofpi_signal, ofpi_confidence, 1.2))
    [pdi, mdi, adx_val] = ta.dmi(14, 14)
//     array.push(strats, OperadicStrategy.new("Trend", (adx_val - 25) / 25, math.abs(adx_val - 25) / 25, 1.0))
    htf_rsi_norm = (htf_rsi - 50) / 50
//     array.push(strats, OperadicStrategy.new("HTF Momentum", htf_rsi_norm, math.abs(htf_rsi_norm), 1.0))
    final_strats = array.new<OperadicStrategy>()
    num_to_take = math.min(array.size(strats), composition_arity)
    for i = 0 to num_to_take - 1
//         array.push(final_strats, array.get(strats, i))
//     final_strats

// category_agreement(strategies, required) =>
    up = 0
    down = 0
    for i = 0 to array.size(strategies) - 1
        s = array.get(strategies, i)
        if s.signal > 0.2
//             up += 1
        if s.signal < -0.2
//             down += 1
//     up >= required ? 1 : down >= required ? -1 : 0

// compose_strategies(strategies, langlands_state) =>
    total_signal = 0.0
    total_weight = 0.0
    for i = 0 to array.size(strategies) - 1
        s = array.get(strategies, i)
        w = s.confidence
//         total_signal += s.signal * w
//         total_weight += w
    base_signal = total_weight > 0 ? total_signal / total_weight : 0
    final_signal = base_signal * (1 + langlands_state.trend_alignment * swiss_cheese_weight) * (1 + langlands_state.htf_trend * swiss_cheese_weight)
//     math.max(-1, math.min(1, final_signal))

// calculate_unified_score(lang_state, composite_signal) =>
    l_score = lang_state.normalized_L
    market_stress = ta.atr(14) > ta.sma(ta.atr(14), 20) * 1.2
    g_score = market_stress ? -lang_state.galois_rank : lang_state.galois_rank
    if lang_state.htf_trend < 0
//         g_score := -math.abs(g_score)
    o_score = composite_signal
    c_base = 1 - lang_state.correspondence_error
    c_score = c_base * math.sign(o_score)
    total_score = l_score * l_function_weight + g_score * galois_weight + o_score * operadic_weight + c_score * correspondence_weight
    if total_score < 0
//         total_score := total_score * 2.5
    if ofpi_value < -0.1 and total_score < 0
//         total_score := total_score * 1.3
//     total_score := math.max(-1, math.min(1, total_score))
    total_score_display = total_score * 10

//==============================================================================
// ENHANCED SIGNAL LOGIC WITH BALANCED LONG/SHORT GENERATION
//==============================================================================
var int continuation_count = 0

atr14 = ta.atr(14)
modular_level_capped = math.min(modular_level, max_mobius_n)
lang_state = calculate_langlands_state(modular_level_capped, frobenius_corr, galois_rank_val, sma50_val)
base_strategies = create_base_strategies()
composite_signal = compose_strategies(base_strategies, lang_state)
agreement_direction = category_agreement(base_strategies, agreement_required)

// calculate_unified_score_asymmetric(lang_state, composite_signal) =>
    l_score = lang_state.normalized_L
    market_stress = ta.atr(14) > ta.sma(ta.atr(14), 20) * 1.2
    g_score = market_stress ? -lang_state.galois_rank : lang_state.galois_rank
    if lang_state.htf_trend < 0
//         g_score := -math.abs(g_score)
    o_score = composite_signal
    c_base = 1 - lang_state.correspondence_error
    c_score = c_base * math.sign(o_score)
    total_score = l_score * l_function_weight + g_score * galois_weight + o_score * operadic_weight + c_score * correspondence_weight
    
    // BALANCED AMPLIFICATION FOR LONGS
    if total_score > 0
//         total_score := total_score * 1.5 // Same base multiplier as shorts
        if not market_stress  // Longs prefer calm markets
//             total_score := total_score * 1.2
        if ofpi_value > 0.1  // Bullish order flow
//             total_score := total_score * 1.3
        if lang_state.htf_trend > 0  // Higher timeframe bullish
//             total_score := total_score * 1.15
    
    // KEEP ORIGINAL SHORT AMPLIFICATION
    if total_score < 0
//         total_score := total_score * 1.5
        if market_stress
//             total_score := total_score * 1.2
        if ofpi_value < -0.1
//             total_score := total_score * 1.3
        if lang_state.htf_trend < 0
//             total_score := total_score * 1.15
    
//     total_score := math.max(-1, math.min(1, total_score))
    total_score_display = total_score * 10
    components = array.from(l_score, g_score, o_score, c_score)
    mean_component = array.avg(components)
    variance_sum = 0.0
    for i = 0 to 3
//         variance_sum += math.pow(array.get(components, i) - mean_component, 2)
    agreement = math.sqrt(variance_sum / 4)
    signal_quality = agreement < 0.2 ? "EXCEPTIONAL" : agreement < 0.4 ? "STRONG" : agreement < 0.6 ? "MODERATE" : "WEAK"
    [total_score_display, signal_quality]

[total_score_display, signal_quality] = calculate_unified_score_asymmetric(lang_state, composite_signal)

volatility_ok = ta.atr(14) > ta.sma(ta.atr(14), 50) * 0.8 and htf_vol > ta.sma(htf_vol, 20) * 0.8
trend_ok = lang_state.trend_alignment != 0 or lang_state.htf_trend != 0
signal_ok = volatility_ok and trend_ok
can_signal = bar_index - last_signal_bar > 10
ofpi_threshold = 0.15
strong_bullish_flow = ofpi_value > ofpi_threshold
strong_bearish_flow = ofpi_value < -ofpi_threshold
flow_accelerating = math.abs(ofpi_value) > math.abs(ofpi_value[1])

// BALANCED THRESHOLDS - BOTH USE SAME MULTIPLIER
long_threshold = score_threshold * 0.6
short_threshold = score_threshold * 0.8

// Pattern Recognition
bearish_engulfing = close < open and close[1] > open[1] and open > close[1] and close < open[1]
three_black_crows = close < open and close[1] < open[1] and close[2] < open[2] and close < close[1] and close[1] < close[2]
evening_star = close[2] > open[2] and math.abs(close[1] - open[1]) < (high[1] - low[1]) * 0.3 and close < open and close < close[2]
bearish_pattern = bearish_engulfing or three_black_crows or evening_star

bullish_engulfing = close > open and close[1] < open[1] and open < close[1] and close > open[1]
morning_star = close[2] < open[2] and math.abs(close[1] - open[1]) < (high[1] - low[1]) * 0.3 and close > open and close > close[2]
three_white_soldiers = close > open and close[1] > open[1] and close[2] > open[2] and close > close[1] and close[1] > close[2]
bullish_pattern = bullish_engulfing or morning_star or three_white_soldiers

// BALANCED ENTRY CONDITIONS - PARALLEL STRUCTURE FOR BOTH
// Long entry - multiple paths like shorts have
long_entry = direction == 0 and can_signal and 
//              ((signal_ok and total_score_display > long_threshold and (agreement_direction == 1 or agreement_direction == 0)) or 
//               (strong_bullish_flow and composite_signal > 0.2) or 
//               (bullish_pattern and total_score_display > long_threshold * 0.5 and ofpi_value > 0) or 
//               (lang_state.htf_trend > 0 and momentum_shifting and ofpi_value > 0) or 
//               (ofpi_value > 0.3 and total_score_display > 0))

// Short entry - keep original structure
short_entry = direction == 0 and can_signal and 
//               ((signal_ok and total_score_display < -short_threshold and (agreement_direction == -1 or agreement_direction == 0)) or 
//                (strong_bearish_flow and composite_signal < -0.2) or 
//                (bearish_pattern and total_score_display < -short_threshold * 0.5 and ofpi_value < 0) or 
//                (lang_state.htf_trend < 0 and momentum_shifting and ofpi_value < 0) or 
//                (ofpi_value < -0.3 and total_score_display < 0))

exit_long = direction == 1 and (total_score_display < 1.0 or not signal_ok or (ofpi_value < -ofpi_threshold and flow_accelerating))
exit_short = direction == -1 and (total_score_display > -1.0 or not signal_ok or (ofpi_value > ofpi_threshold and flow_accelerating))

if long_entry
//     direction := 1
//     entry_price := close
//     continuation_count := 0
//     last_signal_bar := bar_index
//     total_signals += 1

if short_entry
//     direction := -1
//     entry_price := close
//     continuation_count := 0
//     last_signal_bar := bar_index
//     total_signals += 1

if exit_long
    if close > entry_price
//         winning_signals += 1
//     direction := 0
//     entry_price := na

if exit_short
    if close < entry_price
//         winning_signals += 1
//     direction := 0
//     entry_price := na

//==============================================================================
// VISUALS: MULTI-SCALE RESONANCE BANDS (Quantum Aura)
//==============================================================================
field_center = ta.ema(close, 5)
field_amplitude = ta.atr(14) * (1 + math.abs(total_score_display) / 10 * 1.5)
band1_upper = field_center + field_amplitude * 0.75
band1_lower = field_center - field_amplitude * 0.75
band2_upper = field_center + field_amplitude * 1.0
band2_lower = field_center - field_amplitude * 1.0
band3_upper = field_center + field_amplitude * 1.25
band3_lower = field_center - field_amplitude * 1.25
band4_upper = field_center + field_amplitude * 1.5
band4_lower = field_center - field_amplitude * 1.5
band5_upper = field_center + field_amplitude * 1.75
band5_lower = field_center - field_amplitude * 1.75
p1u = plot(band1_upper, color=color.new(c1, field_transparency + 2), linewidth=1, title="Band 1 Upper")
p1l = plot(band1_lower, color=color.new(c1, field_transparency + 2), linewidth=1, title="Band 1 Lower")
fill(p1u, p1l, color=color.new(c1, field_transparency + 2))
p2u = plot(band2_upper, color=color.new(c1, field_transparency + 6), linewidth=1, title="Band 2 Upper")
p2l = plot(band2_lower, color=color.new(c1, field_transparency + 6), linewidth=1, title="Band 2 Lower")
fill(p2u, p2l, color=color.new(c1, field_transparency + 6))
p3u = plot(band3_upper, color=color.new(c1, field_transparency + 10), linewidth=1, title="Band 3 Upper")
p3l = plot(band3_lower, color=color.new(c1, field_transparency + 10), linewidth=1, title="Band 3 Lower")
fill(p3u, p3l, color=color.new(c1, field_transparency + 10))
p4u = plot(band4_upper, color=color.new(c1, field_transparency + 14), linewidth=1, title="Band 4 Upper")
p4l = plot(band4_lower, color=color.new(c1, field_transparency + 14), linewidth=1, title="Band 4 Lower")
fill(p4u, p4l, color=color.new(c1, field_transparency + 14))
p5u = plot(band5_upper, color=color.new(c1, field_transparency + 18), linewidth=1, title="Band 5 Upper")
p5l = plot(band5_lower, color=color.new(c1, field_transparency + 18), linewidth=1, title="Band 5 Lower")
fill(p5u, p5l, color=color.new(c1, field_transparency + 18))

//==============================================================================
// REGIME INTENSITY HEATMAP BACKGROUND
//==============================================================================
var color final_bg_color = na 

// Function to get purple/black/gray background colors based on theme
// get_background_colors() =>
    if visual_theme == "Holographic"
//         array.from(color.new(#8b00ff, 85), color.new(#4b0082, 88), color.new(#2d004d, 91), color.new(#1a0033, 94), color.new(#0d001a, 96), color.new(#000000, 97))
//     else if visual_theme == "Crystalline"
//         array.from(color.new(#9370db, 85), color.new(#6a5acd, 88), color.new(#483d8b, 91), color.new(#2e2b5f, 94), color.new(#1a1a2e, 96), color.new(#0f0f1e, 97))
//     else if visual_theme == "Plasma"
//         array.from(color.new(#da70d6, 85), color.new(#ba55d3, 88), color.new(#8b008b, 91), color.new(#4b0051, 94), color.new(#2d0033, 96), color.new(#1a001f, 97))
//     else if visual_theme == "Cosmic Neon"
//         array.from(color.new(#ff00ff, 85), color.new(#cc00cc, 88), color.new(#990099, 91), color.new(#660066, 94), color.new(#330033, 96), color.new(#1a001a, 97))
//     else // Quantum (default)
//         array.from(color.new(#9400d3, 85), color.new(#7b00b0, 88), color.new(#5e0087, 91), color.new(#40005e, 94), color.new(#2d0042, 96), color.new(#1a0026, 97))

if show_aether_flow
    trend_strength = math.abs(lang_state.trend_alignment + lang_state.htf_trend) / 2
    momentum_strength = math.abs(ofpi_value)
    volatility_regime = ta.atr(14) / ta.sma(ta.atr(14), 50)
    score_intensity = math.min(math.abs(total_score_display) / 10, 1)
    
    regime_intensity = (trend_strength + momentum_strength + volatility_regime + score_intensity) / 4
    
    // Get theme-specific background colors
    var bg_colors_array = get_background_colors()
    
    // Select color based on intensity (single line)
    bg_color = regime_intensity > 0.8 ? array.get(bg_colors_array, 0) : regime_intensity > 0.6 ? array.get(bg_colors_array, 1) : regime_intensity > 0.4 ? array.get(bg_colors_array, 2) : regime_intensity > 0.3 ? array.get(bg_colors_array, 3) : regime_intensity > 0.2 ? array.get(bg_colors_array, 4) : array.get(bg_colors_array, 5)
    
    // Additional dimming for neutral market conditions
    if math.abs(total_score_display) < 2.0
//         bg_color := color.new(color.black, 95 + int(regime_intensity * 3))
    
//     final_bg_color := bg_color
// else
//     final_bg_color := na

bgcolor(final_bg_color, title="Regime Intensity Heatmap")

//==============================================================================
// PORTAL EFFECT: TWO LAYERED CIRCLES WITH DIRECTIONAL COLORS
//==============================================================================
if show_morphism_flow
    composite_morphism_strength = math.abs(composite_signal)
    flow_strength = math.max(0.3, composite_morphism_strength)
    for i = 1 to type_recursion_depth
        if bar_index > i and i % 2 == 0
            y = (close + close[i]) / 2
            is_bearish = total_score_display < 0
            signal_strength = math.abs(total_score_display) / 10
            portal_outer = color.new(#000000, 100)
            portal_inner = color.new(#000000, 100)
            if visual_theme == "Quantum"
//                 portal_outer := is_bearish ? color.new(#ff0040, 40) : color.new(#00ff88, 40)
//                 portal_inner := is_bearish ? color.new(#ffaa00, 10) : color.new(#00ffff, 10)
//             else if visual_theme == "Holographic"
//                 portal_outer := is_bearish ? color.new(#ff0066, 40) : color.new(#00ffff, 40)
//                 portal_inner := is_bearish ? color.new(#ffff00, 10) : color.new(#00ff00, 10)
//             else if visual_theme == "Crystalline" 
//                 portal_outer := is_bearish ? color.new(#da70d6, 40) : color.new(#00ced1, 40)
//                 portal_inner := is_bearish ? color.new(#ff69b4, 10) : color.new(#7fffd4, 10)
//             else if visual_theme == "Plasma"
//                 portal_outer := is_bearish ? color.new(#dc143c, 40) : color.new(#ffd700, 40)
//                 portal_inner := is_bearish ? color.new(#ff1493, 10) : color.new(#ffff00, 10)
//             else if visual_theme == "Cosmic Neon"
//                 portal_outer := is_bearish ? color.new(#ff073a, 40) : color.new(#39ff14, 40)
//                 portal_inner := is_bearish ? color.new(#00f9ff, 10) : color.new(#ff40e0, 10)
//             else
//                 portal_outer := is_bearish ? color.new(#ff0000, 40) : color.new(#00ff00, 40)
//                 portal_inner := is_bearish ? color.new(#ff8800, 10) : color.new(#00ffff, 10)
//             label.new(bar_index - i, y, "â—", color=portal_outer, textcolor=portal_outer, style=label.style_none, size=size.small)
//             label.new(bar_index - i, y, "â—", color=portal_inner, textcolor=portal_inner, style=label.style_none, size=size.tiny)

//==============================================================================
// WICK PRESSURE LINES (UNIQUE PURPLE TONES)
//==============================================================================
atr = ta.atr(14)
if show_wick_pressure and atr > 0
    upperWick = high - math.max(open, close)
    lowerWick = math.min(open, close) - low
    body = math.abs(close - open)
    for i = 1 to math.min(glowIntensity, 5)
        if bar_index > i
            if upperWick[i] > body[i] * 0.5
                wickAlpha = 20 + i * 8
                wickColor = color.new(primaryBear, wickAlpha)
                wickWidth = math.max(1, glowIntensity - i)
//                 line.new(bar_index - i, high[i], bar_index, high - (atr * 0.1), color=wickColor, width=wickWidth, style=line.style_dotted)
            if lowerWick[i] > body[i] * 0.5
                wickAlpha = 20 + i * 8
                wickColor = color.new(primaryBull, wickAlpha)
                wickWidth = math.max(1, glowIntensity - i)
//                 line.new(bar_index - i, low[i], bar_index, low + (atr * 0.1), color=wickColor, width=wickWidth, style=line.style_dotted)

//==============================================================================
// FRACTAL GRID: Neon Shadow + Dotted Highlight, Theme-Matched
//==============================================================================
// CORRECTED: Replaced invalid [...] array creation with array.from()
// get_fractal_line_colors() => visual_theme == "Holographic" ? array.from(color.new(#00ffff, 0), color.new(#00ffff, 80), color.new(#ff00ff, 0), color.new(#ff00ff, 80)) : visual_theme == "Crystalline" ? array.from(color.new(#00ced1, 0), color.new(#00ced1, 80), color.new(#9370db, 0), color.new(#9370db, 80)) : visual_theme == "Plasma" ? array.from(color.new(#ffd700, 0), color.new(#ffd700, 80), color.new(#ff1493, 0), color.new(#ff1493, 80)) : visual_theme == "Cosmic Neon" ? array.from(color.new(#39ff14, 0), color.new(#39ff14, 80), color.new(#ff073a, 0), color.new(#ff073a, 80)) : array.from(color.new(#00ff00, 0), color.new(#00ff00, 80), color.new(#ff0000, 0), color.new(#ff0000, 80))

// Using the safe assignment method
var fractal_line_array = get_fractal_line_colors()
// color fractalHighBase = array.get(fractal_line_array, 0)
// color fractalHighDark = array.get(fractal_line_array, 1)
// color fractalLowBase = array.get(fractal_line_array, 2)
// color fractalLowDark = array.get(fractal_line_array, 3)

fractalHighs = array.from(ta.highest(high, 10), ta.highest(high, 20), ta.highest(high, 30), ta.highest(high, 40), ta.highest(high, 50))
fractalLows  = array.from(ta.lowest(low, 10),  ta.lowest(low, 20),  ta.lowest(low, 30),  ta.lowest(low, 40),  ta.lowest(low, 50))
var array<line> fractalHighGlowLines = array.new<line>()
var array<line> fractalHighHighlightLines = array.new<line>()
var array<line> fractalLowGlowLines = array.new<line>()
var array<line> fractalLowHighlightLines = array.new<line>()
var array<label> fractalHighLabels = array.new<label>()
var array<label> fractalLowLabels = array.new<label>()

if showFractalGrid and barstate.isrealtime
    for l in fractalHighGlowLines
//         line.delete(l)
    for l in fractalHighHighlightLines
//         line.delete(l)
    for l in fractalLowGlowLines
//         line.delete(l)
    for l in fractalLowHighlightLines
//         line.delete(l)
    for lbl in fractalHighLabels
//         label.delete(lbl)
    for lbl in fractalLowLabels
//         label.delete(lbl)
//     array.clear(fractalHighGlowLines)
//     array.clear(fractalHighHighlightLines)
//     array.clear(fractalLowGlowLines)
//     array.clear(fractalLowHighlightLines)
//     array.clear(fractalHighLabels)
//     array.clear(fractalLowLabels)
    for i = 0 to 4
        glowAlpha = 70 + i * 8
        highlightAlpha = 40 + i * 8
        hi = array.get(fractalHighs, i)
        if not na(hi)
//             array.push(fractalHighGlowLines, line.new(bar_index - 14, hi, bar_index + 30, hi, color=color.new(fractalHighBase, glowAlpha), width=3, style=line.style_solid))
//             array.push(fractalHighHighlightLines, line.new(bar_index - 15, hi, bar_index + 30, hi, color=color.new(fractalHighDark, highlightAlpha), width=1, style=line.style_dotted))
        lo = array.get(fractalLows, i)
        if not na(lo)
//             array.push(fractalLowGlowLines, line.new(bar_index - 14, lo, bar_index + 30, lo, color=color.new(fractalLowBase, glowAlpha), width=3, style=line.style_solid))
//             array.push(fractalLowHighlightLines, line.new(bar_index - 15, lo, bar_index + 30, lo, color=color.new(fractalLowDark, highlightAlpha), width=1, style=line.style_dotted))
    lookback_periods = array.from(10, 20, 30, 40, 50)
    used_positions = array.new<float>()
    min_spacing = atr14 * 0.15
    for i = 0 to 4
        hi = array.get(fractalHighs, i)
        lo = array.get(fractalLows, i)
        period = array.get(lookback_periods, i)
        if not na(hi)
            can_place = true
            if array.size(used_positions) > 0
                for j = 0 to array.size(used_positions) - 1
                    if math.abs(hi - array.get(used_positions, j)) < min_spacing
//                         can_place := false
//                         break
            if can_place
                price_impact = (hi - close) / atr14
                estimated_score = total_score_display - (price_impact * 3)
                hi_label_text = "R" + str.tostring(period) + ": " + str.tostring(hi, "#.##") + " | L-Score: " + str.tostring(estimated_score, "#.#")
                new_label = label.new(bar_index + 30, hi, hi_label_text, color=color.new(fractalHighBase, 85), textcolor=fractalHighBase, style=label.style_label_left, size=size.tiny)
//                 array.push(fractalHighLabels, new_label)
//                 array.push(used_positions, hi)
        if not na(lo)
            can_place = true
            if array.size(used_positions) > 0
                for j = 0 to array.size(used_positions) - 1
                    if math.abs(lo - array.get(used_positions, j)) < min_spacing
//                         can_place := false
//                         break
            if can_place
                price_impact = (close - lo) / atr14
                estimated_score = total_score_display + (price_impact * 3)
                lo_label_text = "S" + str.tostring(period) + ": " + str.tostring(lo, "#.##") + " | L-Score: " + str.tostring(estimated_score, "#.#")
                new_label = label.new(bar_index + 30, lo, lo_label_text, color=color.new(fractalLowBase, 85), textcolor=fractalLowBase, style=label.style_label_left, size=size.tiny)
//                 array.push(fractalLowLabels, new_label)
//                 array.push(used_positions, lo)
//==============================================================================
// SIGNAL LABELS (LONG/SHORT) 
//==============================================================================
plotshape(show_signal_portals and long_entry, style=shape.triangleup, location=location.belowbar, color=color.new(c4, 0), size=size.small, offset=1, title="Long Entry")
plotshape(show_signal_portals and short_entry, style=shape.triangledown, location=location.abovebar, color=color.new(c5, 0), size=size.small, offset=1, title="Short Entry")
//==============================================================================
// ENHANCED DASHBOARD WITH COMPLETE OFPI INTEGRATION
//==============================================================================
var table dashboard = na
if show_dashboard and barstate.islast
    // Dashboard positioning and sizing
    dashboard_pos = dashboard_position_input == "Top Left" ? position.top_left : dashboard_position_input == "Top Right" ? position.top_right : dashboard_position_input == "Bottom Left" ? position.bottom_left : position.bottom_right
    cols = dashboard_size == "Large" ? 5 : 4
    rows = dashboard_size == "Large" ? 25 : dashboard_size == "Normal" ? 22 : 16

    // Clean up existing dashboard
    if not na(dashboard)
//         table.delete(dashboard)
    
    // Create new dashboard
//     dashboard := table.new(dashboard_pos, cols, rows, border_width = 1, border_color = color.new(c_neutral, 50), bgcolor = color.new(#1e222d, 20))
    
    // Color scheme
    dc_white = color.white
    dc_gray = #B2B5BE
    dc_green = #26A69A
    dc_red = #EF5350
    dc_gold = #FFD700
    dc_purple = c1
    dc_aqua = c3
    dc_orange = #FF8C00
    dc_cyan = #00FFFF
    bg_header = color.new(color.black, 30)
    bg_section = color.new(color.gray, 85)
    
    // Text sizing
    header_size = dashboard_size == "Large" ? size.normal : size.small
    value_size = dashboard_size == "Large" ? size.normal : size.small
    label_size = dashboard_size == "Large" ? size.small : size.tiny
    
    current_row = 0
    
    // â•â•â• MAIN HEADER â•â•â•
//     table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
//     table.cell(dashboard, 0, current_row, "ðŸ›¸ Langlands-Operadic MÃ¶bius Vortex | " + syminfo.ticker, text_halign=text.align_center, text_color=dc_white, bgcolor=bg_header, text_size=header_size)
//     current_row += 1
    
    // Warning for modular level cap
    if show_warning
//         table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
//         table.cell(dashboard, 0, current_row, "âš ï¸ Modular Level capped at " + str.tostring(max_mobius_n) + " for performance", text_color=dc_red, text_size=label_size)
//         current_row += 1
    
    // â•â•â• UNIFIED AI SCORE SECTION â•â•â•
//     table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
//     table.cell(dashboard, 0, current_row, "â•â•â• ðŸŽ¯ UNIFIED AI SCORE â•â•â•", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
//     current_row += 1
    
    // Total Score
//     table.cell(dashboard, 0, current_row, "TOTAL SCORE", text_color=dc_gray, text_size=label_size)
//     table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
    score_color = signal_quality == "EXCEPTIONAL" ? dc_gold : signal_quality == "STRONG" ? dc_green : signal_quality == "MODERATE" ? dc_aqua : dc_gray
//     table.cell(dashboard, 1, current_row, str.tostring(-total_score_display, "#.##"), text_halign=text.align_right, text_color=score_color, text_size=value_size)
//     current_row += 1
    
    // Signal Quality
//     table.cell(dashboard, 0, current_row, "Quality", text_color=dc_gray, text_size=label_size)
//     table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
    quality_emoji = signal_quality == "EXCEPTIONAL" ? "ðŸŒŸ" : signal_quality == "STRONG" ? "ðŸ’ª" : signal_quality == "MODERATE" ? "ðŸ‘" : "âš ï¸"
//     table.cell(dashboard, 1, current_row, quality_emoji + " " + signal_quality, text_halign=text.align_right, text_color=score_color, text_size=value_size)
//     current_row += 1
    
    // Component Contributions (Normal and Large only)
    if dashboard_size != "Small"
//         table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
//         table.cell(dashboard, 0, current_row, "ðŸ“Š Component Analysis", text_halign=text.align_center, text_color=dc_aqua, text_size=label_size)
//         current_row += 1
        
        // L-Function & Galois
//         table.cell(dashboard, 0, current_row, "L-Function", text_color=dc_gray, text_size=label_size)
        l_func_color = math.abs(lang_state.L_value) > 1.0 ? dc_purple : dc_gray
//         table.cell(dashboard, 1, current_row, str.tostring(lang_state.L_value, "#.###"), text_halign=text.align_right, text_color=l_func_color, text_size=label_size)
//         table.cell(dashboard, 2, current_row, "Galois", text_color=dc_gray, text_size=label_size)
        galois_color = lang_state.galois_rank > 0.7 ? dc_red : lang_state.galois_rank > 0.3 ? dc_orange : dc_green
//         table.cell(dashboard, 3, current_row, str.tostring(lang_state.galois_rank, "#.##"), text_halign=text.align_right, text_color=galois_color, text_size=label_size)
//         current_row += 1
        
        // Operadic & Correspondence
//         table.cell(dashboard, 0, current_row, "Operadic", text_color=dc_gray, text_size=label_size)
        operadic_color = composite_signal > 0.3 ? dc_green : composite_signal < -0.3 ? dc_red : dc_gray
//         table.cell(dashboard, 1, current_row, str.tostring(composite_signal, "#.##"), text_halign=text.align_right, text_color=operadic_color, text_size=label_size)
//         table.cell(dashboard, 2, current_row, "Corr.", text_color=dc_gray, text_size=label_size)
        corr_value = 1 - lang_state.correspondence_error
        corr_color = corr_value > 0.7 ? dc_green : corr_value > 0.4 ? dc_orange : dc_red
//         table.cell(dashboard, 3, current_row, str.tostring(corr_value, "#.##"), text_halign=text.align_right, text_color=corr_color, text_size=label_size)
//         current_row += 1
    
    // â•â•â• ORDER FLOW ANALYSIS SECTION â•â•â•
//     table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
//     table.cell(dashboard, 0, current_row, "â•â•â• ðŸ“Š ORDER FLOW ANALYSIS â•â•â•", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
//     current_row += 1
    
    // OFPI Value and Visual Gauge
    ofpi_display = ofpi_value * 100
    gauge_bars = int(math.abs(ofpi_display) / 10)
//     gauge_bars := math.min(gauge_bars, 10)
    gauge_str = ofpi_value > 0 ? "â–°" + str.repeat("â–ˆ", gauge_bars) + str.repeat("â–‘", 10 - gauge_bars) : str.repeat("â–‘", 10 - gauge_bars) + str.repeat("â–ˆ", gauge_bars) + "â–°"
    
//     table.cell(dashboard, 0, current_row, "OFPI", text_color=dc_gray, text_size=label_size)
    ofpi_color = ofpi_value > 0.15 ? dc_green : ofpi_value < -0.15 ? dc_red : dc_gray
//     table.cell(dashboard, 1, current_row, str.tostring(ofpi_display, "#.#") + "%", text_halign=text.align_right, text_color=ofpi_color, text_size=value_size)
    
    if dashboard_size == "Large"
//         table.cell(dashboard, 2, current_row, "Flow", text_color=dc_gray, text_size=label_size)
//         table.cell(dashboard, 3, current_row, gauge_str, text_halign=text.align_right, text_color=ofpi_value > 0 ? dc_green : dc_red, text_size=label_size)
//     else
//         table.merge_cells(dashboard, 2, current_row, cols - 1, current_row)
//         table.cell(dashboard, 2, current_row, gauge_str, text_halign=text.align_right, text_color=ofpi_value > 0 ? dc_green : dc_red, text_size=label_size)
//     current_row += 1
    
    // Flow Momentum Status
//     flow_accelerating := math.abs(ofpi_value) > math.abs(ofpi_value[1])
    momentum_status = momentum_shifting ? "ðŸ”„ SHIFTING" : flow_accelerating ? "ðŸ“ˆ ACCELERATING" : math.abs(ofpi_value) > 0.5 ? "ðŸ’ª STRONG" : math.abs(ofpi_value) > 0.2 ? "ðŸ“Š MODERATE" : "ðŸ˜´ WEAK"
    momentum_color = momentum_shifting ? dc_gold : flow_accelerating ? dc_aqua : math.abs(ofpi_value) > 0.3 ? dc_green : dc_gray
    
//     table.cell(dashboard, 0, current_row, "Momentum", text_color=dc_gray, text_size=label_size)
//     table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
//     table.cell(dashboard, 1, current_row, momentum_status, text_halign=text.align_right, text_color=momentum_color, text_size=value_size)
//     current_row += 1
    
    // OFPI Configuration Details (Large dashboard only)
    if dashboard_size == "Large"
//         table.cell(dashboard, 0, current_row, "OFPI Config", text_color=dc_gray, text_size=label_size)
//         table.cell(dashboard, 1, current_row, "Len:" + str.tostring(ofpi_length), text_color=dc_cyan, text_size=label_size)
//         table.cell(dashboard, 2, current_row, "T3:" + str.tostring(ofpi_t3_length), text_color=dc_cyan, text_size=label_size)
//         table.cell(dashboard, 3, current_row, "VF:" + str.tostring(ofpi_t3_vfactor, "#.#"), text_color=dc_cyan, text_size=label_size)
//         current_row += 1
    
    // â•â•â• SIGNAL PERFORMANCE SECTION â•â•â•
//     table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
//     table.cell(dashboard, 0, current_row, "â•â•â• ðŸ† SIGNAL PERFORMANCE â•â•â•", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
//     current_row += 1
    
    // Win Rate and Signal Count
    win_rate = total_signals > 0 ? (winning_signals / total_signals) * 100 : 0.0
    win_rate_color = win_rate >= 60 ? dc_green : win_rate >= 45 ? dc_orange : dc_red
    win_rate_emoji = win_rate >= 60 ? "ðŸ”¥" : win_rate >= 45 ? "ðŸ‘" : "âš ï¸"
    
//     table.cell(dashboard, 0, current_row, "Win Rate", text_color=dc_gray, text_size=label_size)
//     table.cell(dashboard, 1, current_row, win_rate_emoji + str.tostring(win_rate, "#.#") + "%", text_halign=text.align_right, text_color=win_rate_color, text_size=label_size)
//     table.cell(dashboard, 2, current_row, "Signals", text_color=dc_gray, text_size=label_size)
//     table.cell(dashboard, 3, current_row, str.tostring(total_signals), text_halign=text.align_right, text_color=dc_gray, text_size=label_size)
//     current_row += 1
    
    // Current Position and Volatility
//     table.cell(dashboard, 0, current_row, "Position", text_color=dc_gray, text_size=label_size)
    position_text = direction == 1 ? "ðŸŸ¢ LONG" : direction == -1 ? "ðŸ”´ SHORT" : "âšª NONE"
    position_color = direction == 1 ? dc_green : direction == -1 ? dc_red : dc_gray
//     table.cell(dashboard, 1, current_row, position_text, text_color=position_color, text_size=value_size)
    
    // Volatility Regime
//     table.cell(dashboard, 2, current_row, "Vol Regime", text_color=dc_gray, text_size=label_size)
    vol_text = volatility_percentile > 70 ? "ðŸ”¥ HIGH" : volatility_percentile > 30 ? "ðŸ“Š MED" : "ðŸ˜´ LOW"
    vol_color = volatility_percentile > 70 ? dc_red : volatility_percentile > 30 ? dc_gold : dc_green
//     table.cell(dashboard, 3, current_row, vol_text, text_color=vol_color, text_size=value_size)
//     current_row += 1
    
    // â•â•â• MARKET STRUCTURE SECTION â•â•â• (Normal and Large only)
    if dashboard_size != "Small"
//         table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
//         table.cell(dashboard, 0, current_row, "â•â•â• ðŸŒŒ MARKET STRUCTURE â•â•â•", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
//         current_row += 1
        
        // MÃ¶bius Field Strength Calculation
        mobius_field_strength_calc = 0.0
        field_oscillations = 0
        for n = 1 to math.min(20, max_mobius_n)
            mob_val = array.get(mobius_arr, n)
            price_cycle = math.sin(2 * 3.14159 * bar_index / n)
            contribution = mob_val * price_cycle * (1 / n)
//             mobius_field_strength_calc += contribution
            if n > 1 and mob_val != array.get(mobius_arr, n-1)
//                 field_oscillations += 1
//         mobius_field_strength_calc := math.abs(mobius_field_strength_calc) * field_oscillations
        
//         table.cell(dashboard, 0, current_row, "MÃ¶bius Field", text_color=dc_gray, text_size=label_size)
        field_str = mobius_field_strength_calc > 2.0 ? "ðŸŒªï¸ CHAOTIC" : mobius_field_strength_calc > 1.0 ? "âš¡ STRONG" : mobius_field_strength_calc > 0.5 ? "ðŸ“Š MODERATE" : "ðŸ˜´ WEAK"
        field_color = mobius_field_strength_calc > 2.0 ? dc_red : mobius_field_strength_calc > 1.0 ? dc_gold : mobius_field_strength_calc > 0.5 ? dc_purple : dc_gray
//         table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
//         table.cell(dashboard, 1, current_row, field_str, text_halign=text.align_right, text_color=field_color, text_size=label_size)
//         current_row += 1
        
        // HTF Trend and Agreement
//         table.cell(dashboard, 0, current_row, "HTF Trend", text_color=dc_gray, text_size=label_size)
        htf_text = lang_state.htf_trend > 0 ? "ðŸ“ˆ BULL" : lang_state.htf_trend < 0 ? "ðŸ“‰ BEAR" : "âž¡ï¸ NEUTRAL"
        htf_color = lang_state.htf_trend > 0 ? dc_green : lang_state.htf_trend < 0 ? dc_red : dc_gray
//         table.cell(dashboard, 1, current_row, htf_text, text_color=htf_color, text_size=label_size)
        
//         table.cell(dashboard, 2, current_row, "Agreement", text_color=dc_gray, text_size=label_size)
        agreement_text = agreement_direction == 1 ? "ðŸ¤ BULL" : agreement_direction == -1 ? "ðŸ¤ BEAR" : "ðŸ¤· MIXED"
        agreement_color = agreement_direction == 1 ? dc_green : agreement_direction == -1 ? dc_red : dc_orange
//         table.cell(dashboard, 3, current_row, agreement_text, text_color=agreement_color, text_size=label_size)
//         current_row += 1
    
    // â•â•â• POSITION DETAILS SECTION â•â•â• (When in position)
    if direction != 0 and dashboard_size != "Small"
//         table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
//         table.cell(dashboard, 0, current_row, "â•â•â• ðŸ’¼ POSITION DETAILS â•â•â•", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
//         current_row += 1
        
        // Entry Price and Current P&L
//         table.cell(dashboard, 0, current_row, "Entry", text_color=dc_gray, text_size=label_size)
//         table.cell(dashboard, 1, current_row, str.tostring(entry_price, "#.##"), text_halign=text.align_right, text_color=dc_white, text_size=label_size)
        
        pnl = direction == 1 ? ((close - entry_price) / entry_price) * 100 : ((entry_price - close) / entry_price) * 100
        pnl_emoji = pnl > 2 ? "ðŸš€" : pnl > 0 ? "ðŸ’š" : pnl > -2 ? "âš ï¸" : "ðŸ”´"
//         table.cell(dashboard, 2, current_row, "P&L", text_color=dc_gray, text_size=label_size)
//         table.cell(dashboard, 3, current_row, pnl_emoji + str.tostring(pnl, "#.##") + "%", text_halign=text.align_right, text_color=pnl > 0 ? dc_green : dc_red, text_size=label_size)
//         current_row += 1
        
        // Position Risk and Duration
        if dashboard_size == "Large"
//             table.cell(dashboard, 0, current_row, "Risk Level", text_color=dc_gray, text_size=label_size)
            risk_level = math.abs(pnl) > 5 ? "ðŸ”¥ HIGH" : math.abs(pnl) > 2 ? "âš ï¸ MED" : "âœ… LOW"
            risk_color = math.abs(pnl) > 5 ? dc_red : math.abs(pnl) > 2 ? dc_orange : dc_green
//             table.cell(dashboard, 1, current_row, risk_level, text_color=risk_color, text_size=label_size)
            
            bars_in_trade = bar_index - last_signal_bar
//             table.cell(dashboard, 2, current_row, "Duration", text_color=dc_gray, text_size=label_size)
//             table.cell(dashboard, 3, current_row, str.tostring(bars_in_trade) + " bars", text_color=dc_aqua, text_size=label_size)
//             current_row += 1
    
    // â•â•â• SETTINGS SUMMARY â•â•â• (Large dashboard only)
    if dashboard_size == "Large"
//         table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
//         table.cell(dashboard, 0, current_row, "â•â•â• âš™ï¸ ACTIVE SETTINGS â•â•â•", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
//         current_row += 1
        
        // Key parameter summary
//         table.cell(dashboard, 0, current_row, "Threshold", text_color=dc_gray, text_size=label_size)
//         table.cell(dashboard, 1, current_row, str.tostring(score_threshold, "#.#"), text_color=dc_cyan, text_size=label_size)
//         table.cell(dashboard, 2, current_row, "Arity", text_color=dc_gray, text_size=label_size)
//         table.cell(dashboard, 3, current_row, str.tostring(composition_arity), text_color=dc_cyan, text_size=label_size)
//         current_row += 1
        
//         table.cell(dashboard, 0, current_row, "Agreement", text_color=dc_gray, text_size=label_size)
//         table.cell(dashboard, 1, current_row, str.tostring(agreement_required), text_color=dc_cyan, text_size=label_size)
//         table.cell(dashboard, 2, current_row, "Theme", text_color=dc_gray, text_size=label_size)
//         table.cell(dashboard, 3, current_row, visual_theme, text_color=dc_purple, text_size=label_size)
//         current_row += 1
//==============================================================================
// ANIMATED WATERMARK
//==============================================================================
var table watermarkMain = table.new(position.bottom_center, 3, 1, bgcolor=color.new(color.black, 100), border_width=0)
var table watermarkGlow1 = table.new(position.bottom_center, 3, 1, bgcolor=color.new(color.black, 100), border_width=0)
var table watermarkGlow2 = table.new(position.bottom_center, 3, 1, bgcolor=color.new(color.black, 100), border_width=0)

var int animFrame = 0
var float glowAlphaWatermark = 80 

if barstate.isrealtime
//     animFrame := (animFrame + 1) % 100
//     glowAlphaWatermark := 70 + math.sin(animFrame * 0.1) * 20  
    
//     table.clear(watermarkMain, 0, 0)
//     table.clear(watermarkGlow1, 0, 0)
//     table.clear(watermarkGlow2, 0, 0)
    
    watermark_text_size = dashboard_size == "Large" ? size.normal : dashboard_size == "Normal" ? size.small : size.tiny
    
    watermarkColorBase = total_score_display > 0 ? color.rgb(100, 255, 100) : total_score_display < 0 ? color.rgb(255, 100, 100) : c1
    accent1 = c2
    
//     table.cell(watermarkGlow2, 0, 0, "âš¡", text_color=color.new(watermarkColorBase, math.round(glowAlphaWatermark) + 20), text_size=watermark_text_size, text_halign=text.align_center)
//     table.cell(watermarkGlow2, 1, 0, "Dskyz (DAFE) Quant Systems", text_color=color.new(watermarkColorBase, math.round(glowAlphaWatermark) + 20), text_size=watermark_text_size, text_halign=text.align_center)
//     table.cell(watermarkGlow2, 2, 0, "âš¡", text_color=color.new(watermarkColorBase, math.round(glowAlphaWatermark) + 20), text_size=watermark_text_size, text_halign=text.align_center)

//     table.cell(watermarkGlow1, 0, 0, "âš¡", text_color=color.new(accent1, math.round(glowAlphaWatermark)), text_size=watermark_text_size, text_halign=text.align_center) 
//     table.cell(watermarkGlow1, 1, 0, "Dskyz (DAFE) Quant Systems", text_color=color.new(accent1, math.round(glowAlphaWatermark)), text_size=watermark_text_size, text_halign=text.align_center)
//     table.cell(watermarkGlow1, 2, 0, "âš¡", text_color=color.new(accent1, math.round(glowAlphaWatermark)), text_size=watermark_text_size, text_halign=text.align_center)

    mainTextWatermark = "Dskyz (DAFE) Quant Systems"
//     table.cell(watermarkMain, 0, 0, animFrame % 20 < 10 ? "âš¡" : "âœ¦", text_color=watermarkColorBase, text_size=watermark_text_size, text_halign=text.align_center)
//     table.cell(watermarkMain, 1, 0, mainTextWatermark, text_color=watermarkColorBase, text_size=watermark_text_size, text_halign=text.align_center)
//     table.cell(watermarkMain, 2, 0, animFrame % 20 >= 10 ? "âš¡" : "âœ¦", text_color=watermarkColorBase, text_size=watermark_text_size, text_halign=text.align_center)