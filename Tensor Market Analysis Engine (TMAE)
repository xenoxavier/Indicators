Tensor Market Analysis Engine (TMAE)

//@version=5
indicator("Tensor Market Analysis Engine (TMAE)", shorttitle="ðŸ”¢ TMAE", overlay=true, max_bars_back=500, max_lines_count=500, max_labels_count=500)
//==============================================================================
// ðŸ“š COMPREHENSIVE USER GUIDE & MATHEMATICAL THEORY
//==============================================================================
// 
// ðŸ”¢ TMAE - THE ULTIMATE TENSOR MARKET ANALYSIS ENGINE
// 
// Welcome to the most sophisticated multi-dimensional market analysis framework,
// combining three revolutionary mathematical approaches into a unified trading system
// that adapts to market personality and provides unparalleled signal accuracy.
//
// âš¡ REVOLUTIONARY THREE-PILLAR APPROACH:
// 
// While traditional indicators use single-dimensional analysis, TMAE operates
// across multiple mathematical domains simultaneously:
//
// 1. MULTI-DIMENSIONAL VOLATILITY WITH JUMP DETECTION:
//    - Analyzes volatility across 2-5 dimensions (price, volume, range, correlation, microstructure)
//    - Uses Mahalanobis distance for outlier detection in volatility space
//    - Implements Hawkes process for self-exciting jump clustering
//    - Detects regime changes through dimensional analysis
//
// 2. HURST EXPONENT REGIME DETECTION:
//    - Calculates fractal dimension of price movements (0-1 scale)
//    - H > 0.6: Trending/Persistent regime (follow momentum)
//    - H < 0.4: Mean-reverting/Anti-persistent regime (fade extremes)
//    - H â‰ˆ 0.5: Random walk regime (breakout strategies)
//    - Adapts signal generation to current market personality
//
// 3. TRANSFER ENTROPY LEAD-LAG ANALYSIS:
//    - Measures information flow between price and volume
//    - Detects which variable is leading the relationship
//    - Quantifies predictive power and causality strength
//    - Identifies structural changes in market microstructure
//
// ðŸŽ¯ SIGNAL INTERPRETATION:
//
// COMPONENT SIGNALS (3 Maximum):
// â€¢ Volatility Signal: Multi-dimensional jump detection active
// â€¢ Hurst Signal: Regime-appropriate pattern detected
// â€¢ Entropy Signal: Significant information flow measured
//
// SIGNAL MODES:
// â€¢ Aggressive: 1+ components active (more signals, higher noise)
// â€¢ Confluence: 2+ components active (balanced approach)
// â€¢ Conservative: All 3 components active (fewer, highest quality signals)
//
// ðŸ“Š PERFORMANCE METRICS:
//
// REAL WIN RATE (0-100%):
// â€¢ Tracks actual entry-to-exit trade performance
// â€¢ Updates with each completed trade
// â€¢ Accounts for realistic exit conditions
//
// TENSOR FIELD STRENGTH:
// â€¢ Mahalanobis distance in volatility space
// â€¢ Values > threshold indicate anomalous conditions
// â€¢ Higher values = stronger signals but less frequent
//
// MARKET REGIME CLASSIFICATION:
// â€¢ Trending: Follow momentum, ride breakouts
// â€¢ Mean-Reverting: Fade extremes, buy dips/sell rips
// â€¢ Random: Wait for volatility compression then breakout
//
// ðŸ§® MATHEMATICAL COMPONENTS:
//
// VOLATILITY TENSOR: Multi-dimensional volatility state vector
// MAHALANOBIS METRIC: Distance measure in volatility space
// HAWKES INTENSITY: Self-exciting jump probability
// HURST EXPONENT: Fractal dimension (0.5 = random, >0.5 = trending, <0.5 = reverting)
// TRANSFER ENTROPY: Information flow measurement between variables
// REGIME CLASSIFIER: Adaptive signal generation based on market personality
//
// ðŸ’¡ TRADING STRATEGY:
//
// 1. SIGNAL GENERATION:
//    - Wait for 2+ components in Confluence mode
//    - Confirm with appropriate momentum direction
//    - Verify regime alignment (trending vs reverting)
//    - Check tensor field strength vs threshold
//
// 2. ENTRY EXECUTION:
//    - Strong signals (3/3 components): Enter immediately
//    - Moderate signals (2/3 components): Wait for pullback
//    - Weak signals (1/3 components): Avoid or reduce size
//
// 3. POSITION MANAGEMENT:
//    - Size based on component agreement strength
//    - Monitor regime changes for strategy adaptation
//    - Watch for tensor field weakening
//
// 4. EXIT STRATEGY:
//    - Component divergence (signals turning off)
//    - Regime change detection
//    - Time-based exits (prevent overholding)
//    - Profit/loss thresholds
//
// âš ï¸ RISK DISCLAIMER:
// Despite mathematical sophistication, markets exhibit:
// â€¢ Regime transition periods (temporary signal degradation)
// â€¢ Black swan events (extreme multidimensional jumps)
// â€¢ Structural breaks (parameter stability issues)
// Always use appropriate risk management and position sizing.
//==============================================================================
// ðŸŽ¯ UNIFIED CONFIGURATION
//==============================================================================
group_core = "ðŸ”¢ Core Parameters"
lookback_period = input.int(50, "Primary Analysis Window", minval=10, maxval=100, group=group_core, tooltip="ðŸŽ¯ MAIN LOOKBACK FOR ALL CALCULATIONS\n\nðŸ“Š Affects:\nâ€¢ Volatility calculation depth\nâ€¢ Hurst exponent accuracy\nâ€¢ Transfer entropy reliability\n\nðŸ•’ TIMEFRAME OPTIMIZATION:\nâ€¢ 1-5min: 20-30 (fast adaptation)\nâ€¢ 15min-1H: 30-50 (balanced)\nâ€¢ 4H+: 50-100 (smooth signals)\n\nðŸ’¡ Lower = More responsive but noisier")
sensitivity = input.float(0.7, "Signal Sensitivity", minval=0.1, maxval=2.0, step=0.1, group=group_core, tooltip="ðŸŽ¯ MASTER SENSITIVITY CONTROL\n\nðŸ“Š Adjusts:\nâ€¢ Jump detection threshold\nâ€¢ Regime change sensitivity\nâ€¢ Entropy significance levels\n\nðŸ“ˆ HIGHER (1.5-2.0): More signals, catch smaller moves\nðŸ“‰ LOWER (0.5-0.8): Fewer signals, only major events\n\nðŸ’¡ Start at 1.0, adjust based on signal frequency")
signal_mode = input.string("Confluence", "Signal Generation Mode", options=["Aggressive", "Confluence", "Conservative"], group=group_core, tooltip="ðŸŽ¯ HOW SIGNALS ARE GENERATED\n\nðŸ”¥ AGGRESSIVE: Any component signals\nâ€¢ Most signals, early entries\nâ€¢ Higher false positive rate\n\nâš–ï¸ CONFLUENCE: 2+ components agree\nâ€¢ Balanced approach\nâ€¢ Good risk/reward\n\nðŸ›¡ï¸ CONSERVATIVE: All 3 must align\nâ€¢ Fewest but highest quality signals\nâ€¢ Best for larger positions")
//==============================================================================
// ðŸŒŠ VOLATILITY JUMP DETECTION
//==============================================================================
group_volatility = "ðŸŒŠ Volatility Jump Detection"
vol_dimensions = input.int(3, "Volatility Dimensions", minval=2, maxval=5, group=group_volatility, tooltip="ðŸŽ¯ VOLATILITY SPACE DIMENSIONS\n\nðŸ“Š Each dimension analyzes different scale:\nâ€¢ 2D: Price + Volume volatility\nâ€¢ 3D: + Momentum volatility\nâ€¢ 4D: + Correlation volatility\nâ€¢ 5D: + Microstructure volatility\n\nðŸ’¡ More dimensions = more nuanced detection")
jump_threshold = input.float(3.0, "Jump Detection Threshold (Ïƒ)", minval=1.5, maxval=4.0, step=0.1, group=group_volatility, tooltip="ðŸŽ¯ STANDARD DEVIATIONS FOR JUMP\n\nðŸ“Š Volatility spike needed to trigger:\nâ€¢ 1.5-2.0Ïƒ: Sensitive (more jumps detected)\nâ€¢ 2.5-3.0Ïƒ: Balanced\nâ€¢ 3.5-4.0Ïƒ: Only extreme jumps\n\nðŸ¦ ASSET OPTIMIZATION:\nâ€¢ Crypto: 2.0-2.5Ïƒ (naturally volatile)\nâ€¢ Stocks: 2.5-3.0Ïƒ\nâ€¢ Forex: 3.0-3.5Ïƒ (usually stable)")
hawkes_decay = input.float(0.85, "Jump Clustering Decay", minval=0.5, maxval=0.99, step=0.01, group=group_volatility, tooltip="ðŸŽ¯ HAWKES PROCESS DECAY RATE\n\nðŸ“Š How quickly jump probability decreases:\nâ€¢ 0.5-0.7: Fast decay (jumps independent)\nâ€¢ 0.8-0.9: Moderate (some clustering)\nâ€¢ 0.95-0.99: Slow (strong clustering)\n\nðŸ’¡ Higher = Jumps trigger more jumps")
//==============================================================================
// ðŸ“ HURST EXPONENT PARAMETERS
//==============================================================================
group_hurst = "ðŸ“ Hurst Exponent Analysis"
hurst_method = input.string("Adaptive R/S", "Calculation Method", options=["Classic R/S", "Adaptive R/S", "DFA"], group=group_hurst, tooltip="ðŸŽ¯ HURST CALCULATION METHOD\n\nðŸ“Š Classic R/S: Original Rescaled Range\nâ€¢ Simple, fast\nâ€¢ Can be biased for short series\n\nðŸ“Š Adaptive R/S: Dynamic windowing\nâ€¢ More accurate for trading\nâ€¢ Handles non-stationarity\n\nðŸ“Š DFA: Detrended Fluctuation\nâ€¢ Most sophisticated\nâ€¢ Best for noisy data")
regime_threshold_trend = input.float(0.60, "Trending Threshold", minval=0.55, maxval=0.8, step=0.01, group=group_hurst, tooltip="ðŸŽ¯ HURST VALUE FOR TREND REGIME\n\nðŸ“Š H > threshold = Trending market\nâ€¢ 0.55-0.60: Weak persistence\nâ€¢ 0.65-0.70: Clear trending\nâ€¢ 0.75-0.80: Strong momentum\n\nðŸ’¡ In trends: Follow breakouts, ride momentum")
regime_threshold_mean = input.float(0.40, "Mean Reversion Threshold", minval=0.2, maxval=0.45, step=0.01, group=group_hurst, tooltip="ðŸŽ¯ HURST VALUE FOR MEAN REVERSION\n\nðŸ“Š H < threshold = Anti-persistent\nâ€¢ 0.40-0.45: Weak reversion\nâ€¢ 0.30-0.35: Clear ranging\nâ€¢ 0.20-0.25: Strong reversion\n\nðŸ’¡ In ranges: Fade extremes, buy support/sell resistance")
//==============================================================================
// ðŸ”„ TRANSFER ENTROPY PARAMETERS
//==============================================================================
group_entropy = "ðŸ”„ Transfer Entropy Analysis"
entropy_source = input.string("Price-Volume", "Information Flow Analysis", options=["Price-Volume", "Price-Volatility", "Multi-Timeframe"], group=group_entropy, tooltip="ðŸŽ¯ WHAT INFORMATION FLOW TO MEASURE\n\nðŸ“Š Price-Volume: Classic flow analysis\nâ€¢ Volume leads price = Accumulation/Distribution\nâ€¢ Price leads volume = Retail chasing\n\nðŸ“Š Price-Volatility: Risk flow\nâ€¢ Volatility leads = Risk-off incoming\nâ€¢ Price leads = Complacent rally\n\nðŸ“Š Multi-Timeframe: Cross-TF flow\nâ€¢ HTF leads = Major trend\nâ€¢ LTF leads = Noise")
entropy_lag = input.int(5, "Maximum Lag (bars)", minval=2, maxval=20, group=group_entropy, tooltip="ðŸŽ¯ HOW FAR BACK TO LOOK FOR CAUSALITY\n\nðŸ“Š Information transfer lag window:\nâ€¢ 2-5 bars: Immediate causality\nâ€¢ 5-10 bars: Short-term flow\nâ€¢ 10-20 bars: Structural flow\n\nðŸ’¡ Match to your timeframe:\nâ€¢ 1min chart: 3-5 bars\nâ€¢ 5min chart: 5-10 bars\nâ€¢ 15min+: 10-20 bars")
entropy_threshold = input.float(0.15, "Significance Threshold", minval=0.05, maxval=0.3, step=0.01, group=group_entropy, tooltip="ðŸŽ¯ MINIMUM ENTROPY FOR SIGNAL\n\nðŸ“Š Information flow strength needed:\nâ€¢ 0.05-0.10: Detect subtle flows\nâ€¢ 0.10-0.20: Clear causality only\nâ€¢ 0.20-0.30: Very strong flow only\n\nðŸ’¡ Lower = More sensitive to information transfer")
//==============================================================================
// ðŸŽ¨ VISUAL CONFIGURATION
//==============================================================================
group_visual = "ðŸŽ¨ Visual Configuration"
color_scheme = input.string("Dark", "Color Scheme", options=["Dark", "Light", "Classic", "Neon", "Neutral", "Bright"], group=group_visual,
     tooltip="Choose your preferred color theme")
show_jump_markers = input.bool(false, "Show Volatility Jumps", group=group_visual, tooltip="Show lightning bolts for volatility jumps - can be visually cluttered")
show_regime_bg = input.bool(true, "Show Hurst Regime Background", group=group_visual)
show_signals = input.bool(true, "Show Trade Signals", group=group_visual)
show_signal_labels = input.bool(true, "Show BUY/SELL Labels", group=group_visual)
show_wick_pressure = input.bool(true, "âš¡ Show Wick Pressure Lines", group=group_visual,
  tooltip="ðŸŽ¯ WHAT IT IS: Rejection level analysis using candle wick patterns\n\n" +
  "âš¡ HOW IT WORKS: Projects lines from significant wicks to show pressure zones\n\n" +
  "ðŸ“ˆ UPPER WICKS: Show selling pressure and resistance\n" +
  "ðŸ“‰ LOWER WICKS: Show buying pressure and support\n\n" +
  "ðŸŽ¯ TRADING APPLICATION:\n" +
  "â€¢ Entry: Trade bounces off wick pressure zones\n" +
  "â€¢ Exit: Watch for wick pressure breakdown\n" +
  "â€¢ Confluence: Combine with fractal grid levels\n\n" +
  "ðŸ’¡ PRO TIP: Multiple wick pressure lines = stronger S/R zones")
regime_smoothing = input.int(10, "Regime Smoothing", minval=1, maxval=20, group=group_visual, tooltip="Smooths regime changes to reduce background flicker")
group_tensor_visuals = "ðŸ”¢ Tensor Analysis Engine"
show_tensor_field = input.bool(true, "ðŸŒŠ Tensor Volatility Field", group=group_tensor_visuals)
show_dimensional_portals = input.bool(true, "ðŸŒ€ Dimensional Portals", group=group_tensor_visuals)
show_entropy_streams = input.bool(true, "ðŸ”„ Information Flow Streams", group=group_tensor_visuals)
show_fractal_matrix = input.bool(true, "ðŸ“ Hurst Fractal Matrix", group=group_tensor_visuals)
show_lightning_network = input.bool(true, "âš¡ Volatility Lightning Network", group=group_tensor_visuals)
show_holographic_signals = input.bool(true, "ðŸŽ¯ Holographic Signal Projection", group=group_tensor_visuals)
tensor_intensity = input.float(1.0, "ðŸ”¥ Visual Intensity", minval=0.5, maxval=2.0, group=group_tensor_visuals)
particle_density = input.int(8, "âœ¨ Particle Density", minval=3, maxval=15, group=group_tensor_visuals)
//==============================================================================
// ðŸ“Š DASHBOARD CONFIGURATION
//==============================================================================
group_dashboard = "ðŸ“Š Dashboard Configuration"
show_dashboard = input.bool(true, "ðŸ“‹ Show Enhanced Dashboard", group=group_dashboard,
  tooltip="ðŸŽ¯ WHAT IT IS: Displays a comprehensive panel with key trading metrics\n\n" +
  "âš¡ HOW IT WORKS: Shows tensor metrics, regime analysis, volatility jumps, and trade signals\n\n" +
  "ðŸ“Š DASHBOARD INCLUDES:\n" +
  "â€¢ Tensor Field Strength (Mahalanobis distance)\n" +
  "â€¢ Volatility Jump Detection\n" +
  "â€¢ Hurst Regime Analysis\n" +
  "â€¢ Information Flow Signals\n" +
  "â€¢ Market Structure Analysis\n\n" +
  "ðŸŽ¯ BENEFITS:\n" +
  "â€¢ Quick decision-making\n" +
  "â€¢ Real-time market insights\n" +
  "â€¢ Multi-dimensional analysis\n\n" +
  "ðŸ’¡ RECOMMENDED: Keep ON for systematic trading, disable for minimal charts")
dashboard_size = input.string("Normal", "ðŸ“ Dashboard Size", options=["Small", "Normal", "Large"], group=group_dashboard,
  tooltip="ðŸŽ¯ WHAT IT IS: Controls the size and detail level of the dashboard\n\n" +
  "âš¡ HOW IT WORKS: Adjusts the amount of information displayed\n\n" +
  "ðŸ“± SMALL: Minimal metrics, ideal for mobile or small screens\n" +
  "ðŸ’» NORMAL: Balanced detail, suitable for most desktops\n" +
  "ðŸ–¥ï¸ LARGE: Maximum detail, best for multi-monitor setups\n\n" +
  "ðŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: Small (quick reference)\n" +
  "â€¢ Day Trading: Normal (balanced info)\n" +
  "â€¢ Swing Trading: Large (detailed analysis)\n\n" +
  "ðŸ’¡ PRO TIP: Use Normal for most setups, Large for deep analysis")
dashboard_position_input = input.string("Top Right", "ðŸ“ Dashboard Position", options=["Top Left", "Top Right", "Bottom Left", "Bottom Right"], group=group_dashboard,
  tooltip="ðŸŽ¯ WHAT IT IS: Sets the dashboard's position on the chart\n\n" +
  "âš¡ HOW IT WORKS: Places the dashboard in a non-intrusive location\n\n" +
  "ðŸ“ TOP RIGHT: Standard placement, avoids price action\n" +
  "ðŸ“ TOP LEFT: Good for wide charts or left-handed users\n" +
  "ðŸ“ BOTTOM RIGHT: Focuses on recent price action, ideal for scalping\n" +
  "ðŸ“ BOTTOM LEFT: Maximizes price visibility, good for swing trading\n\n" +
  "ðŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: Bottom Right (recent price focus)\n" +
  "â€¢ Day Trading: Top Right (standard)\n" +
  "â€¢ Swing Trading: Bottom Left (price visibility)\n\n" +
  "ðŸ’¡ PRO TIP: Choose a position that doesn't obscure key chart areas")
// ========================================
// ENHANCED COLOR SCHEME SYSTEM
// ========================================
get_color_scheme(scheme) =>
    switch scheme
        "Light" =>
            [#ffffff, #f5f5f5, #e0e0e0, #00897b, #d32f2f, #5e35b1, #ff6f00, #1976d2, #388e3c, #6a1b9a,
             #000000, #212121, #616161, #9e9e9e]
        "Classic" =>
            [#1a1a1a, #2d2d2d, #404040, #008000, #ff0000, #0000ff, #ffa500, #00bfff, #32cd32, #9370db,
             #ffffff, #f0f0f0, #c0c0c0, #808080]
        "Neon" =>
            [#000000, #0a0a0a, #1a1a1a, #00ff00, #ff0066, #00ffff, #ffff00, #ff00ff, #00ff99, #ff3399,
             #ffffff, #f0f0ff, #e0e0ff, #c0c0ff]
        "Neutral" =>
            [#2e2e2e, #3a3a3a, #4a4a4a, #708090, #696969, #778899, #a9a9a9, #b0c4de, #d3d3d3, #dcdcdc,
             #ffffff, #f5f5f5, #cccccc, #999999]
        "Bright" =>
            [#000011, #001122, #002244, #00ff44, #ff4400, #4400ff, #ffaa00, #00aaff, #44ff00, #ff0044,
             #ffffff, #ffff88, #88ffff, #ff88ff]
        => // Default "Dark"
            [#0a0e17, #1a1e27, #2a2e37, #26a69a, #ef5350, #7c4dff, #ffa726, #42a5f5, #66bb6a, #ab47bc,
             #ffffff, #e4e8eb, #9ca3af, #6b7280]
[bg_dark, panel_bg, border_color, color_bullish, color_bearish, color_neutral, 
 color_warning, color_info, color_success, color_consciousness,
 text_bright, text_normal, text_muted, text_dim] = get_color_scheme(color_scheme)
c_success = color_success
c_danger = color_bearish  
c_primary = color_consciousness
c_info = color_info
//==============================================================================
// ðŸ§® CORE CALCULATIONS
//==============================================================================
returns = (close - close[1]) / close[1]
log_returns = math.log(close / close[1])
atr_value = ta.atr(14)
//==============================================================================
// ðŸŒŠ MULTI-DIMENSIONAL VOLATILITY WITH JUMP DETECTION
//==============================================================================
price_vol = ta.stdev(returns, lookback_period)
volume_vol = ta.stdev((volume - ta.sma(volume, lookback_period)) / ta.sma(volume, lookback_period), lookback_period)
high_low_vol = ta.stdev((high - low) / close, lookback_period)
corr_vol = ta.stdev(ta.correlation(close, volume, lookback_period), lookback_period)
micro_vol = ta.stdev((close - (high + low) / 2) / (high - low + 0.0001), lookback_period)
calculate_volatility_state(dims, p_vol, v_vol, hl_vol, c_vol, m_vol) =>
    state = array.new_float(dims, 0.0)
    array.set(state, 0, p_vol)
    if dims >= 2
        array.set(state, 1, v_vol)
    if dims >= 3
        array.set(state, 2, hl_vol)
    if dims >= 4
        array.set(state, 3, c_vol)
    if dims >= 5
        array.set(state, 4, m_vol)
    state
current_vol_state = calculate_volatility_state(vol_dimensions, price_vol, volume_vol, high_low_vol, corr_vol, micro_vol)
calculate_mahalanobis_distance(state, dims) =>
    dim_means = array.new_float(dims, 0.0)
    dim_stds = array.new_float(dims, 0.0)
    for d = 0 to dims - 1
        dim_values = array.new_float(0)
        for j = 1 to lookback_period
            if j <= bar_index
                hist_val = d == 0 ? price_vol[j] : d == 1 ? volume_vol[j] : d == 2 ? high_low_vol[j] : d == 3 ? corr_vol[j] : micro_vol[j]
                array.push(dim_values, hist_val)
        mean_val = array.avg(dim_values)
        std_val = array.stdev(dim_values)
        array.set(dim_means, d, mean_val)
        array.set(dim_stds, d, std_val)
    distance = 0.0
    for i = 0 to array.size(state) - 1
        mean_val = array.get(dim_means, i)
        std_val = array.get(dim_stds, i)        
        if std_val > 0
            z_score = (array.get(state, i) - mean_val) / std_val
            distance += z_score * z_score   
    math.sqrt(distance / array.size(state))
mahalanobis_dist = calculate_mahalanobis_distance(current_vol_state, vol_dimensions)
raw_volatility_jump = mahalanobis_dist > jump_threshold * sensitivity
var int last_jump_bar = 0
jump_cooldown = bar_index - last_jump_bar > 5 
volatility_jump = raw_volatility_jump and jump_cooldown
if volatility_jump
    last_jump_bar := bar_index
var float hawkes_intensity = 0.0
if volatility_jump
    hawkes_intensity := 1.0
else
    hawkes_intensity := hawkes_intensity * hawkes_decay
jump_probability = hawkes_intensity
//==============================================================================
// ðŸ“ HURST EXPONENT CALCULATION
//==============================================================================
calculate_hurst_exponent(data, length) =>
    if length < 4
        0.5
    else
        mean = 0.0
        for i = 0 to length - 1
            if i < array.size(data)
                mean += array.get(data, i)
        mean /= length
        cumsum = array.new_float(length, 0.0)
        for i = 0 to length - 1
            if i < array.size(data)
                sum_val = 0.0
                for j = 0 to i
                    sum_val += array.get(data, j) - mean
                array.set(cumsum, i, sum_val)
        range_val = array.max(cumsum) - array.min(cumsum)
        std_sum = 0.0
        for i = 0 to length - 1
            if i < array.size(data)
                std_sum += math.pow(array.get(data, i) - mean, 2)
        std = math.sqrt(std_sum / length)
        rs = std > 0 ? range_val / std : 0
        rs > 0 ? math.log(rs) / math.log(length) : 0.5
price_array = array.new_float(lookback_period)
for i = 0 to lookback_period - 1
    if i < bar_index
        array.set(price_array, i, log_returns[i])
hurst = calculate_hurst_exponent(price_array, lookback_period)
hurst_smoothed = ta.ema(hurst, regime_smoothing)
var string current_regime = "random"
var int regime_bars = 0
if hurst_smoothed > regime_threshold_trend + 0.02 
    current_regime := "trending"
    regime_bars := 0
else if hurst_smoothed < regime_threshold_mean - 0.02
    current_regime := "reverting"
    regime_bars := 0
else
    regime_bars += 1
    if regime_bars > 10 
        current_regime := "random"
is_trending = current_regime == "trending"
is_mean_reverting = current_regime == "reverting"  
is_random_walk = current_regime == "random"
regime_strength = is_trending ? (hurst_smoothed - 0.5) / 0.5 : is_mean_reverting ? (0.5 - hurst_smoothed) / 0.5 : 0.0
//==============================================================================
// ðŸ”„ TRANSFER ENTROPY CALCULATION
//==============================================================================
calculate_transfer_entropy(source_data, target_data, lag) =>
    if bar_index < lag + lookback_period
        0.0
    else
        num_bins = 10
        source_min = array.min(source_data)
        source_max = array.max(source_data)
        target_min = array.min(target_data)
        target_max = array.max(target_data)
        source_range = source_max - source_min
        target_range = target_max - target_min
        if source_range == 0 or target_range == 0
            0.0
        else
            joint_count = 0.0
            source_count = 0.0
            target_count = 0.0
            for i = lag to array.size(source_data) - 1
                source_val = array.get(source_data, i - lag)
                target_val = array.get(target_data, i)
                source_bin = int((source_val - source_min) / source_range * (num_bins - 1))
                target_bin = int((target_val - target_min) / target_range * (num_bins - 1))
                if source_bin == target_bin
                    joint_count += 1
                source_count += 1
                target_count += 1
            prob = joint_count / source_count
            prob > 0 and prob < 1 ? -prob * math.log(prob) - (1 - prob) * math.log(1 - prob) : 0.0
volume_array = array.new_float(lookback_period)
price_change_array = array.new_float(lookback_period)
for i = 0 to lookback_period - 1
    if i < bar_index
        array.set(volume_array, i, math.log(volume[i] + 1))
        array.set(price_change_array, i, returns[i])
te_volume_to_price = calculate_transfer_entropy(volume_array, price_change_array, entropy_lag)
te_price_to_volume = calculate_transfer_entropy(price_change_array, volume_array, entropy_lag)
te_volume_to_price_smooth = ta.ema(te_volume_to_price, 5)
te_price_to_volume_smooth = ta.ema(te_price_to_volume, 5)
net_information_flow = te_volume_to_price_smooth - te_price_to_volume_smooth
volume_leads = net_information_flow > entropy_threshold * sensitivity
price_leads = net_information_flow < -entropy_threshold * sensitivity
no_clear_leader = not volume_leads and not price_leads
//==============================================================================
// ðŸŽ¯ SIGNAL GENERATION
//==============================================================================
sma_20 = ta.sma(close, 20)
sma_volume = ta.sma(volume, 20)
ema_9 = ta.ema(close, 9)
rsi_14 = ta.rsi(close, 14)
[bb_middle, bb_upper, bb_lower] = ta.bb(close, 20, 2)
bb_squeeze = (bb_upper - bb_lower) / bb_middle < 0.1
vol_signal = volatility_jump or hawkes_intensity > (0.2 * sensitivity)
hurst_signal = false
if is_trending
    hurst_signal := close > sma_20 and close > close[1]
else if is_mean_reverting
    hurst_signal := (close > bb_upper) or (close < bb_lower)
else
    hurst_signal := bb_squeeze and (close > bb_upper[1] or close < bb_lower[1])
entropy_signal = volume_leads or price_leads or (volume > sma_volume * (1.0 + sensitivity * 0.1))
momentum_up = rsi_14 > 50 and close > ema_9
momentum_down = rsi_14 < 50 and close < ema_9
active_signals = (vol_signal ? 1 : 0) + (hurst_signal ? 1 : 0) + (entropy_signal ? 1 : 0)
long_condition = false
short_condition = false
if signal_mode == "Aggressive"
    long_condition := active_signals >= 1 and momentum_up
    short_condition := active_signals >= 1 and momentum_down
else if signal_mode == "Confluence"
    long_condition := active_signals >= 2 and momentum_up
    short_condition := active_signals >= 2 and momentum_down
else 
    long_condition := active_signals == 3 and momentum_up
    short_condition := active_signals == 3 and momentum_down
var int last_signal_bar = 0
signal_gap = bar_index - last_signal_bar > 5
long_signal = long_condition and signal_gap
short_signal = short_condition and signal_gap
if long_signal or short_signal
    last_signal_bar := bar_index
//==============================================================================
// ðŸ“Š REAL PERFORMANCE TRACKING
//==============================================================================
var array<float> trade_results = array.new<float>()
var array<int> trade_entry_bars = array.new<int>()
var float current_entry_price = na
var int current_entry_bar = na
var string current_position = "none"
if long_signal and current_position == "none"
    current_entry_price := close
    current_entry_bar := bar_index
    current_position := "long"
if short_signal and current_position == "none"
    current_entry_price := close
    current_entry_bar := bar_index
    current_position := "short"
exit_trade = false
if current_position != "none" and not na(current_entry_price) and not na(current_entry_bar)
    bars_in_trade = bar_index - current_entry_bar
    if current_position == "long"
        pnl_pct = (close - current_entry_price) / current_entry_price
        exit_trade := bars_in_trade > 15 or pnl_pct > 0.03 or pnl_pct < -0.015
    else 
        pnl_pct = (current_entry_price - close) / current_entry_price  
        exit_trade := bars_in_trade > 15 or pnl_pct > 0.03 or pnl_pct < -0.015
if exit_trade and current_position != "none"
    final_pnl = 0.0
    if current_position == "long"
        final_pnl := (close - current_entry_price) / current_entry_price
    else
        final_pnl := (current_entry_price - close) / current_entry_price
    array.push(trade_results, final_pnl)
    array.push(trade_entry_bars, current_entry_bar)
    current_position := "none"
    current_entry_price := na
    current_entry_bar := na
real_win_rate = 0.0
total_trades = array.size(trade_results)
if total_trades > 0
    winning_trades = 0
    for i = 0 to total_trades - 1
        if array.get(trade_results, i) > 0
            winning_trades += 1
    real_win_rate := winning_trades / total_trades
// ============================================
// CORE CALCULATIONS FOR DASHBOARD
// ============================================
signal_threshold = jump_threshold * sensitivity
signal_strength_confirmed = mahalanobis_dist
signal_quality_rating = active_signals == 3 ? "ELITE" : active_signals == 2 ? "STRONG" : active_signals == 1 ? "GOOD" : "WEAK"
volume_sma = ta.sma(volume, 20)
volume_spike = volume > volume_sma * 1.5 ? 50 : 0
bb_position = mahalanobis_dist > jump_threshold ? 100 : 0
anomaly_level = math.min(bb_position + volume_spike, 100)
tensor_state = is_trending ? 1 : is_mean_reverting ? -1 : 0
trend_direction = is_trending ? 1 : is_mean_reverting ? -1 : 0
flow_strength = math.abs(net_information_flow) * 10
market_regime_bullish = is_trending and close > ta.sma(close, 20)
trade_allowed = true  
can_trade = true  
daily_trades = active_signals  
max_trades_adjusted = 10      
daily_pnl = (close - close[20]) / close[20] * 100 
win_rate = total_trades > 0 ? real_win_rate : 0.0
ENABLE_LEARNING = true
adaptive_risk_multiplier = active_signals >= 2 ? 1.2 : active_signals == 1 ? 1.0 : 0.8
MAX_DAILY_TRADES = 10
BASE_RISK = 0.02
SIGNAL_SENSITIVITY = sensitivity
EXECUTION_MODE = signal_mode
high_vol = mahalanobis_dist > jump_threshold * 1.5
low_vol = mahalanobis_dist < jump_threshold * 0.5
session_timezone = "UTC" 
visual_theme = color_scheme
//==============================================================================
// âš¡ WICK PRESSURE LINES
//==============================================================================
if show_wick_pressure and atr_value > 0
    upperWick = high - math.max(open, close)
    lowerWick = math.min(open, close) - low
    body = math.abs(close - open)
    glow_intensity = int(tensor_intensity * 5)
    primaryBear = color_bearish 
    primaryBull = color_bullish 
    for i = 1 to math.min(glow_intensity, 8)
        if bar_index > i
            if upperWick[i] > body[i] * 0.5
                wickAlpha = 20 + i * 8
                wickColor = color.new(primaryBear, wickAlpha)
                wickWidth = math.max(1, glow_intensity - i)
                line.new(bar_index - i, high[i], bar_index, high - (atr_value * 0.1), 
                         color=wickColor, width=wickWidth, style=line.style_dotted)
            if lowerWick[i] > body[i] * 0.5
                wickAlpha = 20 + i * 8
                wickColor = color.new(primaryBull, wickAlpha)
                wickWidth = math.max(1, glow_intensity - i)
                line.new(bar_index - i, low[i], bar_index, low + (atr_value * 0.1), 
                         color=wickColor, width=wickWidth, style=line.style_dotted)
//==============================================================================
// ðŸŽ¨ TENSOR VISUALIZATION SYSTEM
//==============================================================================
price_range = ta.highest(high, 20) - ta.lowest(low, 20)
field_offset = price_range * 0.08
//==============================================================================
// ðŸŒŠ TENSOR VOLATILITY FIELD WITH RADIATION LINES
//==============================================================================
field_strength = math.min(3.0, mahalanobis_dist * tensor_intensity)
field_center = ta.ema(close, 9)
field_amplitude = atr_value * (1 + math.abs(mahalanobis_dist) / 2)
tensor_multiplier = 1 + field_strength * 0.5
upper_field1 = field_center + field_offset * 0.5 * tensor_multiplier
lower_field1 = field_center - field_offset * 0.5 * tensor_multiplier
upper_field2 = field_center + field_offset * 1.0 * tensor_multiplier
lower_field2 = field_center - field_offset * 1.0 * tensor_multiplier
upper_field3 = field_center + field_offset * 1.5 * tensor_multiplier
lower_field3 = field_center - field_offset * 1.5 * tensor_multiplier
upper_field4 = field_center + field_offset * 2.0 * tensor_multiplier
lower_field4 = field_center - field_offset * 2.0 * tensor_multiplier
upper_field5 = field_center + field_offset * 2.5 * tensor_multiplier
lower_field5 = field_center - field_offset * 2.5 * tensor_multiplier
upper_plot1 = plot(show_tensor_field ? upper_field1 : na, color=color.new(color_consciousness, 40), linewidth=3, title="Tensor Core Upper")
lower_plot1 = plot(show_tensor_field ? lower_field1 : na, color=color.new(color_consciousness, 40), linewidth=3, title="Tensor Core Lower")
upper_plot2 = plot(show_tensor_field ? upper_field2 : na, color=color.new(color_neutral, 50), linewidth=2, title="Tensor Layer 2 Upper")
lower_plot2 = plot(show_tensor_field ? lower_field2 : na, color=color.new(color_neutral, 50), linewidth=2, title="Tensor Layer 2 Lower")
upper_plot3 = plot(show_tensor_field ? upper_field3 : na, color=color.new(color_info, 60), linewidth=2, title="Tensor Layer 3 Upper")
lower_plot3 = plot(show_tensor_field ? lower_field3 : na, color=color.new(color_info, 60), linewidth=2, title="Tensor Layer 3 Lower")
upper_plot4 = plot(show_tensor_field ? upper_field4 : na, color=color.new(color_warning, 70), linewidth=1, title="Tensor Layer 4 Upper")
lower_plot4 = plot(show_tensor_field ? lower_field4 : na, color=color.new(color_warning, 70), linewidth=1, title="Tensor Layer 4 Lower")
upper_plot5 = plot(show_tensor_field ? upper_field5 : na, color=color.new(color_success, 80), linewidth=1, title="Tensor Layer 5 Upper")
lower_plot5 = plot(show_tensor_field ? lower_field5 : na, color=color.new(color_success, 80), linewidth=1, title="Tensor Layer 5 Lower")
fill(upper_plot1, lower_plot1, color=show_tensor_field ? color.new(color_consciousness, 92) : na, title="Tensor Core")
fill(upper_plot2, lower_plot2, color=show_tensor_field ? color.new(color_neutral, 94) : na, title="Tensor Layer 2")
fill(upper_plot3, lower_plot3, color=show_tensor_field ? color.new(color_info, 96) : na, title="Tensor Layer 3")
fill(upper_plot4, lower_plot4, color=show_tensor_field ? color.new(color_warning, 97) : na, title="Tensor Layer 4")
fill(upper_plot5, lower_plot5, color=show_tensor_field ? color.new(color_success, 98) : na, title="Tensor Layer 5")
if show_tensor_field and bar_index % 3 == 0 
    field_intensity = mahalanobis_dist / jump_threshold
    for angle_i = 1 to 8  
        angle = angle_i * 45 * math.pi / 180
        ray_length = field_amplitude * 0.3 
        var float start_y = na
        var float end_y = na
        var color ray_color = na
        for segment = 1 to 3 
            segment_start_ratio = (segment - 1) / 3.0
            segment_end_ratio = segment / 3.0
            start_distance = ray_length * segment_start_ratio
            end_distance = ray_length * segment_end_ratio
            start_x = bar_index + int(start_distance / atr_value * 2)
            end_x = bar_index + int(end_distance / atr_value * 2)
            if angle_i <= 4 
                start_y := field_center + start_distance * math.sin(angle)
                end_y := field_center + end_distance * math.sin(angle)
                ray_color := volatility_jump ? color_bearish : color_consciousness
            else  // Lower hemisphere
                start_y := field_center - start_distance * math.sin(angle)
                end_y := field_center - end_distance * math.sin(angle)
                ray_color := volatility_jump ? color_bearish : color_neutral
            line_width = segment == 1 ? 2 : 1
            transparency_ray = 85 + angle_i * 2 + segment * 10
            if segment < 3
                line.new(start_x, start_y, end_x, end_y, color=color.new(ray_color, transparency_ray), width=line_width, style=line.style_dashed)
    if volatility_jump
        pulse_radius = field_amplitude * 0.8
        for pulse_i = 1 to 12 
            pulse_angle = pulse_i * 30 * math.pi / 180
            for pulse_segment = 1 to 2 
                segment_start_ratio = (pulse_segment - 1) / 2.0
                segment_end_ratio = pulse_segment / 2.0               
                start_distance = pulse_radius * segment_start_ratio
                end_distance = pulse_radius * segment_end_ratio                
                pulse_start_x = bar_index + int(start_distance / atr_value * 1.5)
                pulse_end_x = bar_index + int(end_distance / atr_value * 1.5)
                pulse_start_y = field_center + start_distance * math.sin(pulse_angle)
                pulse_end_y = field_center + end_distance * math.sin(pulse_angle)              
                pulse_width = pulse_segment == 1 ? 2 : 1
                pulse_transparency = 90 + pulse_segment * 5                
                line.new(pulse_start_x, pulse_start_y, pulse_end_x, pulse_end_y, color=color.new(color_bearish, pulse_transparency), width=pulse_width, style=line.style_dotted)
//==============================================================================
// ðŸŒŠ DYNAMIC REGIME BACKGROUND 
//==============================================================================
var color regime_bg_color = na
if show_regime_bg
    pulse_intensity = int(regime_strength * 10) + 5
    base_alpha = 98 - pulse_intensity 
    if is_trending
        regime_bg_color := color.new(color_bullish, base_alpha)
    else if is_mean_reverting
        regime_bg_color := color.new(color_bearish, base_alpha)
    else
        regime_bg_color := color.new(color_neutral, base_alpha + 1)
else
    regime_bg_color := na
bgcolor(regime_bg_color, title="Dynamic Regime Background")
//==============================================================================
// âš¡ VOLATILITY JUMPS
//==============================================================================
var int jump_display_bar = 0
var bool jump_shown = false
if volatility_jump and not jump_shown
    jump_display_bar := bar_index
    jump_shown := true
    if show_jump_markers
        for bolt = 0 to 3
            bolt_y = high + field_offset * (0.3 + bolt * 0.08)
            bolt_alpha = 40 + bolt * 20   
            label.new(bar_index, bolt_y, "âš¡", 
                     color=color.new(color.white, 100), 
                     textcolor=color.new(color_warning, bolt_alpha), 
                     style=label.style_none, 
                     size=bolt == 0 ? size.large : size.normal)
if not raw_volatility_jump
    jump_shown := false
//==============================================================================
// ðŸŒ€ DIMENSIONAL PORTAL
//==============================================================================
if show_dimensional_portals
    portal_offset = field_offset * 0.25
    var float portal_y = na
    var color portal_color = na
    clean_green = #00ff00  
    clean_red = #ff0000  
    clean_yellow = #ffff00 
    if is_trending 
        portal_y := close - portal_offset  
        portal_color := clean_green
    else if is_mean_reverting  
        portal_y := close + portal_offset 
        portal_color := clean_red
    else 
        portal_y := close + (close > close[1] ? portal_offset : -portal_offset)
        portal_color := clean_yellow    
    portal_char1 = is_trending ? "â—‰" : is_mean_reverting ? "â—Ž" : "â—‹"
    label.new(bar_index, portal_y, portal_char1, 
             color=color.new(color.white, 100), 
             textcolor=color.new(portal_color, 0), 
             style=label.style_none, 
             size=size.large)
    for trail = 1 to 8 
        if bar_index >= trail
            trail_x = bar_index - trail
            trail_y = portal_y + math.sin(trail * 0.5) * field_offset * 0.05
            trail_alpha = 30 + trail * 8           
            trail_size = trail <= 2 ? size.normal : trail <= 4 ? size.small : size.tiny
            trail_char = trail <= 2 ? "â—" : trail <= 4 ? "â—¦" : trail <= 6 ? "Â·" : "Ë™"            
            label.new(trail_x, trail_y, trail_char, 
                     color=color.new(color.white, 100), 
                     textcolor=color.new(portal_color, trail_alpha), 
                     style=label.style_none, 
                     size=trail_size)
//==============================================================================
// ðŸ”„ INFORMATION FLOW
//==============================================================================
if show_entropy_streams
    flow_active = math.abs(net_information_flow) > 0.01   
    if flow_active or volume > sma_volume * 1.05
        stream_y_base = close + (volume_leads ? field_offset * 0.12 : -field_offset * 0.12)
        for particle = 0 to 15
            particle_x_offset = particle
            if bar_index >= particle_x_offset
                stream_x = bar_index - particle_x_offset
                stream_y = stream_y_base + math.sin((bar_index - particle_x_offset) * 0.3) * field_offset * 0.08
                flow_char = particle <= 1 ? "â—‰" : particle <= 3 ? "â—" : particle <= 6 ? "â—¦" : particle <= 10 ? "Â·" : "Ë™"
                flow_color = volume_leads ? color_info : price_leads ? color_warning : color_neutral
                particle_alpha = 20 + particle * 4 
                particle_size = particle <= 1 ? size.normal : particle <= 4 ? size.small : particle <= 8 ? size.tiny : size.auto
                label.new(stream_x, stream_y, flow_char, 
                         color=color.new(color.white, 100), 
                         textcolor=color.new(flow_color, particle_alpha), 
                         style=label.style_none, 
                         size=particle_size)
//==============================================================================
// ðŸ”® FRACTAL GRID
//==============================================================================
SCORE_AMPLIFIER = 5.0
phase_intense = color_consciousness
anomaly_strong = color_warning
tensor_negative = color_bearish
tensor_positive = color_bullish
holonomy_accent = color_neutral
holonomy_primary = color_info
if show_fractal_matrix
    h8_high = ta.highest(high, 8)
    h8_low = ta.lowest(low, 8)
    h13_high = ta.highest(high, 13)
    h13_low = ta.lowest(low, 13)
    h21_high = ta.highest(high, 21)
    h21_low = ta.lowest(low, 21)
    h34_high = ta.highest(high, 34)
    h34_low = ta.lowest(low, 34)
    h55_high = ta.highest(high, 55)
    h55_low = ta.lowest(low, 55)
    fractalHighs = array.from(h8_high, h13_high, h21_high, h34_high, h55_high)
    fractalLows = array.from(h8_low, h13_low, h21_low, h34_low, h55_low)
    var array<line> fractalHighGlowLines = array.new<line>()
    var array<line> fractalHighTensorLines = array.new<line>()
    var array<line> fractalHighShadowLines = array.new<line>()
    var array<line> fractalLowGlowLines = array.new<line>()
    var array<line> fractalLowTensorLines = array.new<line>()
    var array<line> fractalLowShadowLines = array.new<line>()
    var array<label> fractalHighLabels = array.new<label>()
    var array<label> fractalLowLabels = array.new<label>()
    if barstate.isconfirmed
        for l in fractalHighGlowLines
            line.delete(l)
        for l in fractalHighTensorLines
            line.delete(l)
        for l in fractalHighShadowLines
            line.delete(l)
        for l in fractalLowGlowLines
            line.delete(l)
        for l in fractalLowTensorLines
            line.delete(l)
        for l in fractalLowShadowLines
            line.delete(l)
        for lbl in fractalHighLabels
            label.delete(lbl)
        for lbl in fractalLowLabels
            label.delete(lbl)        
        array.clear(fractalHighGlowLines)
        array.clear(fractalHighTensorLines)
        array.clear(fractalHighShadowLines)
        array.clear(fractalLowGlowLines)
        array.clear(fractalLowTensorLines)
        array.clear(fractalLowShadowLines)
        array.clear(fractalHighLabels)
        array.clear(fractalLowLabels)
        holonomy_periods = array.from(8, 13, 21, 34, 55)
        used_positions = array.new<float>()
        min_spacing = atr_value * 0.2
        for i = 0 to 4
            period = array.get(holonomy_periods, i)
            base_alpha = 50 + i * 10
            glow_alpha = 70 + i * 6
            shadow_alpha = 85 + i * 3
            hi = array.get(fractalHighs, i)
            if not na(hi)
                array.push(fractalHighShadowLines, line.new(bar_index - 5, hi, bar_index + 20, hi, color=color.new(color.white, shadow_alpha), width=5, style=line.style_solid))
                array.push(fractalHighGlowLines, line.new(bar_index - 5, hi, bar_index + 20, hi, color=color.new(color.white, glow_alpha), width=3, style=line.style_solid))
                array.push(fractalHighTensorLines, line.new(bar_index - 6, hi, bar_index + 21, hi, color=color.new(tensor_negative, base_alpha), width=1, style=line.style_dotted))
                can_place_label = true
                if array.size(used_positions) > 0
                    for j = 0 to array.size(used_positions) - 1
                        if math.abs(hi - array.get(used_positions, j)) < min_spacing
                            can_place_label := false
                            break                
                if can_place_label
                    price_distance = (hi - close) / atr_value
                    holonomy_impact = mahalanobis_dist - (price_distance * SCORE_AMPLIFIER / 10)
                    anomaly_strength = math.abs(holonomy_impact) / jump_threshold
                    cohom_obstruction = hurst_smoothed * math.sin(period * math.pi / 55)
                    level_resonance = hawkes_intensity * (1 - math.abs(price_distance) / 10)
                    regime_factor = is_trending ? 1.2 : is_mean_reverting ? 0.8 : 1.0
                    anomaly_strength := anomaly_strength * regime_factor
                    topo_class = anomaly_strength > 1.5 ? "III" : anomaly_strength > 1.0 ? "II" : anomaly_strength > 0.5 ? "I" : "0"
                    vol_strength = vol_dimensions > 3 ? "V" + str.tostring(vol_dimensions) : "V" + str.tostring(vol_dimensions)
                    hurst_class = is_trending ? "T" : is_mean_reverting ? "R" : "N"                   
                    label_text = "H" + str.tostring(period) + " [" + topo_class + "] " + str.tostring(hi, "#.##") + " | M:" + str.tostring(mahalanobis_dist, "#.##") + " | H:" + str.tostring(hurst_smoothed, "#.##") + " | " + hurst_class + (anomaly_strength > 1.5 ? " âš¡" : anomaly_strength > 1.0 ? " â—" : anomaly_strength > 0.5 ? " â—" : " â—‹")                   
                    label_bg_color = anomaly_strength > 1.5 ? color.new(anomaly_strong, 75) : anomaly_strength > 1.0 ? color.new(holonomy_accent, 80) : color.new(panel_bg, 85)                   
                    label_text_color = anomaly_strength > 1.0 ? anomaly_strong : holonomy_accent                    
                    new_label = label.new(bar_index + 21, hi, label_text, color=label_bg_color, textcolor=label_text_color, style=label.style_label_left, size=size.small)                   
                    array.push(fractalHighLabels, new_label)
                    array.push(used_positions, hi)
            lo = array.get(fractalLows, i)
            if not na(lo)

                array.push(fractalLowShadowLines, line.new(bar_index - 5, lo, bar_index + 20, lo, color=color.new(color.white, shadow_alpha), width=5, style=line.style_solid))
                array.push(fractalLowGlowLines, line.new(bar_index - 5, lo, bar_index + 20, lo, color=color.new(color.white, glow_alpha), width=3, style=line.style_solid))
                array.push(fractalLowTensorLines, line.new(bar_index - 6, lo, bar_index + 21, lo, color=color.new(tensor_positive, base_alpha), width=1, style=line.style_dotted))
                can_place_label = true
                if array.size(used_positions) > 0
                    for j = 0 to array.size(used_positions) - 1
                        if math.abs(lo - array.get(used_positions, j)) < min_spacing
                            can_place_label := false
                            break               
                if can_place_label
                    price_distance = (close - lo) / atr_value
                    holonomy_impact = mahalanobis_dist + (price_distance * SCORE_AMPLIFIER / 10)
                    anomaly_strength = math.abs(holonomy_impact) / jump_threshold
                    cohom_obstruction = hurst_smoothed * math.sin(period * math.pi / 55)
                    level_resonance = hawkes_intensity * (1 - math.abs(price_distance) / 10)
                    regime_factor = is_trending ? 1.2 : is_mean_reverting ? 0.8 : 1.0
                    anomaly_strength := anomaly_strength * regime_factor
                    topo_class = anomaly_strength > 1.5 ? "III" : anomaly_strength > 1.0 ? "II" : anomaly_strength > 0.5 ? "I" : "0"
                    vol_strength = vol_dimensions > 3 ? "V" + str.tostring(vol_dimensions) : "V" + str.tostring(vol_dimensions)
                    hurst_class = is_trending ? "T" : is_mean_reverting ? "R" : "N"
                    entropy_class = volume_leads ? "VL" : price_leads ? "PL" : "NL"                    
                    label_text = "L" + str.tostring(period) + " [" + topo_class + "] " + str.tostring(lo, "#.##") + " | M:" + str.tostring(mahalanobis_dist, "#.##") + " | H:" + str.tostring(hurst_smoothed, "#.##") + " | " + hurst_class + (anomaly_strength > 1.5 ? " âš¡" : anomaly_strength > 1.0 ? " â—" : anomaly_strength > 0.5 ? " â—" : " â—‹")                    
                    label_bg_color = anomaly_strength > 1.5 ? color.new(tensor_positive, 75) : anomaly_strength > 1.0 ? color.new(holonomy_primary, 80) : color.new(panel_bg, 85)                    
                    label_text_color = anomaly_strength > 1.0 ? tensor_positive : holonomy_primary                    
                    new_label = label.new(bar_index + 21, lo, label_text, color=label_bg_color, textcolor=label_text_color, style=label.style_label_left, size=size.small)                    
                    array.push(fractalLowLabels, new_label)
                    array.push(used_positions, lo)
//==============================================================================
// âš¡ LIGHTNING NETWORK 
//==============================================================================
if show_lightning_network and hawkes_intensity > 0.2
    if bar_index % 5 == 0
        lightning_y = high + field_offset * 0.2       
        for connection = 1 to 2
            if bar_index >= connection * 4
                start_x = bar_index - connection * 4
                end_x = bar_index
                start_y = high[connection * 4] + field_offset * 0.08
                end_y = lightning_y                
                lightning_alpha = 45 + connection * 20 
                line.new(start_x, start_y, end_x, end_y, color=color.new(color_warning, lightning_alpha), width=1, style=line.style_dashed)        
        label.new(bar_index, lightning_y, "âš¡", 
                 color=color.new(color.white, 100), 
                 textcolor=color.new(color_warning, 50), 
                 style=label.style_none, 
                 size=size.small)
//==============================================================================
// ðŸŽ¯ HOLOGRAPHIC PROJECTIONS
//==============================================================================
if show_holographic_signals and (long_signal or short_signal)

    var float signal_y = na
    var string signal_char = na
    var color signal_color = na
    if long_signal
        signal_y := high + field_offset * 0.6
        signal_char := "â–¼"
        signal_color := color_bearish
    else  
        signal_y := low - field_offset * 0.6
        signal_char := "â–²" 
        signal_color := color_bullish
    for projection = 1 to 8
        projection_alpha = 30 + projection * 8
        projection_size = projection <= 2 ? size.normal : projection <= 4 ? size.small : size.tiny
        projection_char = projection <= 3 ? signal_char : projection <= 5 ? "â—¦" : "Â·"       
        proj_y = signal_y + math.sin(projection * 0.3) * field_offset * 0.03       
        label.new(bar_index + projection, proj_y, projection_char, 
                 color=color.new(color.white, 100), 
                 textcolor=color.new(signal_color, projection_alpha), 
                 style=label.style_none, 
                 size=projection_size)
//==============================================================================
// ðŸŒŸ TENSOR CONSTELLATION NETWORK
//==============================================================================
if show_dimensional_portals and bar_index % 4 == 0
    for connection = 1 to 3
        if bar_index >= connection * 5
            start_x = bar_index - connection * 5
            end_x = bar_index
            start_y = close[connection * 5]
            end_y = close            
            connection_color = start_y < end_y ? color_bullish : color_bearish
            connection_alpha = 80 + connection * 5  // More transparent           
            line.new(start_x, start_y, end_x, end_y, color=color.new(connection_color, connection_alpha), width=1, style=line.style_dotted)
//==============================================================================
// ðŸŽ¯ TENSOR BUY/SELL SIGNALS
//==============================================================================
if show_signals
    if long_signal
        signal_base_y = high + field_offset * 1.0
        label.new(bar_index, signal_base_y, "â—‰", 
                 color=color.new(color.white, 100), 
                 textcolor=color_bearish,
                 style=label.style_none, 
                 size=size.large)
        for ring = 1 to 4
            ring_char = ring == 1 ? "â—Ž" : ring == 2 ? "â—‹" : ring == 3 ? "â—Œ" : "â—¦"
            ring_alpha = 20 + ring * 15
            ring_size = ring <= 2 ? size.large : size.normal            
            label.new(bar_index, signal_base_y, ring_char, 
                     color=color.new(color.white, 100), 
                     textcolor=color.new(color_bearish, ring_alpha), 
                     style=label.style_none, 
                     size=ring_size)
        for particle = 0 to 8
            particle_distance = field_offset * 0.15
            particle_y_offset = particle_distance * math.sin(particle * 45 * math.pi / 180)            
            label.new(bar_index, signal_base_y + particle_y_offset, "âœ¦", 
                     color=color.new(color.white, 100), 
                     textcolor=color.new(color_bearish, 40), 
                     style=label.style_none, 
                     size=size.small)
        for trail = 1 to 6
            if bar_index >= trail
                trail_y = signal_base_y + trail * field_offset * 0.02
                trail_char = trail <= 2 ? "âœ§" : trail <= 4 ? "âœ¦" : "Â·"
                trail_alpha = 30 + trail * 10               
                label.new(bar_index - trail, trail_y, trail_char, 
                         color=color.new(color.white, 100), 
                         textcolor=color.new(color_bearish, trail_alpha),
                         style=label.style_none, 
                         size=size.small)        
        if show_signal_labels
            label.new(bar_index, signal_base_y + field_offset * 0.4, "SELL", 
                     color=color_bearish,
                     textcolor=text_bright, 
                     style=label.style_label_down, 
                     size=size.normal)   
    if short_signal
        signal_base_y = low - field_offset * 1.0
        label.new(bar_index, signal_base_y, "â—‰", 
                 color=color.new(color.white, 100), 
                 textcolor=color_bullish,
                 style=label.style_none, 
                 size=size.large)
        for ring = 1 to 4
            ring_char = ring == 1 ? "â—Ž" : ring == 2 ? "â—‹" : ring == 3 ? "â—Œ" : "â—¦"
            ring_alpha = 20 + ring * 15
            ring_size = ring <= 2 ? size.large : size.normal            
            label.new(bar_index, signal_base_y, ring_char, 
                     color=color.new(color.white, 100), 
                     textcolor=color.new(color_bullish, ring_alpha),
                     style=label.style_none, 
                     size=ring_size)
        for particle = 0 to 8
            particle_distance = field_offset * 0.15
            particle_y_offset = particle_distance * math.sin(particle * 45 * math.pi / 180)
            
            label.new(bar_index, signal_base_y - particle_y_offset, "âœ¦", 
                     color=color.new(color.white, 100), 
                     textcolor=color.new(color_bullish, 40), 
                     size=size.small)
        for trail = 1 to 6
            if bar_index >= trail
                trail_y = signal_base_y - trail * field_offset * 0.02
                trail_char = trail <= 2 ? "âœ§" : trail <= 4 ? "âœ¦" : "Â·"
                trail_alpha = 30 + trail * 10               
                label.new(bar_index - trail, trail_y, trail_char, 
                         color=color.new(color.white, 100), 
                         textcolor=color.new(color_bullish, trail_alpha),
                         style=label.style_none, 
                         size=size.small)       
        if show_signal_labels
            label.new(bar_index, signal_base_y - field_offset * 0.4, "BUY",
                     color=color_bullish, 
                     textcolor=text_bright, 
                     style=label.style_label_up,
                     size=size.normal)
//==============================================================================
// DASHBOARD
//==============================================================================
var table dashboard_enhanced = na
if show_dashboard and barstate.isconfirmed
    dashboard_pos = dashboard_position_input == "Top Left" ? position.top_left : 
                   dashboard_position_input == "Top Right" ? position.top_right : 
                   dashboard_position_input == "Bottom Left" ? position.bottom_left : 
                   position.bottom_right   
    cols = dashboard_size == "Large" ? 5 : 4
    rows = dashboard_size == "Large" ? 25 : dashboard_size == "Normal" ? 20 : 14    
    if not na(dashboard_enhanced)
        table.delete(dashboard_enhanced)      
    dashboard_enhanced := table.new(dashboard_pos, cols, rows, border_width = 1, 
                                  border_color = color.new(border_color, 50), 
                                  bgcolor = color.new(panel_bg, 20))        
    dc_white = text_bright
    dc_gray = text_muted
    dc_green = color_bullish
    dc_red = color_bearish
    dc_gold = color_warning
    dc_purple = color_consciousness
    dc_aqua = color_info
    dc_orange = color_warning
    dc_cyan = color_success
    bg_header = color.new(bg_dark, 30)
    bg_section = color.new(panel_bg, 85)       
    header_size = dashboard_size == "Large" ? size.normal : size.small
    value_size = dashboard_size == "Large" ? size.normal : size.small
    label_size = dashboard_size == "Large" ? size.small : size.tiny       
    current_row = 0      
    table.merge_cells(dashboard_enhanced, 0, current_row, cols - 1, current_row)
    table.cell(dashboard_enhanced, 0, current_row, "ðŸ”¢ Tensor Market Analysis Engine | " + syminfo.ticker, 
              text_halign=text.align_center, text_color=dc_white, bgcolor=bg_header, text_size=header_size)
    current_row += 1   
    table.merge_cells(dashboard_enhanced, 0, current_row, cols - 1, current_row)
    table.cell(dashboard_enhanced, 0, current_row, "â•â•â• âš¡ TENSOR FIELD STATUS â•â•â•", 
              text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
    current_row += 1       
    table.cell(dashboard_enhanced, 0, current_row, "Field Strength", text_color=dc_gray, text_size=label_size)
    table.merge_cells(dashboard_enhanced, 1, current_row, cols - 1, current_row)
    field_color = math.abs(signal_strength_confirmed) > signal_threshold ? 
                  (signal_strength_confirmed > 0 ? dc_green : dc_red) : dc_gray
    field_emoji = math.abs(signal_strength_confirmed) > signal_threshold * 1.5 ? "âš¡" : 
                  math.abs(signal_strength_confirmed) > signal_threshold ? "â—" : "â—‹"
    table.cell(dashboard_enhanced, 1, current_row, field_emoji + " " + str.tostring(signal_strength_confirmed, "#.##"), 
              text_halign=text.align_right, text_color=field_color, text_size=value_size)
    current_row += 1       
    table.cell(dashboard_enhanced, 0, current_row, "Quality", text_color=dc_gray, text_size=label_size)
    table.merge_cells(dashboard_enhanced, 1, current_row, cols - 1, current_row)
    quality_emoji = signal_quality_rating == "ELITE" ? "ðŸŒŸ" : 
                   signal_quality_rating == "STRONG" ? "ðŸ’ª" : 
                   signal_quality_rating == "GOOD" ? "ðŸ‘" : "âš ï¸"
    quality_color = signal_quality_rating == "ELITE" ? dc_gold : 
                   signal_quality_rating == "STRONG" ? dc_green : 
                   signal_quality_rating == "GOOD" ? dc_aqua : dc_gray
    table.cell(dashboard_enhanced, 1, current_row, quality_emoji + " " + signal_quality_rating, 
              text_halign=text.align_right, text_color=quality_color, text_size=value_size)
    current_row += 1       
    table.merge_cells(dashboard_enhanced, 0, current_row, cols - 1, current_row)
    table.cell(dashboard_enhanced, 0, current_row, "â•â•â• ðŸŽ¯ TRADING SIGNALS â•â•â•", 
              text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
    current_row += 1        
    table.cell(dashboard_enhanced, 0, current_row, "Long Signal", text_color=dc_gray, text_size=label_size)
    long_text = long_signal ? "ðŸŸ¢ ACTIVE" : "âšª INACTIVE"
    table.cell(dashboard_enhanced, 1, current_row, long_text, text_color=long_signal ? dc_green : dc_gray, text_size=label_size)      
    table.cell(dashboard_enhanced, 2, current_row, "Short Signal", text_color=dc_gray, text_size=label_size)
    short_text = short_signal ? "ðŸ”´ ACTIVE" : "âšª INACTIVE"
    table.cell(dashboard_enhanced, 3, current_row, short_text, text_color=short_signal ? dc_red : dc_gray, text_size=label_size)
    current_row += 1      
    table.cell(dashboard_enhanced, 0, current_row, "Vol Signal", text_color=dc_gray, text_size=label_size)
    vol_text = vol_signal ? "âœ… ON" : "âŒ OFF"
    table.cell(dashboard_enhanced, 1, current_row, vol_text, text_color=vol_signal ? dc_green : dc_gray, text_size=label_size)   
    table.cell(dashboard_enhanced, 2, current_row, "Hurst Signal", text_color=dc_gray, text_size=label_size)
    hurst_text = hurst_signal ? "âœ… ON" : "âŒ OFF"
    table.cell(dashboard_enhanced, 3, current_row, hurst_text, text_color=hurst_signal ? dc_green : dc_gray, text_size=label_size)
    current_row += 1    
    table.cell(dashboard_enhanced, 0, current_row, "Entropy Signal", text_color=dc_gray, text_size=label_size)
    entropy_text = entropy_signal ? "âœ… ON" : "âŒ OFF"
    table.cell(dashboard_enhanced, 1, current_row, entropy_text, text_color=entropy_signal ? dc_green : dc_gray, text_size=label_size)    
    table.cell(dashboard_enhanced, 2, current_row, "Components", text_color=dc_gray, text_size=label_size)
    components_text = str.tostring(active_signals) + "/3"
    components_color = active_signals == 3 ? dc_green : active_signals == 2 ? dc_aqua : active_signals == 1 ? dc_orange : dc_gray
    table.cell(dashboard_enhanced, 3, current_row, components_text, text_color=components_color, text_size=value_size)    
    current_row += 1       
    table.merge_cells(dashboard_enhanced, 0, current_row, cols - 1, current_row)
    table.cell(dashboard_enhanced, 0, current_row, "â•â•â• ðŸ† PERFORMANCE METRICS â•â•â•", 
              text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
    current_row += 1         
    table.cell(dashboard_enhanced, 0, current_row, "Win Rate", text_color=dc_gray, text_size=label_size)
    win_rate_display = total_trades > 0 ? str.tostring(real_win_rate * 100, "#.1") + "%" : "N/A"
    win_rate_color = real_win_rate >= 0.6 ? dc_green : real_win_rate >= 0.4 ? dc_orange : dc_red
    win_rate_emoji = real_win_rate >= 0.6 ? "ðŸ”¥" : real_win_rate >= 0.4 ? "ðŸ‘" : "âš ï¸"       
    table.cell(dashboard_enhanced, 1, current_row, win_rate_emoji + win_rate_display, 
              text_halign=text.align_right, text_color=total_trades > 0 ? win_rate_color : dc_gray, text_size=label_size)           
    table.cell(dashboard_enhanced, 2, current_row, "Total Trades", text_color=dc_gray, text_size=label_size)
    table.cell(dashboard_enhanced, 3, current_row, str.tostring(total_trades), text_color=dc_cyan, text_size=label_size)
    current_row += 1        
    table.cell(dashboard_enhanced, 0, current_row, "Regime", text_color=dc_gray, text_size=label_size)
    regime_text = is_trending ? "ðŸ“ˆ TREND" : is_mean_reverting ? "ðŸ”„ REVERT" : "ðŸŽ² RANDOM"
    regime_color = is_trending ? dc_green : is_mean_reverting ? dc_red : dc_aqua
    table.cell(dashboard_enhanced, 1, current_row, regime_text, text_color=regime_color, text_size=label_size)       
    table.cell(dashboard_enhanced, 2, current_row, "Hurst Exp", text_color=dc_gray, text_size=label_size)
    table.cell(dashboard_enhanced, 3, current_row, str.tostring(hurst_smoothed, "#.###"), 
              text_halign=text.align_right, text_color=dc_purple, text_size=label_size)
    current_row += 1
//==============================================================================
// ðŸ”” ALERTS
//==============================================================================
alertcondition(long_signal, "TMAE Sell Signal", "Tensor Market Analysis Engine: Sell Entry Signal")
alertcondition(short_signal, "TMAE Buy Signal", "Tensor Market Analysis Engine: Buy Entry Signal")
alertcondition(volatility_jump, "Volatility Jump", "Multi-dimensional volatility jump detected")
alertcondition(is_trending and not is_trending[1], "Regime: Trending", "Market entered trending regime")
alertcondition(is_mean_reverting and not is_mean_reverting[1], "Regime: Mean Reverting", "Market entered mean reverting regime")
alertcondition(volume_leads and not volume_leads[1], "Volume Leading", "Volume now leading price - potential move incoming")