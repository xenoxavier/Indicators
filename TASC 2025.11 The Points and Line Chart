TASC 2025.11 The Points and Line Chart



//  TASC Issue: November 2025
//     Article: Efficient Display Of Irregular Time Series
//              The Points & Line Chart
//  Article By: Mohamed Ashraf Mahfouz, CETA, CFTe, MFTA
//              Mohamed Meregy, CETA, CFTe
//    Language: TradingView's Pine Script® v6
// Provided By: PineCoders, for tradingview.com

//@version=6
indicator(
     "TASC 2025.11 The Points and Line Chart", "P&L Chart",
     max_lines_count = 500, 
     max_boxes_count = 500, 
     max_labels_count = 500
 )


//#region   --- UDTs and enums ---

// @type  A custom type for storing candle information.
type Candle
    float o
    float h
    float l
    float c
    float v
    int t
    int d

// @enum  An enumeration of scale size methods.
enum SCALE
	Default
	ATR
	Percent

// @enum  An enumeration of P&L filter methods.
enum METHOD
	Point = "Point Size"
	HL    = "High Low"
	Close = "Close"

// @enum  An enumeration of price display options.
enum PD
    Line
    Candles
    None

// @enum  An enumeration of pane display options. 
enum DD
    Volume
    Days
    None
//#endregion


//#region   --- Inputs ---

string TT_SS = "Method for filtering price moves:
     \n- 'Default' uses an automatic scale size based on predefined values.
     \n- 'ATR' uses Average True Range with a specified length.
     \n- 'Percent' uses a specified change percentage."
string TT_OC = "If enabled, the P&L drawing appears
         on the main chart pane. Othewise, it appears
         in a separate pane. If the drawing is hidden by
         the histogram, set 'Data display' to 'None'."
 
string GROUP1 = "P&L calculation settings"
int rxValue = input.int(
     3, 
     title   = "Reversal amount:", 
     minval  = 1, 
     maxval  = 20, 
     tooltip = "The number of points required for direction to change.", 
     group   = GROUP1
 )
SCALE scaleType = input.enum(
     SCALE.Default, 
     title   = "Scale size method: ", 
     tooltip = "Method for filtering price moves.", 
     inline  = "st", 
     group   = GROUP1
 )
int atrLength = input.int(
     14, "", 
     minval  = 1,
     inline  = "st", 
     active  = scaleType == SCALE.ATR, 
     group   = GROUP1
 )
float percentage = input.float(
     1.0, 
     title   = "", 
     minval  = 0.5, 
     maxval  = 50, 
     step    = 1, 
     tooltip = TT_SS, 
     inline  = "st", 
     active  = scaleType == SCALE.Percent, 
     group   = GROUP1
 )
METHOD iMethod = input.enum(
     METHOD.Point, "P&L Method:", 
     tooltip = "Method for calculating P&L prices.", 
     group   = GROUP1
 )

string GROUP2 = "Display settings"
bool onChart = input.bool(
     true, 
     title   = "Overlay P&L on chart",
     tooltip = TT_OC, 
     group   = GROUP2
 )
PD priceDisplay = input.enum(
     PD.Line, 
     title   = "Price display", 
     group   = GROUP2
 )
DD dataDisplay = input.enum(
     DD.Volume, 
     title   = "Data display", 
     group   = GROUP2
 )
//#endregion


//#region   --- Functions ---

// @function        Rounds a number to the nearest multiple of a given step size.
// @param source    The source value to round.
// @param step      The rounding step size.
// @returns         The rounded value.
roundTo(float source, float step) =>
    math.round(source / step) * step

// @function        Constructs a string representation of `Candle` data for 
//                  drawing tooltips.
// @param candle    The ID of a `Candle` object.
// @returns         A string representing the object's formatted data.
formatTT(Candle candle) =>
    date = str.format_time(candle.t, "MM/dd/yy HH:mm")
    d    = str.tostring(candle.d)  + " Day" + (candle.d == 1 ? "" : "s")
    o    = "O: " + str.tostring(candle.o,format.mintick)
    h    = "H: " + str.tostring(candle.h,format.mintick)
    l    = "L: " + str.tostring(candle.l,format.mintick)
    c    = "C: " + str.tostring(candle.c,format.mintick)
    v    = "V: " + str.tostring(candle.v,format.volume)
    date + "\n" + d + "\n" + o + "\n" + h + "\n" + l + "\n" + c + "\n" + v

// @function        Draws a tooltip to display `Candle` information.
// @param candle    The ID of the `Candle` object.
// @param t         The UNIX timestamp on which to anchor the label.
// @param txt       The text for the label. Defines the hover region's size.
// @param atC       If `true`, the label anchors to the object's `c` value. 
//                  If `false`, it anchors to the average of `o` and `c`.
// @param fo        If `true`, the drawing is on the main chart.
//                  If `false`, the drawing is in a separate pane.
// @returns         Label ID.
drawTooltip(Candle candle, int t, string txt, bool atC, bool fo) =>
    float p = atC ? candle.c : math.avg(candle.o, candle.c)
    if fo
        label.new(
             t, math.avg(candle.o, candle.c), txt, xloc.bar_time, 
             color = #00000000, textcolor = #00000000, 
             style = label.style_label_center, 
             tooltip = formatTT(candle), force_overlay = true
         )
    else
        label.new(
             t, math.avg(candle.o, candle.c), txt, xloc.bar_time, 
             color = #00000000, textcolor = #00000000, 
             style = label.style_label_center, 
             tooltip = formatTT(candle)
         )

// @function        Creates a candle drawing from a `Candle` object.
// @param candle    The ID of the `Candle` object.
// @param t         The UNIX timestamp at which to anchor the candle.
// @param fo        If `true`, the drawing is on the main chart.
//                  If `false`, the drawing is in a separate pane.
drawCandle(Candle candle, int t, bool fo) =>
    color col = candle.c > candle.o ? color.green : color.red
    if fo
        line.new(
             t, candle.h, t, candle.l, xloc.bar_time, color = col, 
             width = 1, force_overlay = true 
         )
        box.new(
             t, candle.o, t, candle.c, xloc = xloc.bar_time, 
             border_color = col, border_width = 3,
             bgcolor = col, force_overlay = true
         )
    else
        line.new(
             t, candle.h, t, candle.l, xloc.bar_time, color = col, 
             width = 1
         )
        box.new(
             t, candle.o, t, candle.c, xloc = xloc.bar_time, 
             border_color = col, border_width = 3,
             bgcolor = col
         )

// @function        Queues a new chart point into an array, removing 
//                  the oldest point if the array's size exceeds 10K.
// @param this      The ID of the array to update.
// @param t         The timestamp of the new point.
// @param p         The price of the new point.
// @returns         The removed element, or `na` if no element is removed.
method queuePoint(array<chart.point> this, int t, float p) =>
    this.unshift(chart.point.from_time(t, p))
    if this.size() > 10000
        this.pop()
//#endregion


//#region   --- Calculations ---

// @variable References a `Candle` object for tracking current data.
var Candle can = Candle.new(open, high, low, close, na, time, na)
// @variable Tracks the current P&L direction.
var int dir = -1
// @variable Tracks the latest P&L price. 
var float lastPoint = close
// @variable Tracks the current P&L bar's total volume.
var float vol = volume
// @variable Tracks the total days/bars in the current candle P&L bar.
var int day = 0

// Create arrays for storing P&L data.
var array<Candle> data      = array.new<Candle>()  // Candle data
var array<float>  volArray  = array.new_float()    // Volume data
var array<float>  dayArray  = array.new_float()    // Days data
var array<int>    timeArray = array.new_int()      // Time data

// Get the box size multiplier for "ATR" and "Default" scale types. 
var array<float> limits = array.from(
     0.25, 0.5, 1, 5, 20, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 10e8
 ) 
var array<float> sizes = array.from(
     0.025, 0.05, 0.1, 0.25, 0.5, 1, 2, 5, 10, 20, 50, 100, 200, 500
 ) 
float boxSize = sizes.get(limits.binary_search_rightmost(close)) 

// @variable The box range value.
float boxRange = switch scaleType
	SCALE.ATR     => nz(ta.atr(atrLength), boxSize)
	SCALE.Default => boxSize
	SCALE.Percent => close * percentage / 100.0

// Get filter and plot prices based on the selected method. 
[filterPriceUp, filterPriceDn, plotPriceUp, plotPriceDn] = switch iMethod
    METHOD.Point =>
        float rounded = roundTo(close, boxRange)
        [close, close, rounded, rounded]
    METHOD.Close =>
        [close, close, close, close]
    METHOD.HL =>
        [high, low, high, low]

// Main P&L logic
if dir != -1
    switch
        filterPriceUp - lastPoint > boxRange =>
            data.unshift(
                 Candle.new(
                     can.o, can.h, can.l, plotPriceUp, vol, can.t, day
                 )
             )
            volArray.unshift(vol)
            dayArray.unshift(day)
            lastPoint := plotPriceUp
            can       := Candle.new(open, high, low, close, 0, time, 0)
            vol       := 0
            day       := 0
        filterPriceUp - lastPoint <= boxRange * -rxValue =>
            data.unshift(
                 Candle.new(
                     can.o, can.h, can.l, plotPriceDn, vol, can.t, day
                 )
             )
            volArray.unshift(vol)
            dayArray.unshift(day)
            lastPoint := plotPriceDn
            can       := Candle.new(open, high, low, close, 0, time, 0)
            vol       := 0
            day       := 0
            dir       := -1
if dir != 1 
    switch
        lastPoint - filterPriceDn > boxRange =>
            data.unshift(
                 Candle.new(
                     can.o, can.h, can.l, plotPriceDn, vol, can.t, day))
            volArray.unshift(vol)
            dayArray.unshift(day)
            lastPoint := plotPriceDn
            can       := Candle.new(open, high, low, close, 0, time, 0)
            vol       := 0
            day       := 0
        lastPoint - filterPriceDn <= boxRange * -rxValue =>
            data.unshift(
                 Candle.new(
                     can.o, can.h, can.l, plotPriceUp, vol, can.t, day
                 )
             )
            volArray.unshift(vol)
            dayArray.unshift(day)
            lastPoint := plotPriceUp
            can       := Candle.new(open, high, low, close, 0, time, 0)
            vol       := 0
            day       := 0
            dir       := 1

// Accumulate volume and days.
vol += volume
day += 1
// Update the current `Candle` object's high and low. 
if high > can.h
    can.h := high
if low < can.l
    can.l := low
// Queue a new `time` value through the time array. 
timeArray.unshift(time)
while timeArray.size() > data.size()
    timeArray.pop()
//#endregion


//#region   --- Display ---

if barstate.islast
    // Delete all active drawings.
    for bx in box.all
        bx.delete()
    for ln in line.all
        ln.delete()
    for lab in label.all
        lab.delete()
    for pln in polyline.all
        pln.delete()

    // Create chart point arrays for polyline drawings.
    array<chart.point> plArray       = array.new<chart.point>()  // P&L points
    array<chart.point> upHistArray   = array.new<chart.point>()  // Upward histogram points
    array<chart.point> downHistArray = array.new<chart.point>()  // Downward histogram points
    array<chart.point> basePLArray   = array.new<chart.point>()  // Histogram base points
    
    //P&L drawing logic
    switch priceDisplay
        // Candle display
        PD.Candles =>
            for i = data.size() - 1 to 0  
                Candle cdl  = data.get(i)
                int    tVal = timeArray.get(i)
                drawCandle(cdl, tVal, onChart)
                drawTooltip(cdl, tVal, "|\n|\n|", false, onChart)
        // Line display
        PD.Line =>
            for i = data.size() - 1 to 0 
                Candle cdl  = data.get(i)
                int    tVal = timeArray.get(i)
                plArray.queuePoint(tVal, cdl.c)
                drawTooltip(cdl, tVal, "|\n|\n|", false, onChart)
            if onChart
                polyline.new(
                     plArray, 
                     line_color    = color.blue, 
                     xloc          = xloc.bar_time, 
                     force_overlay = true
                 )
            else
                polyline.new(
                     plArray, 
                     line_color = color.blue, 
                     xloc       = xloc.bar_time
                 )
    
    // Histogram drawing logic
    switch dataDisplay
        // Volume display
        DD.Volume =>
            for i = volArray.size() - 1 to 0
                Candle cdl  = data.get(i)
                int    tVal = timeArray.get(i)
                float  p    = volArray.get(i)
                [upVal, dnVal] = switch
                    cdl.c > cdl.o => [p, 0.0]
                    =>               [0.0, p]
                upHistArray.  queuePoint(tVal, 0.0)
                upHistArray.  queuePoint(tVal, upVal)
                upHistArray.  queuePoint(tVal, 0.0)
                downHistArray.queuePoint(tVal, 0.0)
                downHistArray.queuePoint(tVal, dnVal)
                downHistArray.queuePoint(tVal, 0.0)
                basePLArray.  queuePoint(tVal, 0.0)
            polyline.new(
                 upHistArray,
                 xloc       = xloc.bar_time, 
                 line_color = color.green
             )
            polyline.new(
                 downHistArray, 
                 xloc       = xloc.bar_time, 
                 line_color = color.red
             )
            polyline.new(
                 basePLArray,
                 xloc       = xloc.bar_time,
                 line_color = chart.bg_color,
                 line_width = 3
             )
        // Days display
        DD.Days =>
            for i = dayArray.size() - 1 to 0
                Candle cdl  = data.get(i)
                int    tVal = timeArray.get(i)
                float  p    = dayArray.get(i)
                [upVal, dnVal] = switch
                    cdl.c > cdl.o => [p, 0.0]
                    =>               [0.0, p]
                upHistArray.  queuePoint(tVal, 0.0)
                upHistArray.  queuePoint(tVal, upVal)
                upHistArray.  queuePoint(tVal, 0.0)
                downHistArray.queuePoint(tVal, 0.0)
                downHistArray.queuePoint(tVal, dnVal)
                downHistArray.queuePoint(tVal, 0.0)
                basePLArray.  queuePoint(tVal, 0.0)
            polyline.new(
                 upHistArray, 
                 xloc = xloc.bar_time, 
                 line_color = color.green
             )
            polyline.new(
                 downHistArray, 
                 xloc = xloc.bar_time, 
                 line_color = color.red
             )
            polyline.new(
                 basePLArray,
                 xloc       = xloc.bar_time,
                 line_color = chart.bg_color,
                 line_width = 3
             )
//#endregion
